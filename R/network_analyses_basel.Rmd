---
title: "R Notebook"
output: html_notebook
---

#Read in tumor community data from Matlab (topological single-cell communities were extracted using the Matlab wrapper of the C++ Louvain implementation) including only tumor cells
```{r}
#Tumor communities
nodules = fread('/home/ubuntu/tmp/server_homes/janaf/Data/2019/Data_publication/BaselTMA/Communities/Communtiy_data_tumor.csv',header = T)

# #Adjust naming only first time when reading from Matlab (provided data is already cleaned)
# test = unique(nodules$core)
# split_core = strsplit(nodules$core,'_', fixed = TRUE)
# nodules$core = unlist(lapply(split_core, function(x){paste(x[c(1,2,8,9,10)],collapse =  "_")}))
# #Replace the ones that don't need acquisition number again
# short = unlist(lapply(strsplit(test,'_', fixed = TRUE),function(x){paste(x[c(1,2,8,9)],collapse =  "_")}))
# duplicate_idx = duplicated(short) | duplicated(short, fromLast = TRUE)
# in_cores_index = unlist(lapply(unique(nodules$core)[duplicate_idx],function(x){which(nodules$core %in% x)}))
# nodules$core[setdiff(1:length(nodules$core),in_cores_index)] = unlist(lapply(strsplit(nodules$core[setdiff(1:length(nodules$core),in_cores_index)],'_', fixed = TRUE), function(x){paste(x[1:length(x)-1],collapse =  "_")}))
# #Delete zeros from core names
# nodules$core = unlist(lapply(nodules$core,function(x){gsub("000","",x)}))

#Threshold for only communities of at least a certain size
nodules[,size_comm := .N, by = c('Community','core')]
nodules = nodules[size_comm > 9,]

#Calculate number of cells from each metacluster per community (community numbers are only unique per core)
colnames(nodules)[colnames(nodules) == 'Pheno'] = 'metacluster'
nodules[,ncells := .N , by = c('Community','metacluster','core')]
nodules[,perc_cluster := ncells/size_comm, by = c('Community','core')]

#Keep as separate variables for later
save_size = unique(nodules[,c('core','Community','size_comm')])
nodules_orig = nodules

#Set missing cells types to 0
nodules <- unique(nodules[,c("core","metacluster","ncells","Community")])
nodules$metacluster = factor(nodules$metacluster, levels = sort(unique(nodules$metacluster)))
nodules_wide = dcast.data.table(nodules,formula = 'Community + core ~ metacluster',value.var = 'ncells',fill = 0)
nodules_wide_not_norm = nodules_wide

```

#PG cluster tumor communtities
```{r}

#01-normalize absolute metacluster cell numbers of each community per metacluster
nodules_wide = cbind( nodules_wide[,c('Community','core')],apply(nodules_wide[,-c('Community','core')],2, function(x){(x-min(x))/(max(x)-min(x))}))

#Run PhenoGraph
rand_seed = 3
rpheno_out = cytofkit::Rphenograph(nodules_wide[,-c('Community','core')], k = 80, seed = rand_seed,approx = T)
nodules_wide$cluster = rpheno_out$membership

##Save out PG results
#fwrite(nodules_wide[,c('core','Community','cluster')],'PG_basel_epi_final.csv',col.names = T)

#Read in previous PG result
cl_dat = fread('/home/ubuntu/tmp/server_homes/janaf/Data/2019/Data_publication/BaselTMA/Communities/PG_tumor_communities.csv',header = T)
nodules_wide = merge(nodules_wide,cl_dat,by = c('Community','core'))
```

#Heatmap of metacluster content of each tumor community
```{r}

nodules_long = melt.data.table(nodules_wide, id.vars = c('Community','cluster','core') ,variable.name = 'channel', value.name = 'perc_cluster')
summary_dat = nodules_long[ ,list(
  mean_val= mean(perc_cluster),
  cell_cluster=.N),
  by=.(channel,cluster)]
hm_dat = dcast.data.table(data =summary_dat, formula = 'cluster ~ channel',
                          value.var = 'mean_val') #can be exchanged for 'median_val'

#Convert to matrix
trownames = hm_dat$cluster
hm_dat = as.matrix(hm_dat[,-1,with=F])
row.names(hm_dat) = trownames

#Set color map
cols = rev(brewer.pal(11,'Spectral'))
cmap = colorRampPalette(cols)

#Hierarchical clustering on rows with Ward's linkage
tdist = as.dist(1-cor(t(hm_dat), method="spearman"))
hr <- hclust(tdist, method="ward.D2")
co_r <- order.optimal(tdist, hr$merge)
hr$merge = co_r$merge
hr$order = co_r$order

#Order rows in heatmap according to clustering
order_heatmap_zscored = row.names(hm_dat)[hr$order]

# Hierarchical clustering on columns with Ward's linkage
tdist = as.dist(1-cor((hm_dat), method="spearman"))
hc <- hclust(tdist, method="ward.D2")
co_c <- order.optimal(tdist, hc$merge)
hc$merge = co_c$merge
hc$order = co_c$order

#Z-score data
p_dat = scale(hm_dat)

#Censor z-score at 2
p_dat[p_dat > 2] =2
p_dat[p_dat < -2] =-2

order_epi = hr$labels[hr$order]

heatmap.2(p_dat,
          scale ='none',
          trace = "none",
          col=cmap(75),
          dendrogram = "none",
          Rowv=F,
          Colv=as.dendrogram(hc),
          density.info ='none',
          cexRow=0.6,
          cexCol=0.6,
          margins=c(4,8),
          xlab = 'Markers',
          ylab ='Cluster',
          main = 'PG_norm_slide',
          colCol = c(mycols_basel_meta[14:27],'black'),
          colRow = col_vector)

# #If heatmap should be ordered according to patient content (bellow in pipeline)
# p_dat = p_dat[rev(o_epi),]
# heatmap.2(p_dat,
#           scale ='none',
#           trace = "none",
#           col=cmap(75),
#           dendrogram = "none",
#           Rowv=F,
#           Colv=as.dendrogram(hc),
#           density.info ='none',
#           cexRow=0.6,
#           cexCol=0.6,
#           margins=c(4,8),
#           xlab = 'Markers',
#           ylab ='Cluster',
#           main = 'PG_norm_slide',
#           colCol = c(mycols_basel_meta[14:27],'black'),
#           colRow = col_vector[rev(o_epi)]) #mycols_basel for small clusters


```

#tSNE of communities based on metacluster cell content
```{r}
#Remove duplicates
dat_tsne = nodules_wide[!duplicated(nodules_wide[,-c('Community','core','cluster')])] 

#Run tSNE
require(doParallel)
cores = 10
options('mc.cores' = cores)
registerDoParallel(cores)
tsne_comm <- Rtsne.multicore::Rtsne.multicore(dat_tsne[,-c('Community','core','cluster')], 
            verbose = T, dims = 2, num_threads = 10)
  
#Write out tSNE results
#fwrite(tsne_comm$Y,'tsne_basel_epi.csv',col.names = F)

#Read in saved tsne run
tsne_comm = fread('/home/ubuntu/tmp/server_homes/janaf/Data/2019/Data_publication/BaselTMA/Communities/tsne_tumor_communities.csv')

dat_tsne = merge(dat_tsne,tsne_comm,by = c('Community','core'))
dat_tsne = merge(unique(Sample_metadata[,c('core','PID')]),dat_tsne,by = 'core')
dat_tsne$PID = as.character(dat_tsne$PID)
dat_tsne = merge(dat_tsne,meta_patient_clustering,by = 'PID')
dat_tsne$patient_pheno = as.factor(dat_tsne$patient_pheno)

#SCP patient groups on community tsne
p = dat_tsne%>%
  ggplot(aes(x=V1, y=V2))+
  geom_point(size=1, alpha=0.8, aes(color=patient_pheno))+
  labs(colour="Patients")+
  scale_color_manual(values = mycols_patient)+
  ggtitle('Phenograph')+
  guides(color=guide_legend(override.aes=list(size=5)))+
  theme(strip.background = element_blank(),
        panel.background=element_rect(fill='white', colour = 'black'),
        panel.grid.major=element_blank(),
        panel.grid.minor=element_blank(),
        plot.background=element_blank(),
        legend.key = element_blank())

pdf('tsne_communities_colorSCP.pdf',width = 10,height = 10)
p
dev.off()

#Community tsne colored by community type (based on PG clustering), color = majority cell type, opacity = number of cells
dat_tsne$cluster = factor(dat_tsne$cluster,levels = order_epi)
p = dat_tsne%>%
  ggplot(aes(x=V1, y=V2))+
  geom_point(size=1, aes(color=cluster,alpha = cluster))+
  labs(colour="Patients")+
  scale_color_manual(values = mycols_basel_meta[c(21,15,26,20,19,17,20,14,18,25,27,24,24,22,19,22,23,20,25,16,25,22,23)][as.numeric(order_epi)])+
  scale_alpha_manual(values=c(1,1,1,1,1,1,0.5,1,1,1,1,1,0.5,1,0.5,0.3,0.5,0.3,0.3,1,0.5,0.5,1)[as.numeric(order_epi)])+
  ggtitle('Phenograph')+
  guides(color=guide_legend(override.aes=list(size=5)))+
  theme(strip.background = element_blank(),
        panel.background=element_rect(fill='white', colour = 'black'),
        panel.grid.major=element_blank(),
        panel.grid.minor=element_blank(),
        plot.background=element_blank(),
        legend.key = element_blank())

pdf('tsne_epithelial_communities_colorMajority.pdf',width = 10,height = 10)
p
dev.off()

#Overview of cell type fractions on community tSNE
melted = melt.data.table(dat_tsne,id.vars = c('PID','V1','V2','patient_pheno','cluster','Community','core'), measure.vars =colnames(dat_tsne)[!colnames(dat_tsne) %in%c('PID','V1','V2','patient_pheno','cluster','Community','core')], variable.name = 'channel', value.name = 'counts', na.rm=TRUE)
melted[, c_counts := bbRtools::censor_dat(counts,0.99), by=channel]
melted[, c_counts_scaled := ((c_counts - min(c_counts))/(max(c_counts) - min(c_counts))), by=channel]
melted[c_counts_scaled < 0, c_counts_scaled := 0, by=channel]


p = melted%>%
  ggplot(aes(x=V1, y=V2, color=c_counts_scaled))+
  facet_wrap(~channel, scales = "free", ncol = 7)+
  geom_point(alpha=1, size=1)+
  scale_color_gradientn(colours=rev(brewer.pal(11, 'Spectral')), name='Counts')+
  ggtitle('Marker overview')+
  scale_x_discrete(labels = abbreviate)+
  theme(strip.background = element_blank(),
        axis.line=element_blank(),
        axis.text.x=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_blank(),
        panel.border=element_blank(),
        panel.grid.major=element_blank(),
        panel.grid.minor=element_blank(),
        plot.background=element_blank()) 

pdf("tsne_cell_type_fractions.pdf",width = 30,height = 10)
p
dev.off()
```

#Stacked bars showing absolute numbers of cells of each metacluster per community type
```{r}
cl_dat = fread('/home/ubuntu/tmp/server_homes/janaf/Data/2019/Data_publication/BaselTMA/Communities/PG_tumor_communities.csv',header = T)
nodules_wide_not_norm = merge(nodules_wide_not_norm,cl_dat,by = c('Community','core'))
nodules_long = melt.data.table(nodules_wide_not_norm, id.vars = c('Community','cluster','core') ,variable.name = 'channel', value.name = 'perc_cluster')

summary_dat = nodules_long[ ,list(
  mean_val= mean(perc_cluster),
  #std_val = std(perc_cluster),
  cell_cluster=.N),
  by=.(channel,cluster)]

hm_dat = dcast.data.table(data =summary_dat, formula = 'cluster ~ channel',
                          value.var = 'mean_val') #can be exchanged for 'median_val'

#Bars ordered according to heatmap (above)
d = unique(summary_dat[,c('channel','cluster','mean_val')])
p <- ggplot(d, aes(x=factor(cluster,levels = order_epi), y=mean_val, fill=factor(channel))) + 
  geom_bar(stat='identity',show.legend = TRUE)+
  scale_fill_manual("Clusters",values =  c(mycols_basel_meta[14:27],'black'))+ 
  labs(fill = "Clusters")+
  coord_flip()+
  xlab("Patient")+
  ylab("Percentage of cluster cells in patient")+
  theme(panel.background = element_blank(),
        axis.text.y = element_text(colour=col_vector[as.numeric(order_epi)]))+
  ggtitle('Patient composition')

pdf('/home/jana/Desktop/R_dat/comm_cluster_compositions.pdf',width = 10,height = 10)
p
dev.off()


# #For ordering according to patient composition use o_epi (generated bellow in pipeline)
# p <- ggplot(d, aes(x=factor(cluster,levels = o_epi), y=mean_val, fill=factor(channel))) + 
#   geom_bar(stat='identity',show.legend = TRUE)+
#   scale_fill_manual("Clusters",values =  c(mycols_basel_meta[14:27],'black'))+ 
#   labs(fill = "Clusters")+
#   coord_flip()+
#   xlab("Patient")+
#   ylab("Percentage of cluster cells in patient")+
#   theme(panel.background = element_blank(),
#         axis.text.y = element_text(colour=col_vector[ o_epi]))+
#   ggtitle('Patient composition')

```

#Clustered heatmaps of community type make up of each patient
```{r}
#Automatically clustered on rows and columns based on community type content of patients
nodules_wide = merge(unique(Sample_metadata[,c('core','PID')]),nodules_wide,by = 'core')
nodules_wide$PID = as.character(nodules_wide$PID)
if (sum(meta_patient_clustering$patient_pheno == 18) == 0){
  meta_patient_clustering = rbind(meta_patient_clustering, data.frame(PID = c('93','276','200'), patient_pheno = rep('18',3)))
}
meta_patient_clustering$PID = as.character(meta_patient_clustering$PID)
nodules_wide = merge(nodules_wide,meta_patient_clustering,by = 'PID')
nodules_wide$PID = as.character(nodules_wide$PID)
nodules_wide$patient_pheno = as.factor(nodules_wide$patient_pheno)
enrichment = unique(nodules_wide[,c('cluster','PID','Community','core')])
enrichment[,both := .N, by = c('cluster','PID')]
enrichment[,frac_patient := both/.N, by = c('PID')]
enrichment = unique(enrichment[,c('PID','cluster','frac_patient')])
d = dcast.data.table(enrichment,formula = 'PID  ~ cluster',value.var = 'frac_patient',fill = 0)
d_mat = as.matrix(d[,-'PID'])
rownames(d_mat) = d$PID
d = merge(d, meta_patient_clustering,by = 'PID')

h = Heatmap(d_mat, name = "Clustergram", km = 1, col = colorRamp2(c(0, 1), c("white", "red")),
     show_row_names = T, show_column_names =  T, clustering_method_rows = "ward.D2",clustering_method_columns = "ward.D2")+

Heatmap(factor(d$patient_pheno), name = "Patientgroups", show_row_names = FALSE, width = unit(10, "mm"), col = structure(mycols_patient, names = c(as.character(1:18))))

pdf('epithelial_communities_perPatient_SCP_colorbar.pdf',width = 10, height = 20)
h
dev.off()


#Rows ordered according to stacked barplot (Figure 3)
missing = patient_cluster_all$PID[!patient_cluster_all$PID %in% rownames(d_mat)]
add_mat = matrix(data=0,nrow=length(missing),ncol=ncol(d_mat))
rownames(add_mat) = missing
d_mat = rbind(d_mat,add_mat)
d_mat = d_mat[order(match(rownames(d_mat),patient_cluster_all$PID)),]
d_mat = d_mat[rev(rownames(d_mat)),]
h = Heatmap(d_mat, name = "Clustergram", km = 1, col = colorRamp2(c(0, 1), c("white", "red")),
     show_row_names = T, show_column_names =  T,cluster_rows = FALSE,clustering_method_columns = "ward.D2")

#Save order to adapt order of heatmap/stacked bar plot if necessary (above)
o_epi = column_order(h)

pdf('ordered_sbp.pdf',width = 10, height = 20)
h
dev.off()

#Rows ordered according to stacked barplot (Figure 3) and columns ordered acoording to heatmap of metacluster content in each community type
missing = patient_cluster_all$PID[!patient_cluster_all$PID %in% rownames(d_mat)]
add_mat = matrix(data=0,nrow=length(missing),ncol=ncol(d_mat))
rownames(add_mat) = missing
d_mat = rbind(d_mat,add_mat)
d_mat = d_mat[order(match(rownames(d_mat),patient_cluster_all$PID)),]
d_mat = d_mat[rev(rownames(d_mat)),]
d_mat = d_mat[,order_epi]
h = Heatmap(d_mat, name = "Clustergram", km = 1, col = colorRamp2(c(0, 1), c("white", "red")),
     show_row_names = T, show_column_names =  T,cluster_rows = FALSE,cluster_columns = FALSE)

pdf('ordered_sbp_and_epiHeatmap.pdf',width = 10, height = 20)
h
dev.off()

```

#Survival on tumor community type densities
```{r}
#Prepare
surv = unique(nodules_wide[,c('PID','cluster','Community','core')])
surv[,nr_both := .N, by = c('cluster','core')]
surv = merge(surv,unique(Sample_metadata[,c('core','area')]),by = 'core')
surv[,nodule_area := nr_both/area, by = 'core']
surv[,nodule_area_patient := mean(nodule_area),by = c('PID','cluster')]
surv = unique(surv[,c('PID','cluster','nodule_area_patient')])
surv = dcast.data.table(surv,'PID ~ cluster',fill = 0)
Sample_metadata$PID = as.character(Sample_metadata$PID)
surv = merge(unique(Sample_metadata[,c('PID','OSmonth','Patientstatus')]),surv,by = 'PID')
surv = surv[!is.na(surv$OSmonth),]
colnames(surv)[-c(1:3)] = paste0('cluster_',colnames(surv)[-c(1:3)])

#Change Unit so the density values are well above 1 (setting zeros to 1 after so they will be zeros again after log, zeros represent complete absence of a community type -> should stay zero)
surv = cbind(surv[,c(1:3)],data.table(as.matrix(surv[,-c(1:3)]) * 10000000))

#log transform density values
bin = surv[,-c(1:3)]
#bin = log1p(bin)
bin[bin == 0] = 1
bin = log(bin)
surv = cbind(surv[,c(1:3)],bin)


#Adjust censoring depending on whether you are interested in overal or disease free survival (here overal)
surv$censoring[str_detect(surv$Patientstatus,'death by primary disease')] = 1
surv$censoring[is.na(surv$censoring)] = 0

res.cox2 <- coxph(Surv(surv$OSmonth, surv$censoring) ~ cluster_1 + cluster_2  + cluster_3  + cluster_4 + cluster_5 + cluster_6 + cluster_7 + cluster_8 + cluster_9 + cluster_10  + cluster_11 + cluster_12 +cluster_13 +cluster_14 +cluster_15 +cluster_16 +cluster_17  +cluster_18  +cluster_19  +cluster_20  +cluster_21  +cluster_22  +cluster_23 , data =  surv)
summary(res.cox2)

```


#Read in microenvironment community data from Matlab (topological single-cell communities were extracted using the Matlab wrapper of the C++ Louvain implementation) including all cells (but tumor metacluster agnostic -> all tumor cells are assigned to the same cell type (Pheno = 100))
```{r}
nodules = fread('/home/ubuntu/tmp/server_homes/janaf/Data/2019/Data_publication/BaselTMA/Communities/Communtiy_data_microenvironment.csv',header = T)

# #Adjust naming only first time when reading from Matlab (provided data is already cleaned)
# test = unique(nodules$core)
# split_core = strsplit(nodules$core,'_', fixed = TRUE)
# nodules$core = unlist(lapply(split_core, function(x){paste(x[c(1,2,8,9,10)],collapse =  "_")}))
# #Replace the ones that don't need acquisition number again
# short = unlist(lapply(strsplit(test,'_', fixed = TRUE),function(x){paste(x[c(1,2,8,9)],collapse =  "_")}))
# duplicate_idx = duplicated(short) | duplicated(short, fromLast = TRUE)
# in_cores_index = unlist(lapply(unique(nodules$core)[duplicate_idx],function(x){which(nodules$core %in% x)}))
# nodules$core[setdiff(1:length(nodules$core),in_cores_index)] = unlist(lapply(strsplit(nodules$core[setdiff(1:length(nodules$core),in_cores_index)],'_', fixed = TRUE), function(x){paste(x[1:length(x)-1],collapse =  "_")}))
# 
# #Delete zeros from core names
# nodules$core = unlist(lapply(nodules$core,function(x){gsub("000","",x)}))

#Calculate number of cells from each cell type per community (community numbers are only unique per core)
nodules[,size_comm := .N, by = c('Community','core')]
nodules[,ncells := .N , by = c('Community','Pheno','core')]
nodules[,perc_cluster := ncells/size_comm, by = c('core','Community')]

#Save variables for bellow in pipeline
save_size = unique(nodules[,c('core','Community','size_comm')])
nodules_orig = nodules

#Make missing cells types 0
nodules <- unique(nodules[,c("core","Pheno","ncells","Community")])
nodules$Pheno = factor(nodules$Pheno, levels = sort(unique(nodules$Pheno)))
nodules_wide = dcast.data.table(nodules,formula = 'Community + core ~ Pheno',value.var = 'ncells',fill = 0)
nodules_wide_not_norm = nodules_wide

```

#Run PG on microenvironment clusters
```{r}

#01-normalize absolute cell type numbers of each community per cel type
nodules_wide = cbind( nodules_wide[,c('Community','core')],apply(nodules_wide[,-c('Community','core')],2, function(x){(x-min(x))/(max(x)-min(x))}))

#PG for identifying different structures
rand_seed = 3
rpheno_out = cytofkit::Rphenograph(nodules_wide[,-c('Community','core')], k = 30, seed = rand_seed,approx = T)
nodules_wide$cluster = rpheno_out$membership


#fwrite(nodules_wide[,c('Community','cluster')],'/home/jana/Desktop/R_dat/PG_basel_stroma_final.csv',col.names = T)

cl_dat = fread('/home/jana/Desktop/R_dat/PG_basel_stroma_final.csv',header = T)#PG_comm_stromal_realk20_smallComm.csv #PG_basel_stroma2.csv
nodules_wide$cluster = cl_dat$cluster

#nodules_wide = merge(nodules_wide,cl_dat,by = c('core','Community'))

# sizes = merge(unique(nodules_wide[,c('core','cluster','Community')]),save_size,by = c('core','Community'))
# sizes[,avgsize := mean(size_comm),by = 'cluster']
# sizes = unique(sizes[,c('cluster','avgsize')])
# 
# #Fragmentation colorbar
# p10 <- ggplot(sizes, aes(x=1,y=c(1:length(sizes$avgsize))))+
#       geom_tile(aes( fill=sizes$avgsize))+
#   scale_fill_gradient2(low = "white", high = "red")+
#   geom_text(aes(label=sizes$cluster))+
#     theme(axis.title.x=element_blank(),
#           axis.text.x=element_blank(),
#           axis.ticks.x=element_blank(),
#           axis.title.y=element_blank(),
#           axis.text.y=element_blank(),
#           axis.ticks.y=element_blank(),
#           line = element_blank(),
#           legend.position="none")
# 
# pdf('/home/jana/Desktop/R_dat/Sies_stromal_clusters.pdf')
# p10
# dev.off()


#tsne
require(doParallel)
cores = 10
options('mc.cores' = cores)
registerDoParallel(cores)
dat_tsne = nodules_wide[!duplicated(nodules_wide[,-c('Community','core','cluster')])] 
tsne_comm <- Rtsne.multicore::Rtsne.multicore(dat_tsne[,-c('Community','core','cluster')], 
            verbose = T, dims = 2, num_threads = 10)

# #tsne
# tsne_comm = tsne(nodules_wide[,-c('Community','core','cluster')], initial_config = NULL, k = 2, initial_dims = 30, perplexity = 30,
# max_iter = 1000, min_cost = 0, epoch_callback = NULL, whiten = TRUE,
# epoch=100)

#fwrite(tsne_comm$Y,'/home/jana/Desktop/R_dat/tsne_stroma_basel_final.csv',col.names = F)

tsne_comm = fread('/home/jana/Desktop/R_dat/tsne_stroma_basel_final.csv')#tsne_comm_stromalk20_smallCommunities.csv

dat_tsne = cbind(dat_tsne,tsne_comm)
dat_tsne = merge(unique(Sample_metadata[,c('core','patientcode')]),dat_tsne,by = 'core')
dat_tsne = merge(dat_tsne,ME,by = 'patientcode')
dat_tsne = merge(dat_tsne,meta_patient_clustering,by = 'patientcode')

dat_tsne$cluster = factor(dat_tsne$cluster,hr$labels[hr$order])

p = dat_tsne%>%
  ggplot(aes(x=V1, y=V2))+
  geom_point(size=1, alpha=0.8, pch = 21, aes(color=cluster,fill = cluster))+
  labs(colour="Patients")+
  scale_color_manual(values = c(mycols_basel_meta,'black')[c(2,11,8,28,12,7,13,28,28,10,3,9,28,28,28,8,28,7,4,28,28,28,10,10,5,3,4,28,6,3)][as.numeric(hr$labels[hr$order])])+
  scale_fill_manual(values = c(mycols_basel_meta,'black')[c(2,11,8,28,12,7,13,8,10,9,3,9,7,28,10,8,28,28,3,28,28,28,9,10,5,9,4,10,6,7)][as.numeric(hr$labels[hr$order])])+
  ggtitle('Phenograph')+
  guides(color=guide_legend(override.aes=list(size=5)))+
  theme(strip.background = element_blank(),
        panel.background=element_rect(fill='white', colour = 'black'),
        panel.grid.major=element_blank(),
        panel.grid.minor=element_blank(),
        plot.background=element_blank(),
        legend.key = element_blank())

pdf('/home/jana/Desktop/R_dat/stroma_communities_tsne.pdf',width = 10,height = 10)
p
dev.off()

dat_tsne$groups = factor(dat_tsne$groups)
p = dat_tsne%>%
  ggplot(aes(x=V1, y=V2))+
  geom_point(size=1, alpha=0.8, aes(color=groups))+
  labs(colour="Patients")+
  scale_color_manual(values = col_vector)+
  ggtitle('Phenograph')+
  guides(color=guide_legend(override.aes=list(size=5)))+
  theme(strip.background = element_blank(),
        panel.background=element_rect(fill='white', colour = 'black'),
        panel.grid.major=element_blank(),
        panel.grid.minor=element_blank(),
        plot.background=element_blank(),
        legend.key = element_blank())

pdf('/home/jana/Desktop/R_dat/tsne_communities_colorTME.pdf',width = 10,height = 10)
p
dev.off()

#Overview of cell type fractions on patient tSNE

melted = melt.data.table(dat_tsne,id.vars = c('patientcode','V1','V2','patient_pheno','cluster','Community','core'), measure.vars =colnames(dat_tsne)[!colnames(dat_tsne) %in%c('patientcode','V1','V2','patient_pheno','cluster','Community','core')], variable.name = 'channel', value.name = 'counts', na.rm=TRUE)
melted[, c_counts := bbRtools::censor_dat(counts,0.995), by=channel]

melted[, c_counts_scaled := ((c_counts - min(c_counts))/(max(c_counts) - min(c_counts))), by=channel]
melted[c_counts_scaled < 0, c_counts_scaled := 0, by=channel]


p = melted%>%
  ggplot(aes(x=V1, y=V2, color=c_counts_scaled))+
  facet_wrap(~channel, scales = "free", ncol = 7)+
  geom_point(alpha=1, size=1)+
  scale_color_gradientn(colours=rev(brewer.pal(11, 'Spectral')), name='Counts')+
  ggtitle('Marker overview')+
  scale_x_discrete(labels = abbreviate)+
  theme(strip.background = element_blank(),
        axis.line=element_blank(),
        axis.text.x=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_blank(),
        panel.border=element_blank(),
        panel.grid.major=element_blank(),
        panel.grid.minor=element_blank(),
        plot.background=element_blank()) 

pdf("/home/jana/Desktop/R_dat/tsne_heatmap_stroma.pdf",
  width     = 30,
  height    = 10)
p
dev.off()


#Heatmap to interpret PG clusters
nodules_long = melt.data.table(nodules_wide, id.vars = c('Community','core','cluster') ,variable.name = 'channel', value.name = 'perc_cluster')
nodules_long$perc_cluster = as.double(nodules_long$perc_cluster)

set.seed(2)
summary_dat = nodules_long[ ,list(
  median_val = median(perc_cluster),
  mean_val= mean(perc_cluster),
  #std_val = std(perc_cluster),
  cell_cluster=.N),
  by=.(channel,cluster)]


hm_dat = dcast.data.table(data =summary_dat, formula = 'cluster ~ channel',
                          value.var = 'mean_val') #can be exchanged for 'median_val' 

#Bars next to heatmap
d = unique(summary_dat[,c('channel','cluster','mean_val')])

p <- ggplot(d, aes(x=factor(cluster,levels = hr$labels[hr$order]), y=mean_val, fill=factor(channel))) + #o_stroma$Clustergram
  geom_bar(stat='identity',show.legend = TRUE)+
  scale_fill_manual("Clusters",values =  c(mycols_basel_meta[1:13],'black'))+ 
  labs(fill = "Clusters")+
  coord_flip()+
  xlab("Patient")+
  ylab("Percentage of cluster cells in patient")+
  theme(panel.background = element_blank(),
        axis.text.y = element_text(colour=col_vector[as.numeric(hr$labels[hr$order])]))+
  ggtitle('Patient composition')



pdf('/home/jana/Desktop/R_dat/comm_cluster_compositions.pdf',width = 10,height = 10)
p
dev.off()


# Row names
trownames = hm_dat$cluster

# Convert to a matrix
hm_dat = as.matrix(hm_dat[,-1,with=F])
row.names(hm_dat) = trownames

# Set color map
cols = rev(brewer.pal(11,'Spectral'))
cmap = colorRampPalette(cols)

# Hierarchical clustering on rows with Ward's linkage
tdist = as.dist(1-cor(t(hm_dat), method="spearman"))
hr <- hclust(tdist, method="ward.D2")
co_r <- order.optimal(tdist, hr$merge)
hr$merge = co_r$merge
hr$order = co_r$order

# Order rows in heatmap according to clustering
order_heatmap_zscored = row.names(hm_dat)[hr$order]

# Hierarchical clustering on columns with Ward's linkage
tdist = as.dist(1-cor((hm_dat), method="spearman"))
hc <- hclust(tdist, method="ward.D2")
co_c <- order.optimal(tdist, hc$merge)
hc$merge = co_c$merge
hc$order = co_c$order

# Z-score data
p_dat = scale(hm_dat)

# Censor z-score at 2
p_dat[p_dat > 2] =2
p_dat[p_dat < -2] =-2

order_stroma = hr$labels[hr$order]

p_dat = p_dat[rev(o_stroma$Clustergram),]


pdf(file="/home/jana/Desktop/R_dat/stroma_node_heatmap_k20.pdf", width=10, height=10)

heatmap.2(p_dat,
          scale ='none',
          trace = "none",
          col=cmap(75),
          dendrogram = 'none',
          Rowv=F,
          Colv=as.dendrogram(hc),
          density.info ='none',
          cexRow=0.6,
          cexCol=0.6,
          margins=c(4,8),
          xlab = 'Markers',
          ylab ='Cluster',
          main = 'PG_norm_slide',
          colCol = c(mycols_basel_meta[1:13],'black'),
          colRow = col_vector[rev(o_stroma$Clustergram)]) #mycols_basel for small clusters

dev.off()






# #Enrichment of stromal community clusters and ME groups
# enrichment = unique(nodules_wide[,c('groups','cluster','Community','core')])
# enrichment[,nr_both := .N, by = c('cluster','groups')]
# enrichment[,perc_ME := nr_both/.N, by = c('groups')]
# enrichment[,perc_clus := nr_both/.N, by = c('cluster')]
# enrichment = unique(enrichment[,c('cluster','groups','perc_ME','perc_clus')])
# enrichment$cluster = factor(enrichment$cluster,hr$labels[hr$order])
# enrichment$groups = factor(enrichment$groups)
# test = enrichment[,c('perc_clus','cluster','groups')]
# 
# #Fraction of patients containing at least 1
# enrichment = unique(nodules_wide[,c('groups','cluster','patientcode')])
# enrichment[,both := .N, by = c('cluster','groups')]
# enrichment[,frac := both/length(unique(patientcode)), by = c('groups')]
# enrichment = unique(enrichment[,c('groups','cluster','frac')])
# enrichment$cluster = factor(enrichment$cluster,hr$labels[hr$order])
# enrichment$groups = factor(enrichment$groups)
# enrichment = merge(enrichment,test,by = c('groups','cluster'))



# p4 <- ggplot(enrichment,aes(y=cluster,x=groups))+
#   geom_point(aes(colour = perc_clus, 
#                  size =frac))  +   
# scale_color_gradient2(low = "blue",  
#                      mid = "white",
#                      high = "red",
#                      name = "Fraction of stromal community in TME group")+       
# scale_size(range = c(1, 15),name = "Fraction of patients in TME containing at least 1") +
#       theme(axis.text.y=element_text(color = col_vector[as.numeric(hr$labels[hr$order])]),panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
# panel.background = element_blank(), axis.line = element_line(colour = "black"))
# 
# pdf('/home/jana/Desktop/R_dat/stromalComm_TME_groups_flipped.pdf',width = 20, height = 10)
# p4
# dev.off()


#Clustergrams
nodules_wide = merge(unique(Sample_metadata[,c('core','patientcode')]),nodules_wide,by = 'core')
nodules_wide = merge(nodules_wide,ME,by = 'patientcode')
nodules_wide = merge(nodules_wide,meta_patient_clustering,by = 'patientcode')
enrichment = unique(nodules_wide[,c('cluster','patientcode','Community','core')])
enrichment[,both := .N, by = c('cluster','patientcode')]
enrichment[,frac_patient := both/.N, by = c('patientcode')]
enrichment = unique(enrichment[,c('patientcode','cluster','frac_patient')])
d = dcast.data.table(enrichment,formula = 'patientcode  ~ cluster',value.var = 'frac_patient',fill = 0)
d_mat = as.matrix(d[,-'patientcode'])
rownames(d_mat) = d$patientcode
d = merge(d, ME,by = 'patientcode')

hr = hclust(dist(d_mat), method = "ward.D2")
clusters = dendextend::cutree(hr, k = 11)

cnames = names(clusters)
neighb_clusters = data.table(cnames)
names(neighb_clusters) = 'core'
neighb_clusters$cluster = unlist(clusters)
neighb_clusters_orig = neighb_clusters

h = Heatmap(d_mat, name = "Clustergram", km = 1, col = colorRamp2(c(0, 1), c("white", "red")),
     show_row_names = T, show_column_names =  T, clustering_method_rows = "ward.D2",clustering_method_columns = "ward.D2",split = clusters)+

Heatmap(factor(d$group), name = "Patientgroups", show_row_names = FALSE, width = unit(10, "mm"), col = structure(col_vector, names = c(as.character(1:10))))
o_stroma = column_order(h)
o_patients = names(clusters[unlist(row_order(h))])

pdf('/home/jana/Desktop/R_dat/levels_stromalcommunities_ME_colors.pdf',width = 10, height = 20)
h
dev.off()

#icons
names(neighb_clusters_orig)[1] = 'patientcode'
icon = merge(merge(nodules_orig,unique(Sample_metadata[,c('core','patientcode')]),by = 'core'),neighb_clusters_orig,by = 'patientcode')
icon = unique(icon[,c('Pheno','ncells','core','Community','cluster')])
icon[,tot := sum(as.double(ncells)), by = c('cluster','Pheno')]
icon[,avg := tot/sum(tot), by = c('cluster')]


bp<- ggplot(icon, aes(x="", y=avg, fill=factor(Pheno)))+
geom_bar(width = 1, stat = "identity")+
  facet_wrap(~cluster, ncol = 5)+
  scale_fill_manual("Clusters",values =  c(mycols_basel_meta[1:13],'black'))+
    theme(strip.background = element_blank(),
        panel.background=element_rect(fill='white', colour = 'black'),
        panel.grid.major=element_blank(),
        panel.grid.minor=element_blank(),
        plot.background=element_blank(),
        legend.key = element_blank())


pdf('/home/jana/Desktop/R_dat/circle_icons.pdf',width = 10, height = 20)
bp
dev.off()


#order according to sbp
missing = patient_cluster_all$patientcode[!patient_cluster_all$patientcode %in% rownames(d_mat)]
add_mat = matrix(data=0,nrow=length(missing),ncol=ncol(d_mat))
rownames(add_mat) = missing
d_mat = rbind(d_mat,add_mat)

d_mat = d_mat[order(match(rownames(d_mat),patient_cluster_all$patientcode)),]
d_mat = d_mat[rev(rownames(d_mat)),]
h = Heatmap(d_mat, name = "Clustergram", km = 1, col = colorRamp2(c(0, 1), c("white", "red")),
     show_row_names = T, show_column_names =  T,cluster_rows = FALSE,clustering_method_columns = "ward.D2")

pdf('/home/jana/Desktop/R_dat/levels_ordered_sbp.pdf',width = 10, height = 20)
h
dev.off()



#Bubble plot next to sbp Figure3 at least one per patient
meta_patient_clustering_ext = rbind(meta_patient_clustering,data.frame(patientcode = c('UB_SX_000429','UB_SX_000153','UB_SX_000443'),patient_pheno = rep(18,3)))
nodules_wide = merge(unique(Sample_metadata[,c('core','patientcode')]),nodules_wide,by = 'core')
nodules_wide = merge(nodules_wide,ME,by = 'patientcode')
nodules_wide = merge(nodules_wide,meta_patient_clustering_ext,by = 'patientcode')
enrichment = unique(nodules_wide[,c('patient_pheno','cluster','patientcode')])
enrichment[,both := .N, by = c('cluster','patient_pheno')]
enrichment[,frac := both/length(unique(patientcode)), by = c('patient_pheno')]
enrichment = unique(enrichment[,c('patient_pheno','cluster','frac')])
enrichment$cluster = factor(enrichment$cluster,hr$labels[hr$order])

cluster_order[is.na(cluster_order)] = 18
enrichment$patient_pheno = factor(enrichment$patient_pheno,levels = unique(cluster_order))

#cluster columns
enrichment_wide = dcast.data.table(enrichment,'patient_pheno ~ cluster')
enrichment_wide[is.na(enrichment_wide)] = 0
clus_dat = as.matrix(t(enrichment_wide[,2:ncol(enrichment_wide)]))
dd <- dist(clus_dat, method = "euclidean")
hc <- hclust(dd, method = "ward.D2")


p4 <- ggplot(enrichment,aes(y=patient_pheno,x=factor(cluster, levels = hc$labels[hc$order]),color = patient_pheno))+
  geom_point(aes(size =frac))  +
  scale_color_manual(values = mycols_patient[as.numeric(unique(cluster_order))])+
# scale_color_gradient2(low = "blue",
#                      mid = "white",
#                      high = "red",
#                      name = "Fraction of stromal community in TME group")+
scale_size(range = c(1, 15),name = "Fraction of patients in TME containing at least 1") +
      theme(axis.text.x=element_text(color = col_vector[as.numeric(hc$labels[hc$order])]),panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
panel.background = element_blank(), axis.line = element_line(colour = "black"))

pdf('/home/jana/Desktop/R_dat/stromalComm_TME_groups_flipped.pdf',width = 20, height = 10)
p4
dev.off()


#Enrichment of stromal community clusters and patient groups
enrichment = unique(nodules_wide[,c('patient_pheno','cluster','Community','core')])
enrichment[,nr_both := .N, by = c('cluster','patient_pheno')]
enrichment[,perc_ME := nr_both/.N, by = 'patient_pheno']
enrichment[,perc_clus := nr_both/.N, by = 'cluster']
enrichment = unique(enrichment[,c('cluster','patient_pheno','perc_ME','perc_clus')])

enrichment$cluster = factor(enrichment$cluster,hr$labels[hr$order])

cluster_order[is.na(cluster_order)] = 18
enrichment$patient_pheno = factor(enrichment$patient_pheno,levels = unique(cluster_order))

#cluster columns
enrichment_wide = dcast.data.table(enrichment,'patient_pheno ~ cluster',value.var = 'perc_ME')
enrichment_wide[is.na(enrichment_wide)] = 0
clus_dat = as.matrix(t(enrichment_wide[,2:ncol(enrichment_wide)]))
dd <- dist(clus_dat, method = "euclidean")
hc <- hclust(dd, method = "ward.D2")


p4 <- ggplot(enrichment,aes(y=patient_pheno,x=factor(cluster, levels = hc$labels[hc$order]),color = patient_pheno))+
  geom_point(aes(size =perc_clus,alpha = perc_ME))  +
  scale_color_manual(values = mycols_patient[as.numeric(unique(cluster_order))])+
# scale_color_gradient2(low = "blue",
#                      mid = "white",
#                      high = "red",
#                      name = "Fraction of stromal community in TME group")+
scale_size(range = c(1, 15),name = "Fraction of community cluster in SCP") +
  scale_alpha(name = "Fraction of SCP communities of type comm cluster") +
      theme(axis.text.x=element_text(color = col_vector[as.numeric(hc$labels[hc$order])]),panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
panel.background = element_blank(), axis.line = element_line(colour = "black"))

pdf('/home/jana/Desktop/R_dat/stromalComm_TME_groups_flipped.pdf',width = 20, height = 10)
p4
dev.off()

```

#Kaplan Meiers for community clusters
```{r}
names(neighb_clusters)[1] = 'patientcode'
surv_comm = merge(neighb_clusters,unique(Sample_metadata[,c('patientcode','OSmonth','DFSmonth','Patientstatus')]),by = 'patientcode')
      

#Adjust censoring depending on whether you are interested in overal or disease free survival (here overal)
surv_comm$censoring[str_detect(surv_comm$Patientstatus,'death by primary disease')] = 1
surv_comm$censoring[is.na(surv_comm$censoring)] = 0

# surv_comm$censoring[str_detect(surv_comm$Patientstatus,'alive w metastases')] = 1
# surv_comm$censoring[is.na(surv_comm$censoring)] = 0
# surv_comm$censoring[surv_comm$OSmonth > surv_comm$DFSmonth] = 1 #uncomment for DFS

SurvObj <- Surv(surv_comm$OSmonth, surv_comm$censoring)
km.as.one <- survfit(SurvObj ~ 1)


#Plot the patient group survival curves next to each other
pdf('/home/jana/Desktop/R_dat/KaplanMeierComm_clusters.pdf',width = 20,height = 20)
par(mfrow=c(4,5))
for (i in unique(surv_comm$cluster)){
  cur = unique(surv_comm$cluster)[unique(surv_comm$cluster) == i]
  cur_dat = subset(surv_comm, surv_comm$cluster == cur)
  SurvObj_cur <- Surv(cur_dat$OSmonth, cur_dat$censoring)
  km.cur.group <- survfit(SurvObj_cur ~ cur_dat$cluster)
  plot(km.cur.group,mark.time = T,col = col_vector[cur],xlim=range(1:242))
  par(new=TRUE)
  plot(km.as.one,mark.time = T,col = "black",xlim=range(1:242))
  legend("bottomleft",1,cur,col_vector[cur], cex=3)
}
dev.off()




#Coxph to test sign difference of one group to rest
pdf('/home/jana/Desktop/R_dat/coxph_stromal_comm_OS.pdf',height = 15, width = 20)
for (i in c(1:11)){
  surv_comm$grp = NULL
  surv_comm$grp[surv_comm$cluster == i] = 1
  surv_comm$grp[is.na(surv_comm$grp)] = 0
  
  res.cox <- coxph(Surv(surv_comm$OSmonth, surv_comm$censoring) ~ grp, data =  surv_comm)
  textplot(capture.output(summary(res.cox)))
  title(as.character(i))
}
dev.off()

#logrank to test sign difference of one group to rest
pdf('/home/jana/Desktop/R_dat/one_vs_rest_sign_logrank_DFS.pdf',height = 10, width = 20)
for (i in c(1:11)){
  one_vs_others = NULL
  one_vs_others[surv_comm$cluster == i ] = 1
  one_vs_others[!(surv_comm$cluster == i)] = 0
  res = survdiff(Surv(surv_comm$DFSmonth, surv_comm$censoring) ~ one_vs_others)
  textplot(capture.output(res))
  title(as.character(i))
}
dev.off()

```


#Correlation with patientgroups and response
```{r}
meta_patient_clustering = fread(file='/home/jana/Desktop/R_dat/patient_groups_tumors_meta.csv', header = TRUE)
cors = merge(neighb_clusters,meta_patient_clustering,by = 'patientcode')

cors[,nr_both := .N, by = c('cluster','patient_pheno')]
cors[,perc_ME := nr_both/.N, by = c('cluster')]
cors[,perc_CT := nr_both/.N, by = c('patient_pheno')]

cors$cluster = factor(cors$cluster, levels = as.character(1:11))
cors$patient_pheno = factor(cors$patient_pheno)
colnames(cors)[1:3] = c('patientcode','StromalComm_groups','SCP_groups')

#plot
p4 <- ggplot(cors,aes(y=StromalComm_groups,x=SCP_groups))+
  geom_point(aes(colour = perc_ME, 
                 size =perc_CT))  +   
scale_color_gradient2(low = "blue",  
                     mid = "white",
                     high = "red",
                     name = "Fraction of Comm_cluster in SCP group")+       
scale_size(range = c(1, 15),name = "Fraction of SCP in Comm_cluster group") +
      theme(axis.text.x=element_text(color = c(mycols_patient)))

pdf('/home/jana/Desktop/R_dat/enrichment_commclusters_SCP_groups.pdf',width = 20, height = 10)
p4
dev.off()

#Enrichment stats

#Loop through all SCP/TME patient groups and test for all response types each one contains whether there is a significant enrichment
overview = list()
counter = 1
for (i in unique(cors$StromalComm_groups)){
  logic_vector = cors$StromalComm_groups == i
  MEs = unique(cors$SCP_groups[logic_vector])
  ME_vectors = lapply(MEs, function(x){cors$SCP_groups == x})
  res = lapply(ME_vectors, function(x){fisher.test(logic_vector,x,alternative = 'greater')})
  p = unlist(lapply(res, function(x){x$p.value}))
  CT_name = rep(i,length(MEs))
  ME_name = MEs
  #Correct for multiple testing
  adjusted_p = p.adjust(p, method = 'bonferroni', n = length(p))
  overview[[counter]] = cbind(CT_name,ME_name,adjusted_p)
  
  counter = counter + 1
}

d = data.table(do.call(rbind,overview))
colnames(d) = c('StromalCommRegion','SCP_groups','adjusted_p')
fwrite(d,file = '/home/jana/Desktop/R_dat/enrichment_p_vals_SCP_styromal_region.csv',col.names = T)

#Response
cors = merge(neighb_clusters_orig,unique(Sample_metadata[,c('patientcode','response')]),by = 'patientcode')
cors = cors[!response == '',]

cors[,nr_both := .N, by = c('cluster','response')]
cors[,perc_ME := nr_both/.N, by = c('cluster')]
cors[,perc_CT := nr_both/.N, by = c('response')]

cors$cluster = factor(cors$cluster, levels = as.character(1:11))
cors$response = factor(cors$response)
colnames(cors)[1:3] = c('patientcode','StromalComm_groups','Response')

#plot
p4 <- ggplot(cors,aes(y=StromalComm_groups,x=Response))+
  geom_point(aes(colour = perc_ME, 
                 size =perc_CT))  +   
scale_color_gradient2(low = "blue",  
                     mid = "white",
                     high = "red",
                     name = "Fraction of Comm_cluster in Response group")+       
scale_size(range = c(1, 15),name = "Fraction of Response in Comm_cluster group") +
      theme(axis.text.x=element_text(color = c(mycols_clinical)))

pdf('/home/jana/Desktop/R_dat/enrichment_commclusters_response_groups.pdf',width = 20, height = 10)
p4
dev.off()

#Enrichment stats

#Loop through all SCP/TME patient groups and test for all response types each one contains whether there is a significant enrichment
overview = list()
counter = 1
for (i in unique(cors$StromalComm_groups)){
  logic_vector = cors$StromalComm_groups == i
  MEs = unique(cors$Response[logic_vector])
  ME_vectors = lapply(MEs, function(x){cors$Response == x})
  res = lapply(ME_vectors, function(x){fisher.test(logic_vector,x,alternative = 'greater')})
  p = unlist(lapply(res, function(x){x$p.value}))
  CT_name = rep(i,length(MEs))
  ME_name = MEs
  #Correct for multiple testing
  adjusted_p = p.adjust(p, method = 'bonferroni', n = length(p))
  overview[[counter]] = cbind(as.data.table(CT_name),ME_name,adjusted_p)
  
  counter = counter + 1
}

d = data.table(do.call(rbind,overview))
colnames(d) = c('StromalCommRegion','Response_groups','adjusted_p')
fwrite(d,file = '/home/jana/Desktop/R_dat/enrichment_p_vals_Response_stromal_region.csv',col.names = T)


#Grade
cors = merge(neighb_clusters_orig,unique(Sample_metadata[,c('patientcode','grade')]),by = 'patientcode')

cors[,nr_both := .N, by = c('cluster','grade')]
cors[,perc_ME := nr_both/.N, by = c('cluster')]
cors[,perc_CT := nr_both/.N, by = c('grade')]

cors$cluster = factor(cors$cluster, levels = as.character(1:11))
cors$grade = factor(cors$grade)
colnames(cors)[1:3] = c('patientcode','StromalComm_groups','grade')

#plot
p4 <- ggplot(cors,aes(y=StromalComm_groups,x=grade))+
  geom_point(aes(colour = perc_ME, 
                 size =perc_CT))  +   
scale_color_gradient2(low = "blue",  
                     mid = "white",
                     high = "red",
                     name = "Fraction of Comm_cluster in grade group")+       
scale_size(range = c(1, 15),name = "Fraction of grade in Comm_cluster group") +
      theme(axis.text.x=element_text(color = c(mycols_clinical)))

pdf('/home/jana/Desktop/R_dat/enrichment_commclusters_grade_groups.pdf',width = 20, height = 10)
p4
dev.off()

#Enrichment stats

#Loop through all SCP/TME patient groups and test for all response types each one contains whether there is a significant enrichment
overview = list()
counter = 1
for (i in unique(cors$StromalComm_groups)){
  logic_vector = cors$StromalComm_groups == i
  MEs = unique(cors$grade[logic_vector])
  ME_vectors = lapply(MEs, function(x){cors$grade == x})
  res = lapply(ME_vectors, function(x){fisher.test(logic_vector,x,alternative = 'greater')})
  p = unlist(lapply(res, function(x){x$p.value}))
  CT_name = rep(i,length(MEs))
  ME_name = MEs
  #Correct for multiple testing
  adjusted_p = p.adjust(p, method = 'bonferroni', n = length(p))
  overview[[counter]] = cbind(as.data.table(CT_name),ME_name,adjusted_p)
  
  counter = counter + 1
}

d = data.table(do.call(rbind,overview))
colnames(d) = c('StromalCommRegion','Grade','adjusted_p')
fwrite(d,file = '/home/jana/Desktop/R_dat/enrichment_p_vals_grade_stromal_region.csv',col.names = T)


#Clinical type
cors = merge(neighb_clusters_orig,unique(Sample_metadata[,c('patientcode','clinical_type')]),by = 'patientcode')
cors = cors[clinical_type != '']

cors[,nr_both := .N, by = c('cluster','clinical_type')]
cors[,perc_ME := nr_both/.N, by = c('cluster')]
cors[,perc_CT := nr_both/.N, by = c('clinical_type')]

cors$cluster = factor(cors$cluster, levels = as.character(1:11))
cors$clinical_type = factor(cors$clinical_type)
colnames(cors)[1:3] = c('patientcode','StromalComm_groups','clinical_type')

#plot
p4 <- ggplot(cors,aes(y=StromalComm_groups,x=factor(clinical_type,c('','HR+HER2-','HR+HER2+','HR-HER2+','TripleNeg'))))+
  geom_point(aes(colour = perc_ME, 
                 size =perc_CT))  +   
scale_color_gradient2(low = "blue",  
                     mid = "white",
                     high = "red",
                     name = "Fraction of Comm_cluster in clinical_type group")+       
scale_size(range = c(1, 15),name = "Fraction of clinical_type in Comm_cluster group") +
      theme(axis.text.x=element_text(color = c(mycols_clinical[c(2,3,1,4)])))

pdf('/home/jana/Desktop/R_dat/enrichment_commclusters_clinical_type_groups.pdf',width = 20, height = 10)
p4
dev.off()

#Enrichment stats

#Loop through all SCP/TME patient groups and test for all response types each one contains whether there is a significant enrichment
overview = list()
counter = 1
for (i in unique(cors$StromalComm_groups)){
  logic_vector = cors$StromalComm_groups == i
  MEs = unique(cors$clinical_type[logic_vector])
  ME_vectors = lapply(MEs, function(x){cors$clinical_type == x})
  res = lapply(ME_vectors, function(x){fisher.test(logic_vector,x,alternative = 'greater')})
  p = unlist(lapply(res, function(x){x$p.value}))
  CT_name = rep(i,length(MEs))
  ME_name = MEs
  #Correct for multiple testing
  adjusted_p = p.adjust(p, method = 'bonferroni', n = length(p))
  overview[[counter]] = cbind(as.data.table(CT_name),ME_name,adjusted_p)
  
  counter = counter + 1
}

d = data.table(do.call(rbind,overview))
colnames(d) = c('StromalCommRegion','clinical_type','adjusted_p')
fwrite(d,file = '/home/jana/Desktop/R_dat/enrichment_p_vals_clinical_type_stromal_region.csv',col.names = T)

```


#Neighborhood according to stromal communities
```{r}
#d_mat from clustered clustergram stroma
# 
# hr = hclust(dist(d_mat), method = "ward.D2")
# hr_c <- order.optimal(dist(d_mat), hr$merge)
# hr$order = hr_c$order
# hr$merge = hr_c$merge
# 
# hc = hclust(dist(t(d_mat)), method = "ward.D2")
# hc_c <- order.optimal(dist(t(d_mat)), hc$merge)
# hc$order = hc_c$order
# hc$merge = hc_c$merge
# order_stroma_sbp = hc$labels[hc$order]
# 
# d_mat = d_mat[,order_stroma_sbp]
# 
# 
# h = Heatmap(d_mat, name = "Clustergram", km = 1, col = colorRamp2(c(0, 1), c("white", "red")),
#      show_row_names = T, show_column_names =  T, cluster_rows = hr,cluster_columns = hc)+
# 
# Heatmap(factor(d$group), name = "Patientgroups", show_row_names = FALSE, width = unit(10, "mm"), col = structure(col_vector, names = c(as.character(1:10))))
# 
# pdf('/home/jana/Desktop/R_dat/levels_stromalcommunities_ME_colors.pdf',width = 10, height = 20)
# h
# dev.off()


pa = pa[order(match(patientcode,o_patients))]
                    
clustergram_dat = clustergram_dat[pa$core,]

clustergram_grade = data.table(clustergram_grade)
clustergram_grade = clustergram_grade[core %in%pa$core,]
clustergram_grade = clustergram_grade[order(match(core,pa$core))]

splitting_names = pa[order(match(patientcode,names(clusters))),'core']
splitting = clusters
names(splitting) = splitting_names$core
splitting = splitting[order(match(names(splitting),pa$core))]



h = Heatmap(clustergram_dat, name = "Clustergram", km = 1, col = colorRamp2(c(-1, 0, 1), c("blue", "white", "red")),
     show_row_names = TRUE, show_column_names =  TRUE, cluster_rows = F,clustering_method_columns = "ward.D2",split = splitting)+   #  row_order = rev(order_stacked), cluster_rows = FALSE
  
#patient groups
    Heatmap(pa$patient_pheno, name = "Patient_Groups", show_row_names = FALSE, width = unit(10, "mm"), col = structure(c("white","white",mycols_patient,"chocolate"), names = c('normal',0:17))) +
  
#grades
  Heatmap(factor(clustergram_grade$grade), name = "Grade", show_row_names = FALSE, width = unit(10, "mm"),col = structure(c("white","green","blue","red","black"), names = c('0','1','2','3','CONTROL')))+
  
#clinical group
  Heatmap(factor(pa$clinical_type), name = "ClinicalType", show_row_names = FALSE, width = unit(10, "mm"),col = structure(c(mycols_clinical,"white","black","black"), names = c('HR-HER2+','HR+HER2-','HR+HER2+','TripleNeg','normal','control','CONTROL')))



pdf('/home/jana/Desktop/R_dat/neighborhood_accordingtoComm.pdf',width = 90, height = 60)
h
dev.off()

#Enrichment analysis for neighborhood interactions in stromal community groups
names(neighb_clusters_orig)[1] = 'patientcode'
neighb_clusters_orig = merge(neighb_clusters_orig,unique(pa[,c('core','patientcode')]),by = 'patientcode')
clustergram = as.data.table(clustergram_dat)
clustergram$core = rownames(clustergram_dat)
neighb_clusters_orig = merge(neighb_clusters_orig,clustergram,by = 'core')

neighb_clusters_orig$cluster = as.factor(neighb_clusters_orig$cluster)

#Loop through all SCP patient groups and test for all TMEs each one contains whether there is a significant enrichment
overview = list()
counter = 1
for (i in 4:ncol(neighb_clusters_orig)){
  
  
  cur = as.matrix(neighb_clusters_orig[,eval(i),with =F])
  cur[cur == 1] = 0
  if (sum(cur)< 0){
    cur = as.factor(cur)
  
    #only for positive association
    res = lapply(unique(neighb_clusters_orig$cluster), function(x){fisher.test(cur == -1,neighb_clusters_orig$cluster == x,alternative = 'greater',simulate.p.value=TRUE)})
    p = unlist(lapply(res, function(x){x$p.value}))
      
    
    interaction_name = rep(names(neighb_clusters_orig)[i],length(unique(neighb_clusters_orig$cluster)))
    group_name = unique(neighb_clusters_orig$cluster)
    #Correct for multiple testing of different TMEs
    adjusted_p = p.adjust(p, method = 'bonferroni', n = length(p))
    overview[[counter]] = cbind(interaction_name,group_name,adjusted_p)
    
    counter = counter + 1
    }
}

#Write out overview of results
d = data.table(do.call(rbind,overview))
d = d[adjusted_p < 0.05,]
fwrite(d,file = '/home/jana/Desktop/R_dat/enrichment_StromalCommGroups_significantInteractions_negative.csv',col.names = T)

```


```{r}
#stromal
surv_stroma = unique(nodules_wide[,c('patientcode','cluster','Community','core')])
surv_stroma[,nr_both := .N, by = c('cluster','core')]
surv_stroma = merge(surv_stroma,unique(Sample_metadata[,c('core','area')]),by = 'core')
surv_stroma[,nodule_area := nr_both/area, by = 'core']
surv_stroma[,nodule_area_patient := mean(nodule_area),by = c('patientcode','cluster')]
surv_stroma = unique(surv_stroma[,c('patientcode','cluster','nodule_area_patient')])
surv_stroma = dcast.data.table(surv_stroma,'patientcode ~ cluster',fill = 0)
surv_stroma = merge(unique(Sample_metadata[,c('patientcode','OSmonth','Patientstatus')]),surv_stroma,by = 'patientcode')

surv_stroma = surv_stroma[!is.na(surv_stroma$OSmonth),]
colnames(surv_stroma)[-c(1:3)] = paste0('cluster_',colnames(surv_stroma)[-c(1:3)])

#Change Unit so the values aren't all super small
surv_stroma = cbind(surv_stroma[,c(1:3)],data.table(as.matrix(surv_stroma[,-c(1:3)]) * 10000000))


#log transf
bin = surv_stroma[,-c(1:3)]
#bin = log1p(bin)
bin[bin ==0] = 1
bin= log(bin)
surv_stroma = cbind(surv_stroma[,c(1:3)],bin)



#Adjust censoring depending on whether you are interested in overal or disease free survival (here overal)
surv_stroma$censoring[str_detect(surv_stroma$Patientstatus,'death by primary disease')] = 1
surv_stroma$censoring[is.na(surv_stroma$censoring)] = 0

res.cox2 <- coxph(Surv(surv_stroma$OSmonth, surv_stroma$censoring) ~ cluster_1 + cluster_2  + cluster_3  + cluster_4 + cluster_5 + cluster_6 + cluster_7 + cluster_8  + cluster_9 + cluster_10  + cluster_11 + cluster_12 +cluster_13 +cluster_14 +cluster_15 +cluster_16 +cluster_17 +cluster_18 +cluster_19 +cluster_20 +cluster_21 +cluster_22 +cluster_23 +cluster_24 +cluster_25 +cluster_26 +cluster_27 +cluster_28 +cluster_29 +cluster_30 , data =  surv_stroma)
summary(res.cox2)
coefs = res.cox$coef
HR = exp(coefs)
CI = exp(confint(res.cox))






#Combined

colnames(surv_stroma)[-c(1:3,ncol(surv_stroma))] = paste0('stromal_',colnames(surv_stroma)[-c(1:3,ncol(surv_stroma))])
comb = merge(surv_stroma,surv, by = c('patientcode','OSmonth','Patientstatus','censoring'))


res.cox2 <- coxph(Surv(comb$OSmonth, comb$censoring) ~ stromal_cluster_1 + stromal_cluster_2 + stromal_cluster_3 + stromal_cluster_4 + stromal_cluster_5 + stromal_cluster_6 + stromal_cluster_7 + stromal_cluster_8 + stromal_cluster_9 + stromal_cluster_10 + stromal_cluster_11 + stromal_cluster_12 + stromal_cluster_13 + stromal_cluster_14 + stromal_cluster_15 + stromal_cluster_16 + stromal_cluster_17 + stromal_cluster_18 + stromal_cluster_19 + stromal_cluster_20 + stromal_cluster_21 + stromal_cluster_22 + stromal_cluster_23 + stromal_cluster_24 + stromal_cluster_25 + stromal_cluster_26 + stromal_cluster_27 + stromal_cluster_28 + stromal_cluster_29 + stromal_cluster_30 + cluster_1 + cluster_2  + cluster_3  + cluster_4 + cluster_5 + cluster_6 + cluster_7 + cluster_8 + cluster_9 + cluster_10  + cluster_11 + cluster_12 +cluster_13 +cluster_14 +cluster_15 +cluster_16 +cluster_17  +cluster_18  +cluster_19  +cluster_20  +cluster_21  +cluster_22  +cluster_23 , data =  comb)
summary(res.cox2)

CI = confint(res2)
df <- data.frame(x = names(res2$coefficients),
                 F = exp(res2$coefficients),
                 L = exp(CI[,1]),
                 U = exp(CI[,2]))
df = data.table(df)
df = df[order(F),]
df$x = factor(df$x, levels = df$x)
df$sign[df$L < 1 & df$U < 1] = 1
df$sign[df$L > 1 & df$U > 1] = 1
df$sign[is.na(df$sign)] = 0
df$sign = factor(df$sign)

g = ggplot(df, aes(x = x, y = F, color = sign)) +
  geom_point(size = 4) +
  geom_errorbar(aes(ymax = U, ymin = L))+
  scale_color_manual(values = c('light blue','red'))+
  coord_flip()+ylim(0,5)+
  geom_hline(yintercept = 1,color = 'blue')+
  scale_y_continuous(trans='log')

pdf('/home/jana/Desktop/R_dat/clinical_community_dat_zoomed.pdf',width = 20, height = 10)
g
dev.off()

#Model comparison
comb = merge(comb,unique(Sample_metadata[,c('patientcode','clinical_type','grade')]),by = 'patientcode')

comb$grade = factor(comb$grade,levels = 3:1)
comb$clinical_type = factor(comb$clinical_type,levels = c('HR+HER2-','TripleNeg','HR+HER2+','HR-HER2+',''))
res1 = coxph(Surv(comb$OSmonth, comb$censoring) ~ clinical_type + grade , data =  comb)
res2 = coxph(Surv(comb$OSmonth, comb$censoring) ~ clinical_type + grade + stromal_cluster_1 + stromal_cluster_2 + stromal_cluster_3 + stromal_cluster_4 + stromal_cluster_5 + stromal_cluster_6 + stromal_cluster_7 + stromal_cluster_8 + stromal_cluster_9 + stromal_cluster_10 + stromal_cluster_11 + stromal_cluster_12 + stromal_cluster_13 + stromal_cluster_14 + stromal_cluster_15 + stromal_cluster_16 + stromal_cluster_17 + stromal_cluster_18 + stromal_cluster_19 + stromal_cluster_20 + stromal_cluster_21 + stromal_cluster_22 + stromal_cluster_23 + stromal_cluster_24 + stromal_cluster_25 + stromal_cluster_26 + stromal_cluster_27 + stromal_cluster_28 + stromal_cluster_29 + stromal_cluster_30 + cluster_1 + cluster_2  + cluster_3  + cluster_4 + cluster_5 + cluster_6 + cluster_7 + cluster_8 + cluster_9 + cluster_10  + cluster_11 + cluster_12 +cluster_13 +cluster_14 +cluster_15 +cluster_16 +cluster_17  +cluster_18  +cluster_19  +cluster_20  +cluster_21  +cluster_22  +cluster_23 , data =  comb)


#Likelihood ratio test
anova(res1,res2)

#Grade and clinical
res1 = coxph(Surv(comb$OSmonth, comb$censoring) ~ grade , data =  comb)
res2 = coxph(Surv(comb$OSmonth, comb$censoring) ~ grade + clinical_type , data =  comb)
anova(res1,res2)

#Grade and clinical
res1 = coxph(Surv(comb$OSmonth, comb$censoring) ~ stromal_cluster_1 + stromal_cluster_2 + stromal_cluster_3 + stromal_cluster_4 + stromal_cluster_5 + stromal_cluster_6 + stromal_cluster_7 + stromal_cluster_8 + stromal_cluster_9 + stromal_cluster_10 + stromal_cluster_11 + stromal_cluster_12 + stromal_cluster_13 + stromal_cluster_14 + stromal_cluster_15 + stromal_cluster_16 + stromal_cluster_17 + stromal_cluster_18 + stromal_cluster_19 + stromal_cluster_20 + stromal_cluster_21 + stromal_cluster_22 + stromal_cluster_23 + stromal_cluster_24 + stromal_cluster_25 + stromal_cluster_26 + stromal_cluster_27 + stromal_cluster_28 + stromal_cluster_29 + stromal_cluster_30 + cluster_1 + cluster_2  + cluster_3  + cluster_4 + cluster_5 + cluster_6 + cluster_7 + cluster_8 + cluster_9 + cluster_10  + cluster_11 + cluster_12 +cluster_13 +cluster_14 +cluster_15 +cluster_16 +cluster_17  +cluster_18  +cluster_19  +cluster_20  +cluster_21  +cluster_22  +cluster_23  , data =  comb)
res2 = coxph(Surv(comb$OSmonth, comb$censoring) ~ stromal_cluster_1 + stromal_cluster_2 + stromal_cluster_3 + stromal_cluster_4 + stromal_cluster_5 + stromal_cluster_6 + stromal_cluster_7 + stromal_cluster_8 + stromal_cluster_9 + stromal_cluster_10 + stromal_cluster_11 + stromal_cluster_12 + stromal_cluster_13 + stromal_cluster_14 + stromal_cluster_15 + stromal_cluster_16 + stromal_cluster_17 + stromal_cluster_18 + stromal_cluster_19 + stromal_cluster_20 + stromal_cluster_21 + stromal_cluster_22 + stromal_cluster_23 + stromal_cluster_24 + stromal_cluster_25 + stromal_cluster_26 + stromal_cluster_27 + stromal_cluster_28 + stromal_cluster_29 + stromal_cluster_30 + cluster_1 + cluster_2  + cluster_3  + cluster_4 + cluster_5 + cluster_6 + cluster_7 + cluster_8 + cluster_9 + cluster_10  + cluster_11 + cluster_12 +cluster_13 +cluster_14 +cluster_15 +cluster_16 +cluster_17  +cluster_18  +cluster_19  +cluster_20  +cluster_21  +cluster_22  +cluster_23 + grade  , data =  comb)
anova(res1,res2)


#Within subgroups
cur = comb[clinical_type == 'TripleNeg',]
res2 = coxph(Surv(cur$OSmonth, cur$censoring) ~  grade + stromal_cluster_1 + stromal_cluster_2 + stromal_cluster_3 + stromal_cluster_4 + stromal_cluster_5 + stromal_cluster_6 + stromal_cluster_7 + stromal_cluster_8 + stromal_cluster_9 + stromal_cluster_10 + stromal_cluster_11 + stromal_cluster_12 + stromal_cluster_13 + stromal_cluster_14 + stromal_cluster_15 + stromal_cluster_16 + stromal_cluster_17 + stromal_cluster_18 + stromal_cluster_19 + stromal_cluster_20 + stromal_cluster_21 + stromal_cluster_22 + stromal_cluster_23 + stromal_cluster_24 + stromal_cluster_25 + stromal_cluster_26 + stromal_cluster_27 + stromal_cluster_28 + stromal_cluster_29 + stromal_cluster_30 + cluster_1 + cluster_2  + cluster_3  + cluster_4 + cluster_5 + cluster_6 + cluster_7 + cluster_8 + cluster_9 + cluster_10  + cluster_11 + cluster_12 +cluster_13 +cluster_14 +cluster_15 +cluster_16 +cluster_17  +cluster_18  +cluster_19  +cluster_20  +cluster_21  +cluster_22  +cluster_23 , data =  cur)

#Within grade
cur = comb[grade == 1,]
res2 = coxph(Surv(cur$OSmonth, cur$censoring) ~ cluster_1 + cluster_2  + cluster_3  + cluster_4 + cluster_5 + cluster_6 + cluster_7 + cluster_8 + cluster_9 + cluster_10  + cluster_11 + cluster_12 +cluster_13 +cluster_14 +cluster_15 +cluster_16 +cluster_17  +cluster_18  +cluster_19  +cluster_20  +cluster_21  +cluster_22  +cluster_23 , data =  cur)

CI = confint(res2)
df <- data.frame(x = names(res2$coefficients),
                 F = exp(res2$coefficients),
                 L = exp(CI[,1]),
                 U = exp(CI[,2]))
df = data.table(df)
df = df[order(F),]
df$x = factor(df$x, levels = df$x)
df$sign[df$L < 1 & df$U < 1] = 1
df$sign[df$L > 1 & df$U > 1] = 1
df$sign[is.na(df$sign)] = 0
df$sign = factor(df$sign)

g = ggplot(df, aes(x = x, y = F, color = sign)) +
  geom_point(size = 4) +
  geom_errorbar(aes(ymax = U, ymin = L))+
  scale_color_manual(values = c('light blue','red'))+
  coord_flip()+ylim(0,20)+
  geom_hline(yintercept = 1,color = 'blue')

pdf('/home/jana/Desktop/R_dat/onlyGrade3Patients_onlyEpiCommunities.pdf',width = 20, height = 10)
g
dev.off()


#Lasso regularized

comb$OSmonth[comb$OSmonth == 0] = 1
comb$clinical_type = factor(comb$clinical_type)
clinical_dummy <- model.matrix( ~ clinical_type, comb)
comb = cbind(comb,clinical_dummy)
grade_dummy <- model.matrix( ~ grade, comb)
comb = cbind(comb,grade_dummy)
comb = comb[,-c('clinical_type','(Intercept)','grade')]
cv.fit <- cv.glmnet(as.matrix(comb[,-c('patientcode','OSmonth','Patientstatus','censoring')]), Surv(comb$OSmonth, comb$censoring), family="cox", maxit = 10000)

plot(cv.fit)

cv.fit$lambda.min
Coefficients <- coef(cv.fit, s = cv.fit$lambda.min)
Active.Index <- which(Coefficients != 0)
Active.Coefficients <- Coefficients[Active.Index]
names(comb[,-c('patientcode','OSmonth','Patientstatus','censoring')])[Active.Index]






#Single-cells

celltype_dat = merge(unique(Sample_metadata[,c('patientcode','OSmonth','Patientstatus')]),patient_wide_densities, by = 'patientcode')
celltype_dat = celltype_dat[!is.na(celltype_dat$OSmonth),]
colnames(celltype_dat)[-c(1:3)] = paste0('cluster_',colnames(celltype_dat)[-c(1:3)])

#Change Unit so the values aren't all super small
celltype_dat = cbind(celltype_dat[,c(1:3)],data.table(as.matrix(celltype_dat[,-c(1:3)]) * 10000000))

#log transf
bin = celltype_dat[,-c(1:3)]
#bin[bin ==0] = 0.0000001
bin[bin ==0] = 1
bin= log(bin)
celltype_dat = cbind(celltype_dat[,c(1:3)],bin)


#Add metadata
celltype_dat = merge(celltype_dat,unique(cluster_dat_tumors[,c('patientcode','grade','age','PTNM_T','PTNM_M','tumor_size','PTNM_N','histology','patient_pheno','clinical_type')]), by = 'patientcode')


#Adjust censoring depending on whether you are interested in overal or disease free survival (here overal)
celltype_dat$censoring[str_detect(celltype_dat$Patientstatus,'death by primary disease')] = 1
celltype_dat$censoring[is.na(celltype_dat$censoring)] = 0


# Compare any 2 nested models using likelihood ratio tests (add in or leave away different variables)
celltype_dat$grade = factor(celltype_dat$grade,levels = 3:1)
celltype_dat$clinical_type = factor(celltype_dat$clinical_type,levels = c('HR+HER2-','TripleNeg','HR+HER2+','HR-HER2+',''))
res.cox1 <- coxph(Surv(celltype_dat$OSmonth, celltype_dat$censoring) ~ clinical_type + grade , data =  celltype_dat)
res.cox2 <- coxph(Surv(celltype_dat$OSmonth, celltype_dat$censoring) ~ clinical_type + grade + cluster_1 + cluster_2  + cluster_3  + cluster_4 + cluster_5 + cluster_6 + cluster_7 + cluster_8  + cluster_9 + cluster_10  + cluster_11 + cluster_12 +cluster_13 +cluster_14 +cluster_15 +cluster_16 +cluster_17 +cluster_18 +cluster_19 +cluster_20 + cluster_21 + cluster_22 + cluster_23 + cluster_24 + cluster_25 + cluster_26 + cluster_27, data =  celltype_dat)
summary(res.cox2)
anova(res.cox1,res.cox2)

CI = confint(res.cox2)
df <- data.frame(x = names(res.cox2$coefficients),
                 F = exp(res.cox2$coefficients),
                 L = exp(CI[,1]),
                 U = exp(CI[,2]))
df = data.table(df)
df = df[order(F),]
df$x = factor(df$x, levels = df$x)
df$sign[df$L < 1 & df$U < 1] = 1
df$sign[df$L > 1 & df$U > 1] = 1
df$sign[is.na(df$sign)] = 0
df$sign = factor(df$sign)

g = ggplot(df, aes(x = x, y = F, color = sign)) +
  geom_point(size = 4) +
  geom_errorbar(aes(ymax = U, ymin = L))+
  scale_color_manual(values = c('light blue','red'))+
  coord_flip()+ylim(0,20)+
  geom_hline(yintercept = 1,color = 'blue')

pdf('/home/jana/Desktop/R_dat/only_single_cell.pdf',width = 20, height = 10)
g
dev.off()

```

#Correlation stroma and epi comm
```{r}
s = surv_stroma[,-c('OSmonth','Patientstatus','censoring')]
e = surv[,-c('OSmonth','Patientstatus','censoring')]

s_mat = as.matrix(s[,-'patientcode'])
rownames(s_mat) = s$patientcode

e_mat = as.matrix(e[,-'patientcode'])
rownames(e_mat) = e$patientcode

s_mat = s_mat[rownames(s_mat)[rownames(s_mat) %in% rownames(e_mat)],]
e_mat = e_mat[rownames(e_mat)[rownames(e_mat) %in% rownames(s_mat)],]

s_mat = s_mat[,o_stroma]
e_mat = e_mat[,o_epi]


crosscor = cor(e_mat,s_mat)

combcorr = cor(cbind(e_mat,s_mat))


hr = hclust(dist(t(cbind(e_mat,s_mat))), method = "ward.D2")


pdf('/home/jana/Desktop/R_dat/corr_stromal_epi_comm_patient_level.pdf',width = 20,height = 20)
corrplot(cor(cbind(e_mat,s_mat)), method = "color",col=colorRampPalette(c("blue","white","red"))(200))#[,hr$labels[hr$order]]
dev.off()
```

#Correlation on cell level ( how often do they share cells)
```{r}

epi = merge(unique(nodules_orig[,c('CellId','Community','core')]),nodules_wide[,c('core','Community','cluster')],by = c('core','Community'))
names(epi)[names(epi) == 'Community'] = 'Epi_community'
names(epi)[names(epi) == 'cluster'] = 'Epi_cluster'

stroma = merge(unique(nodules_orig[,c('CellId','Community','core')]),nodules_wide[,c('core','Community','cluster')],by = c('core','Community'))
names(stroma)[names(stroma) == 'Community'] = 'Stromal_community'
names(stroma)[names(stroma) == 'cluster'] = 'Stromal_cluster'

both = merge(epi,stroma, by = c('core','CellId'))
both = unique(both[,-'CellId'])
both[,n_both := .N , by = c('Epi_cluster','Stromal_cluster')]
both[,frac_epi := n_both/.N , by = c('Epi_cluster')]
both[,frac_stroma := n_both/.N , by = c('Stromal_cluster')]

both$Stromal_cluster = factor(both$Stromal_cluster, levels = o_stroma) #order_stroma or o_stroma$Clustergram
both$Epi_cluster = factor(both$Epi_cluster, levels = order_epi)#order_epi

both = unique(both[,c('Epi_cluster','Stromal_cluster','n_both')])
p4 <- ggplot(both,aes(y=factor(Epi_cluster),x=factor(Stromal_cluster)))+
  geom_point(aes(colour = n_both, 
                 size = n_both))  +   
scale_color_gradient2(low = "blue",  
                     mid = "white",
                     high = "red",
                     name = "Absolute shared number")+       
scale_size(range = c(1, 15),name = "Absolute shared number") +
  theme_dark()

pdf('/home/jana/Desktop/R_dat/community_enrichment_abs_numbers.pdf',width = 20, height = 10)
p4
dev.off()


```

Distances to tumor-stroma boundary
```{r}
#Import SC distnace data exported from histoCAT (SC distnacens were extracted using regionprops in matlab)
folder_csv_images <- '/home/ubuntu/tmp/Data/2019/Revisions_submission/Data_for_submission/SC_Distances.csv'

# Load the data and get rid of cells for which the distance to mask couldn't be calculated (Inf) because no mask in that image
cells <- fread(folder_csv_images, header = TRUE, check.names = TRUE)
cells = cells[!cells$Distances == 'Inf',]

# Adjust to uniform core naming as done previously for the data here in histoCAT2R_dataCleaning.R (because naming slighlty different in histoCAT than here in R pipeline due to metadata)
test = unique(cells$core)
split_core = strsplit(cells$core,'_', fixed = TRUE)
cells$core = unlist(lapply(split_core, function(x){paste(x[c(1,2,8,9,10)],collapse =  "_")}))
#Replace the ones that don't need acquisition number again
short = unlist(lapply(strsplit(test,'_', fixed = TRUE),function(x){paste(x[c(1,2,8,9)],collapse =  "_")}))
duplicate_idx = duplicated(short) | duplicated(short, fromLast = TRUE)
in_cores_index = unlist(lapply(unique(cells$core)[duplicate_idx],function(x){which(cells$core %in% x)}))
cells$core[setdiff(1:length(cells$core),in_cores_index)] = unlist(lapply(strsplit(cells$core[setdiff(1:length(cells$core),in_cores_index)],'_', fixed = TRUE), function(x){paste(x[1:length(x)-1],collapse =  "_")}))

#Delete zeros from core names
cells$core = unlist(lapply(cells$core,function(x){gsub("000","",x)}))

#Assign StandardID (across entire data set) for every cell
cells <- cells[, id := paste(.BY,collapse =  "_"), by=.(core,CellId)]



#Add metacluster info
dat_tumor_mask = merge(unique(cells[,c('core','CellId','Mask')]),stroma, by = c('core','CellId'))
dat_tumor_mask[,n_in := .N, by = c('Stromal_cluster','Mask')]
dat_tumor_mask = unique(dat_tumor_mask[,c('Mask','Stromal_cluster','n_in')])
dat_tumor_mask[,sum_cluster := sum(n_in), by = Stromal_cluster]
dat_tumor_mask[,frac_in := n_in/sum_cluster , by = Mask]
in_tumor = dat_tumor_mask[Mask == 1,]
in_tumor = unique(in_tumor[,c('Stromal_cluster','frac_in')])

```


#K for stromal communities
```{r}
nodules = fread('/home/jana/Desktop/R_dat/nodules_stromal_basel.csv',header = T)


test = unique(nodules$core)
split_core = strsplit(nodules$core,'_', fixed = TRUE)
nodules$core = unlist(lapply(split_core, function(x){paste(x[c(1,2,8,9,10)],collapse =  "_")}))
#Replace the ones that don't need acquisition number again
short = unlist(lapply(strsplit(test,'_', fixed = TRUE),function(x){paste(x[c(1,2,8,9)],collapse =  "_")}))
duplicate_idx = duplicated(short) | duplicated(short, fromLast = TRUE)
in_cores_index = unlist(lapply(unique(nodules$core)[duplicate_idx],function(x){which(nodules$core %in% x)}))
nodules$core[setdiff(1:length(nodules$core),in_cores_index)] = unlist(lapply(strsplit(nodules$core[setdiff(1:length(nodules$core),in_cores_index)],'_', fixed = TRUE), function(x){paste(x[1:length(x)-1],collapse =  "_")}))

#Delete zeros from core names
nodules$core = unlist(lapply(nodules$core,function(x){gsub("000","",x)}))

# nodules = merge(nodules,unique(cells[,c('core','CellId','Mask')]),by = c('core','CellId'))
# nodules = nodules[Mask ==0,]

nodules[,size_comm := .N, by = c('Community','core')]
#nodules = nodules[size_comm > 19,]
nodules[,ncells := .N , by = c('Community','Pheno','core')]
nodules[,perc_cluster := ncells/size_comm, by = c('core','Community')]
save_size = unique(nodules[,c('core','Community','size_comm')])
nodules_orig = nodules

#Image mean
nodules <- unique(nodules[,c("core","Pheno","ncells","Community")])
nodules$Pheno = factor(nodules$Pheno, levels = sort(unique(nodules$Pheno)))

#Make missing cells types 0
nodules_wide = dcast.data.table(nodules,formula = 'Community + core ~ Pheno',value.var = 'ncells',fill = 0)

# #Add size and normalize
# nodules_wide = merge(nodules_wide,save_size,by = c('core','Community'))
nodules_wide = cbind( nodules_wide[,c('Community','core')],apply(nodules_wide[,-c('Community','core')],2, function(x){(x-min(x))/(max(x)-min(x))}))

save_clusterings = unique(Sample_metadata[,'patientcode'])
for (i in seq(20,60,10)){
  #PG for identifying different structures
  rand_seed = 3
  rpheno_out = cytofkit::Rphenograph(nodules_wide[,-c('Community','core')], k = i, seed = rand_seed,approx = T)
  nodules_wide_cur = nodules_wide
  nodules_wide_cur$cluster = rpheno_out$membership

  nodules_wide_cur = merge(unique(Sample_metadata[,c('core','patientcode')]),nodules_wide_cur,by = 'core')
  enrichment = unique(nodules_wide_cur[,c('cluster','patientcode','Community','core')])
  enrichment[,both := .N, by = c('cluster','patientcode')]
  enrichment[,frac_patient := both/.N, by = c('patientcode')]
  enrichment = unique(enrichment[,c('patientcode','cluster','frac_patient')])
  d = dcast.data.table(enrichment,formula = 'patientcode  ~ cluster',value.var = 'frac_patient',fill = 0)
  d_mat = as.matrix(d[,-'patientcode'])
  rownames(d_mat) = d$patientcode


  hr = hclust(dist(d_mat), method = "ward.D2")
  clusters = dendextend::cutree(hr, k = 11)

  cnames = names(clusters)
  neighb_clusters = data.table(cnames)
  names(neighb_clusters) = 'patientcode'
  neighb_clusters$cluster = unlist(clusters)
  names(neighb_clusters)[2] = paste0('cluster_',as.character(i))
  save_clusterings = merge(save_clusterings,neighb_clusters,by = 'patientcode')

}

cluster_20 = dcast.data.table(save_clusterings,'patientcode ~ cluster_20')
cluster_20_mat = as.matrix(cluster_20[,2:ncol(cluster_20)])
rownames(cluster_20_mat) = cluster_20$patientcode
cluster_20_mat[!is.na(cluster_20_mat)] = 1
cluster_20_mat[is.na(cluster_20_mat)] = 0

cluster_30 = dcast.data.table(save_clusterings,'patientcode ~ cluster_30')
cluster_30_mat = as.matrix(cluster_30[,2:ncol(cluster_30)])
rownames(cluster_30_mat) = cluster_30$patientcode
cluster_30_mat[!is.na(cluster_30_mat)] = 1
cluster_30_mat[is.na(cluster_30_mat)] = 0

cluster_40 = dcast.data.table(save_clusterings,'patientcode ~ cluster_40')
cluster_40_mat = as.matrix(cluster_40[,2:ncol(cluster_40)])
rownames(cluster_40_mat) = cluster_40$patientcode
cluster_40_mat[!is.na(cluster_40_mat)] = 1
cluster_40_mat[is.na(cluster_40_mat)] = 0

cluster_50 = dcast.data.table(save_clusterings,'patientcode ~ cluster_50')
cluster_50_mat = as.matrix(cluster_50[,2:ncol(cluster_50)])
rownames(cluster_50_mat) = cluster_50$patientcode
cluster_50_mat[!is.na(cluster_50_mat)] = 1
cluster_50_mat[is.na(cluster_50_mat)] = 0

cluster_60 = dcast.data.table(save_clusterings,'patientcode ~ cluster_60')
cluster_60_mat = as.matrix(cluster_60[,2:ncol(cluster_60)])
rownames(cluster_60_mat) = cluster_60$patientcode
cluster_60_mat[!is.na(cluster_60_mat)] = 1
cluster_60_mat[is.na(cluster_60_mat)] = 0

cor20 = cor(t(cluster_20_mat))
cor20[cor20 != 1] = 0
cor30 = cor(t(cluster_30_mat))
cor30[cor30 != 1] = 0
cor40 = cor(t(cluster_40_mat))
cor40[cor40 != 1] = 0
cor50 = cor(t(cluster_50_mat))
cor50[cor50 != 1] = 0
cor60 = cor(t(cluster_60_mat))
cor60[cor60 != 1] = 0


co_occurance = (cor20+cor30+cor40+cor50+cor60)/5
co_occurance = co_occurance[o_patients,]
co_occurance = co_occurance[,o_patients]

tab = rownames(co_occurance)
tab = as.data.table(tab)
names(tab) = 'patientcode'
names(neighb_clusters_orig)[1] = 'patientcode'
tab = merge(tab,neighb_clusters_orig,by = 'patientcode')
tab = tab[order(match(patientcode,rownames(co_occurance)))]

h = Heatmap(co_occurance, name = "co_occurance", km = 1, col = colorRamp2(c(0, 1), c("white", "red")),
     show_row_names = F, show_column_names =  F,cluster_rows = F,cluster_columns = F)+

Heatmap(factor(tab$cluster), name = "Patientgroups", show_row_names = FALSE, width = unit(10, "mm"), col = structure(col_vector, names = c(as.character(1:11))))

pdf('/home/jana/Desktop/R_dat/test.pdf',width = 30 , height = 30)
h
dev.off()

#Amount changing
length(which((cor20 - cor30) %in% c(1,-1)))
length(which((cor30 - cor40) %in% c(1,-1)))
length(which((cor40 - cor50) %in% c(1,-1)))
length(which((cor50 - cor60) %in% c(1,-1)))

```

```{r}
#Boxplots stroma and SCP


#Shannon entropy per patientcode
dat_cut_tumors <- unique(cluster_dat_tumors[,c("patientcode","cluster","ncells")])

#split into cores
ind_cores <- split( dat_cut_tumors , f = dat_cut_tumors$patientcode )

shannon_cores = lapply(ind_cores, function(x){entropy.ChaoShen(x$ncells)})

shannon_core = data.table(unlist(names(shannon_cores)))
names(shannon_core) = "patientcode"
shannon_core$shannon = unlist(shannon_cores)

#SCP

sh = merge(shannon_core,meta_patient_clustering,by = 'patientcode')


p <- ggplot(sh, aes(x=factor(patient_pheno), y=shannon)) + 
  geom_boxplot()+
  geom_point(size=2, alpha=1)+
  #stat_summary( fun.y = "mean",geom="point",colour = "black", size = 5)+
  #stat_summary(aes(group=grade), fun.y=mean, geom="line", colour="green")+
  ylab("KL div to patietn average of core")+
  xlab("Patientgroup")+
  theme(panel.background = element_blank())+
  ggtitle('Cores assigned to patient group')

pdf('/home/jana/Desktop/R_dat/shannon_SCP_basel.pdf')
p
dev.off()

#Stroma
names(neighb_clusters_orig)[1] = 'patientcode'
sh = merge(shannon_core,neighb_clusters_orig)


p <- ggplot(sh, aes(x=factor(cluster), y=shannon)) + 
  geom_boxplot()+
  geom_point(size=2, alpha=1)+
  #stat_summary( fun.y = "mean",geom="point",colour = "black", size = 5)+
  #stat_summary(aes(group=grade), fun.y=mean, geom="line", colour="green")+
  ylab("KL div to patietn average of core")+
  xlab("Patientgroup")+
  ylim(c(0,3))+
  theme(panel.background = element_blank())+
  ggtitle('Cores assigned to patient group')

pdf('/home/jana/Desktop/R_dat/shannon_stromalComm_basel.pdf')
p
dev.off()
```


#Example images
```{r}


nodules_orig = merge(nodules_orig,unique(Sample_metadata[,c('core','patientcode')]),by = 'core')
nodules_orig = merge(nodules_orig,unique(nodules_wide[,c('core','cluster','Community')]),by = c('core','Community'))


cur = surv_stroma[cluster_19 == max(cluster_19),'patientcode']
nodules_orig[patientcode == cur$patientcode,]
c = nodules_orig[(core == 'BaselTMA_SP41_178_X4Y9' & cluster == 23),c('CellId','Community')]

fwrite(c,'/home/jana/Desktop/R_dat/community_examples.csv',col.names = T)

#Check grade 2 dangerous small nodules
m = melt.data.table(comb,id.vars = c('patientcode','OSmonth','Patientstatus','censoring','clinical_type','grade'))
m = m[value != 0,]
pdf('/home/jana/Desktop/R_dat/grade.pdf',width = 50, height = 10)
ggplot(m,aes(x = variable, y = value, fill = grade))+
  geom_boxplot()
dev.off()
```
