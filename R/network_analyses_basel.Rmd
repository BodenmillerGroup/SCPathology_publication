---
title: "R Notebook"
output: html_notebook
---

#Read in tumor community data from Matlab (topological single-cell communities were extracted using the Matlab wrapper of the C++ Louvain implementation) including only tumor cells
```{r}
#Tumor communities
nodules = fread('/home/ubuntu/tmp/server_homes/janaf/Data/2019/Data_publication/BaselTMA/Communities/Communtiy_data_tumor.csv',header = T)

# #Adjust naming only first time when reading from Matlab (provided data is already cleaned)
# test = unique(nodules$core)
# split_core = strsplit(nodules$core,'_', fixed = TRUE)
# nodules$core = unlist(lapply(split_core, function(x){paste(x[c(1,2,8,9,10)],collapse =  "_")}))
# #Replace the ones that don't need acquisition number again
# short = unlist(lapply(strsplit(test,'_', fixed = TRUE),function(x){paste(x[c(1,2,8,9)],collapse =  "_")}))
# duplicate_idx = duplicated(short) | duplicated(short, fromLast = TRUE)
# in_cores_index = unlist(lapply(unique(nodules$core)[duplicate_idx],function(x){which(nodules$core %in% x)}))
# nodules$core[setdiff(1:length(nodules$core),in_cores_index)] = unlist(lapply(strsplit(nodules$core[setdiff(1:length(nodules$core),in_cores_index)],'_', fixed = TRUE), function(x){paste(x[1:length(x)-1],collapse =  "_")}))
# #Delete zeros from core names
# nodules$core = unlist(lapply(nodules$core,function(x){gsub("000","",x)}))

#Threshold for only communities of at least a certain size
nodules[,size_comm := .N, by = c('Community','core')]
nodules = nodules[size_comm > 9,]

#Calculate number of cells from each metacluster per community (community numbers are only unique per core)
colnames(nodules)[colnames(nodules) == 'Pheno'] = 'metacluster'
nodules[,ncells := .N , by = c('Community','metacluster','core')]
nodules[,perc_cluster := ncells/size_comm, by = c('Community','core')]

#Keep as separate variables for later
save_size = unique(nodules[,c('core','Community','size_comm')])
nodules_orig = nodules

#Set missing cells types to 0
nodules <- unique(nodules[,c("core","metacluster","ncells","Community")])
nodules$metacluster = factor(nodules$metacluster, levels = sort(unique(nodules$metacluster)))
nodules_wide = dcast.data.table(nodules,formula = 'Community + core ~ metacluster',value.var = 'ncells',fill = 0)
nodules_wide_not_norm = nodules_wide

```

#PG cluster tumor communtities
```{r}

#01-normalize absolute metacluster cell numbers of each community per metacluster
nodules_wide = cbind( nodules_wide[,c('Community','core')],apply(nodules_wide[,-c('Community','core')],2, function(x){(x-min(x))/(max(x)-min(x))}))

#Run PhenoGraph
rand_seed = 3
rpheno_out = cytofkit::Rphenograph(nodules_wide[,-c('Community','core')], k = 80, seed = rand_seed,approx = T)
nodules_wide$cluster = rpheno_out$membership

##Save out PG results
#fwrite(nodules_wide[,c('core','Community','cluster')],'PG_basel_epi_final.csv',col.names = T)

#Read in previous PG result from publication
cl_dat = fread('/home/ubuntu/tmp/server_homes/janaf/Data/2019/Data_publication/BaselTMA/Communities/PG_tumor_communities.csv',header = T)
nodules_wide = merge(nodules_wide,cl_dat,by = c('Community','core'))
```

#Heatmap of metacluster content of each tumor community type
```{r}

nodules_long = melt.data.table(nodules_wide, id.vars = c('Community','cluster','core') ,variable.name = 'channel', value.name = 'perc_cluster')
summary_dat = nodules_long[ ,list(
  mean_val= mean(perc_cluster),
  cell_cluster=.N),
  by=.(channel,cluster)]
hm_dat = dcast.data.table(data =summary_dat, formula = 'cluster ~ channel',
                          value.var = 'mean_val') #can be exchanged for 'median_val'

#Convert to matrix
trownames = hm_dat$cluster
hm_dat = as.matrix(hm_dat[,-1,with=F])
row.names(hm_dat) = trownames

#Set color map
cols = rev(brewer.pal(11,'Spectral'))
cmap = colorRampPalette(cols)

#Hierarchical clustering on rows with Ward's linkage
tdist = as.dist(1-cor(t(hm_dat), method="spearman"))
hr <- hclust(tdist, method="ward.D2")
co_r <- order.optimal(tdist, hr$merge)
hr$merge = co_r$merge
hr$order = co_r$order

#Order rows in heatmap according to clustering
order_heatmap_zscored = row.names(hm_dat)[hr$order]

# Hierarchical clustering on columns with Ward's linkage
tdist = as.dist(1-cor((hm_dat), method="spearman"))
hc <- hclust(tdist, method="ward.D2")
co_c <- order.optimal(tdist, hc$merge)
hc$merge = co_c$merge
hc$order = co_c$order

#Z-score data
p_dat = scale(hm_dat)

#Censor z-score at 2
p_dat[p_dat > 2] =2
p_dat[p_dat < -2] =-2

order_epi = hr$labels[hr$order]

heatmap.2(p_dat,
          scale ='none',
          trace = "none",
          col=cmap(75),
          dendrogram = "none",
          Rowv=as.dendrogram(hr),
          Colv=as.dendrogram(hc),
          density.info ='none',
          cexRow=0.6,
          cexCol=0.6,
          margins=c(4,8),
          xlab = 'Markers',
          ylab ='Cluster',
          main = 'PG_norm_slide',
          colCol = c(mycols_basel_meta[14:27],'black'),
          colRow = col_vector)

# #If heatmap should be ordered according to patient content (bellow in pipeline)
# p_dat = p_dat[rev(o_epi),]
# heatmap.2(p_dat,
#           scale ='none',
#           trace = "none",
#           col=cmap(75),
#           dendrogram = "none",
#           Rowv=F,
#           Colv=as.dendrogram(hc),
#           density.info ='none',
#           cexRow=0.6,
#           cexCol=0.6,
#           margins=c(4,8),
#           xlab = 'Markers',
#           ylab ='Cluster',
#           main = 'PG_norm_slide',
#           colCol = c(mycols_basel_meta[14:27],'black'),
#           colRow = col_vector[rev(o_epi)]) #mycols_basel for small clusters


```

#tSNE of communities based on metacluster cell content
```{r}
#Remove duplicates
dat_tsne = nodules_wide[!duplicated(nodules_wide[,-c('Community','core','cluster')])] 

#Run tSNE
require(doParallel)
cores = 10
options('mc.cores' = cores)
registerDoParallel(cores)
tsne_comm <- Rtsne.multicore::Rtsne.multicore(dat_tsne[,-c('Community','core','cluster')], 
            verbose = T, dims = 2, num_threads = 10)
  
#Write out tSNE results
#fwrite(tsne_comm$Y,'tsne_basel_epi.csv',col.names = F)

#Read in saved tsne run from publication
tsne_comm = fread('/home/ubuntu/tmp/server_homes/janaf/Data/2019/Data_publication/BaselTMA/Communities/tsne_tumor_communities.csv')

dat_tsne = merge(dat_tsne,tsne_comm,by = c('Community','core'))
dat_tsne = merge(unique(Sample_metadata[,c('core','PID')]),dat_tsne,by = 'core')
dat_tsne$PID = as.character(dat_tsne$PID)
dat_tsne = merge(dat_tsne,meta_patient_clustering,by = 'PID')
dat_tsne$patient_pheno = as.factor(dat_tsne$patient_pheno)

#SCP patient groups on community tsne
p = dat_tsne%>%
  ggplot(aes(x=V1, y=V2))+
  geom_point(size=1, alpha=0.8, aes(color=patient_pheno))+
  labs(colour="Patients")+
  scale_color_manual(values = mycols_patient)+
  ggtitle('Phenograph')+
  guides(color=guide_legend(override.aes=list(size=5)))+
  theme(strip.background = element_blank(),
        panel.background=element_rect(fill='white', colour = 'black'),
        panel.grid.major=element_blank(),
        panel.grid.minor=element_blank(),
        plot.background=element_blank(),
        legend.key = element_blank())

pdf('tsne_communities_colorSCP.pdf',width = 10,height = 10)
p
dev.off()

#Community tsne colored by community type (based on PG clustering), color = majority cell type, opacity = number of cells
dat_tsne$cluster = factor(dat_tsne$cluster,levels = order_epi)
p = dat_tsne%>%
  ggplot(aes(x=V1, y=V2))+
  geom_point(size=1, aes(color=cluster,alpha = cluster))+
  labs(colour="Patients")+
  scale_color_manual(values = mycols_basel_meta[c(21,15,26,20,19,17,20,14,18,25,27,24,24,22,19,22,23,20,25,16,25,22,23)][as.numeric(order_epi)])+
  scale_alpha_manual(values=c(1,1,1,1,1,1,0.5,1,1,1,1,1,0.5,1,0.5,0.3,0.5,0.3,0.3,1,0.5,0.5,1)[as.numeric(order_epi)])+
  ggtitle('Phenograph')+
  guides(color=guide_legend(override.aes=list(size=5)))+
  theme(strip.background = element_blank(),
        panel.background=element_rect(fill='white', colour = 'black'),
        panel.grid.major=element_blank(),
        panel.grid.minor=element_blank(),
        plot.background=element_blank(),
        legend.key = element_blank())

pdf('tsne_epithelial_communities_colorMajority.pdf',width = 10,height = 10)
p
dev.off()

#Overview of cell type fractions on community tSNE
melted = melt.data.table(dat_tsne,id.vars = c('PID','V1','V2','patient_pheno','cluster','Community','core'), measure.vars =colnames(dat_tsne)[!colnames(dat_tsne) %in%c('PID','V1','V2','patient_pheno','cluster','Community','core')], variable.name = 'channel', value.name = 'counts', na.rm=TRUE)
melted[, c_counts := bbRtools::censor_dat(counts,0.99), by=channel]
melted[, c_counts_scaled := ((c_counts - min(c_counts))/(max(c_counts) - min(c_counts))), by=channel]
melted[c_counts_scaled < 0, c_counts_scaled := 0, by=channel]


p = melted%>%
  ggplot(aes(x=V1, y=V2, color=c_counts_scaled))+
  facet_wrap(~channel, scales = "free", ncol = 7)+
  geom_point(alpha=1, size=1)+
  scale_color_gradientn(colours=rev(brewer.pal(11, 'Spectral')), name='Counts')+
  ggtitle('Marker overview')+
  scale_x_discrete(labels = abbreviate)+
  theme(strip.background = element_blank(),
        axis.line=element_blank(),
        axis.text.x=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_blank(),
        panel.border=element_blank(),
        panel.grid.major=element_blank(),
        panel.grid.minor=element_blank(),
        plot.background=element_blank()) 

pdf("tsne_cell_type_fractions.pdf",width = 30,height = 10)
p
dev.off()
```

#Stacked bars showing absolute numbers of cells of each metacluster per community type
```{r}
cl_dat = fread('/home/ubuntu/tmp/server_homes/janaf/Data/2019/Data_publication/BaselTMA/Communities/PG_tumor_communities.csv',header = T)
nodules_wide_not_norm = merge(nodules_wide_not_norm,cl_dat,by = c('Community','core'))
nodules_long = melt.data.table(nodules_wide_not_norm, id.vars = c('Community','cluster','core') ,variable.name = 'channel', value.name = 'perc_cluster')

summary_dat = nodules_long[ ,list(
  mean_val= mean(perc_cluster),
  #std_val = std(perc_cluster),
  cell_cluster=.N),
  by=.(channel,cluster)]

hm_dat = dcast.data.table(data =summary_dat, formula = 'cluster ~ channel',
                          value.var = 'mean_val') #can be exchanged for 'median_val'

#Bars ordered according to heatmap (above)
d = unique(summary_dat[,c('channel','cluster','mean_val')])
p <- ggplot(d, aes(x=factor(cluster,levels = order_epi), y=mean_val, fill=factor(channel))) + 
  geom_bar(stat='identity',show.legend = TRUE)+
  scale_fill_manual("Clusters",values =  c(mycols_basel_meta[14:27],'black'))+ 
  labs(fill = "Clusters")+
  coord_flip()+
  xlab("Patient")+
  ylab("Percentage of cluster cells in patient")+
  theme(panel.background = element_blank(),
        axis.text.y = element_text(colour=col_vector[as.numeric(order_epi)]))+
  ggtitle('Patient composition')

pdf('/home/jana/Desktop/R_dat/comm_cluster_compositions.pdf',width = 10,height = 10)
p
dev.off()


# #For ordering according to patient composition use o_epi (generated bellow in pipeline)
# p <- ggplot(d, aes(x=factor(cluster,levels = o_epi), y=mean_val, fill=factor(channel))) + 
#   geom_bar(stat='identity',show.legend = TRUE)+
#   scale_fill_manual("Clusters",values =  c(mycols_basel_meta[14:27],'black'))+ 
#   labs(fill = "Clusters")+
#   coord_flip()+
#   xlab("Patient")+
#   ylab("Percentage of cluster cells in patient")+
#   theme(panel.background = element_blank(),
#         axis.text.y = element_text(colour=col_vector[ o_epi]))+
#   ggtitle('Patient composition')

```

#Clustered heatmaps of community type make up of each patient
```{r}
#Automatically clustered on rows and columns based on community type content of patients
nodules_wide = merge(unique(Sample_metadata[,c('core','PID')]),nodules_wide,by = 'core')
nodules_wide$PID = as.character(nodules_wide$PID)
if (sum(meta_patient_clustering$patient_pheno == 18) == 0){
  meta_patient_clustering = rbind(meta_patient_clustering, data.frame(PID = c('93','276','200'), patient_pheno = rep('18',3)))
}
meta_patient_clustering$PID = as.character(meta_patient_clustering$PID)
nodules_wide = merge(nodules_wide,meta_patient_clustering,by = 'PID')
nodules_wide$PID = as.character(nodules_wide$PID)
nodules_wide$patient_pheno = as.factor(nodules_wide$patient_pheno)
enrichment = unique(nodules_wide[,c('cluster','PID','Community','core')])
enrichment[,both := .N, by = c('cluster','PID')]
enrichment[,frac_patient := both/.N, by = c('PID')]
enrichment = unique(enrichment[,c('PID','cluster','frac_patient')])
d = dcast.data.table(enrichment,formula = 'PID  ~ cluster',value.var = 'frac_patient',fill = 0)
d_mat = as.matrix(d[,-'PID'])
rownames(d_mat) = d$PID
d = merge(d, meta_patient_clustering,by = 'PID')

h = Heatmap(d_mat, name = "Clustergram", km = 1, col = colorRamp2(c(0, 1), c("white", "red")),
     show_row_names = T, show_column_names =  T, clustering_method_rows = "ward.D2",clustering_method_columns = "ward.D2")+

Heatmap(factor(d$patient_pheno), name = "Patientgroups", show_row_names = FALSE, width = unit(10, "mm"), col = structure(mycols_patient, names = c(as.character(1:18))))

pdf('epithelial_communities_perPatient_SCP_colorbar.pdf',width = 10, height = 20)
h
dev.off()


#Rows ordered according to stacked barplot (Figure 3)
missing = patient_cluster_all$PID[!patient_cluster_all$PID %in% rownames(d_mat)]
add_mat = matrix(data=0,nrow=length(missing),ncol=ncol(d_mat))
rownames(add_mat) = missing
d_mat = rbind(d_mat,add_mat)
d_mat = d_mat[order(match(rownames(d_mat),patient_cluster_all$PID)),]
d_mat = d_mat[rev(rownames(d_mat)),]
h = Heatmap(d_mat, name = "Clustergram", km = 1, col = colorRamp2(c(0, 1), c("white", "red")),
     show_row_names = T, show_column_names =  T,cluster_rows = FALSE,clustering_method_columns = "ward.D2")

#Save order to adapt order of heatmap/stacked bar plot if necessary (above)
o_epi = column_order(h)

pdf('ordered_sbp.pdf',width = 10, height = 20)
h
dev.off()

#Rows ordered according to stacked barplot (Figure 3) and columns ordered acoording to heatmap of metacluster content in each community type
missing = patient_cluster_all$PID[!patient_cluster_all$PID %in% rownames(d_mat)]
add_mat = matrix(data=0,nrow=length(missing),ncol=ncol(d_mat))
rownames(add_mat) = missing
d_mat = rbind(d_mat,add_mat)
d_mat = d_mat[order(match(rownames(d_mat),patient_cluster_all$PID)),]
d_mat = d_mat[rev(rownames(d_mat)),]
d_mat = d_mat[,order_epi]
h = Heatmap(d_mat, name = "Clustergram", km = 1, col = colorRamp2(c(0, 1), c("white", "red")),
     show_row_names = T, show_column_names =  T,cluster_rows = FALSE,cluster_columns = FALSE)

pdf('ordered_sbp_and_epiHeatmap.pdf',width = 10, height = 20)
h
dev.off()

```

#Survival on tumor community type densities
```{r}
#Prepare
surv = unique(nodules_wide[,c('PID','cluster','Community','core')])
surv[,nr_both := .N, by = c('cluster','core')]
surv = merge(surv,unique(Sample_metadata[,c('core','area')]),by = 'core')
surv[,nodule_area := nr_both/area, by = 'core']
surv[,nodule_area_patient := mean(nodule_area),by = c('PID','cluster')]
surv = unique(surv[,c('PID','cluster','nodule_area_patient')])
surv = dcast.data.table(surv,'PID ~ cluster',fill = 0)
Sample_metadata$PID = as.character(Sample_metadata$PID)
surv = merge(unique(Sample_metadata[,c('PID','OSmonth','Patientstatus')]),surv,by = 'PID')
surv = surv[!is.na(surv$OSmonth),]
colnames(surv)[-c(1:3)] = paste0('cluster_',colnames(surv)[-c(1:3)])

#Change Unit so the density values are well above 1 (setting zeros to 1 after so they will be zeros again after log, zeros represent complete absence of a community type -> should stay zero)
surv = cbind(surv[,c(1:3)],data.table(as.matrix(surv[,-c(1:3)]) * 10000000))

#log transform density values
bin = surv[,-c(1:3)]
#bin = log1p(bin)
bin[bin == 0] = 1
bin = log(bin)
surv = cbind(surv[,c(1:3)],bin)


#Adjust censoring depending on whether you are interested in overal or disease free survival (here overal)
surv$censoring[str_detect(surv$Patientstatus,'death by primary disease')] = 1
surv$censoring[is.na(surv$censoring)] = 0

res.cox2 <- coxph(Surv(surv$OSmonth, surv$censoring) ~ cluster_1 + cluster_2  + cluster_3  + cluster_4 + cluster_5 + cluster_6 + cluster_7 + cluster_8 + cluster_9 + cluster_10  + cluster_11 + cluster_12 +cluster_13 +cluster_14 +cluster_15 +cluster_16 +cluster_17  +cluster_18  +cluster_19  +cluster_20  +cluster_21  +cluster_22  +cluster_23 , data =  surv)
summary(res.cox2)

```


#Read in microenvironment community data from Matlab (topological single-cell communities were extracted using the Matlab wrapper of the C++ Louvain implementation) including all cells (but tumor metacluster agnostic -> all tumor cells are assigned to the same cell type (Pheno = 100))
```{r}
nodules = fread('/home/ubuntu/tmp/server_homes/janaf/Data/2019/Data_publication/BaselTMA/Communities/Communtiy_data_microenvironment.csv',header = T)

# #Adjust naming only first time when reading from Matlab (provided data is already cleaned)
# test = unique(nodules$core)
# split_core = strsplit(nodules$core,'_', fixed = TRUE)
# nodules$core = unlist(lapply(split_core, function(x){paste(x[c(1,2,8,9,10)],collapse =  "_")}))
# #Replace the ones that don't need acquisition number again
# short = unlist(lapply(strsplit(test,'_', fixed = TRUE),function(x){paste(x[c(1,2,8,9)],collapse =  "_")}))
# duplicate_idx = duplicated(short) | duplicated(short, fromLast = TRUE)
# in_cores_index = unlist(lapply(unique(nodules$core)[duplicate_idx],function(x){which(nodules$core %in% x)}))
# nodules$core[setdiff(1:length(nodules$core),in_cores_index)] = unlist(lapply(strsplit(nodules$core[setdiff(1:length(nodules$core),in_cores_index)],'_', fixed = TRUE), function(x){paste(x[1:length(x)-1],collapse =  "_")}))
# 
# #Delete zeros from core names
# nodules$core = unlist(lapply(nodules$core,function(x){gsub("000","",x)}))

#Calculate number of cells from each cell type per community (community numbers are only unique per core)
nodules[,size_comm := .N, by = c('Community','core')]
nodules[,ncells := .N , by = c('Community','Pheno','core')]
nodules[,perc_cluster := ncells/size_comm, by = c('core','Community')]

#Save variables for bellow in pipeline
save_size = unique(nodules[,c('core','Community','size_comm')])
nodules_orig = nodules

#Make missing cells types 0
nodules <- unique(nodules[,c("core","Pheno","ncells","Community")])
nodules$Pheno = factor(nodules$Pheno, levels = sort(unique(nodules$Pheno)))
nodules_wide = dcast.data.table(nodules,formula = 'Community + core ~ Pheno',value.var = 'ncells',fill = 0)
nodules_wide_not_norm = nodules_wide

```

#Run PG on microenvironment communities
```{r}

#01-normalize absolute cell type numbers of each community per cel type
nodules_wide = cbind( nodules_wide[,c('Community','core')],apply(nodules_wide[,-c('Community','core')],2, function(x){(x-min(x))/(max(x)-min(x))}))

#PG for identifying different structures
rand_seed = 3
rpheno_out = cytofkit::Rphenograph(nodules_wide[,-c('Community','core')], k = 30, seed = rand_seed,approx = T)
nodules_wide$cluster = rpheno_out$membership

#Write out PG result
#fwrite(nodules_wide[,c('Community','cluster')],'PG_basel_stroma_final.csv',col.names = T)

#Read in PG result from publication
cl_dat = fread('/home/ubuntu/tmp/server_homes/janaf/Data/2019/Data_publication/BaselTMA/Communities/PG_microenvironment_communities.csv',header = T)
nodules_wide = merge(nodules_wide,cl_dat,by = c('Community','core'))
```

#Heatmap of cell type content of each microenvironment community type
```{r}
nodules_long = melt.data.table(nodules_wide, id.vars = c('Community','core','cluster') ,variable.name = 'channel', value.name = 'perc_cluster')
nodules_long$perc_cluster = as.double(nodules_long$perc_cluster)

summary_dat = nodules_long[ ,list(
  median_val = median(perc_cluster),
  mean_val= mean(perc_cluster),
  #std_val = std(perc_cluster),
  cell_cluster=.N),
  by=.(channel,cluster)]

hm_dat = dcast.data.table(data =summary_dat, formula = 'cluster ~ channel',
                          value.var = 'mean_val') #can be exchanged for 'median_val' 

# Row names
trownames = hm_dat$cluster
# Convert to a matrix
hm_dat = as.matrix(hm_dat[,-1,with=F])
row.names(hm_dat) = trownames
# Set color map
cols = rev(brewer.pal(11,'Spectral'))
cmap = colorRampPalette(cols)
# Hierarchical clustering on rows with Ward's linkage
tdist = as.dist(1-cor(t(hm_dat), method="spearman"))
hr <- hclust(tdist, method="ward.D2")
co_r <- order.optimal(tdist, hr$merge)
hr$merge = co_r$merge
hr$order = co_r$order
# Order rows in heatmap according to clustering
order_heatmap_zscored = row.names(hm_dat)[hr$order]
# Hierarchical clustering on columns with Ward's linkage
tdist = as.dist(1-cor((hm_dat), method="spearman"))
hc <- hclust(tdist, method="ward.D2")
co_c <- order.optimal(tdist, hc$merge)
hc$merge = co_c$merge
hc$order = co_c$order

# Z-score data
p_dat = scale(hm_dat)

# Censor z-score at 2
p_dat[p_dat > 2] =2
p_dat[p_dat < -2] =-2

order_stroma = hr$labels[hr$order]

heatmap.2(p_dat,
          scale ='none',
          trace = "none",
          col=cmap(75),
          dendrogram = 'none',
          Colv=as.dendrogram(hc),
          Rowv=as.dendrogram(hr),
          density.info ='none',
          cexRow=0.6,
          cexCol=0.6,
          margins=c(4,8),
          xlab = 'Markers',
          ylab ='Cluster',
          main = 'PG_norm_slide',
          colCol = c(mycols_basel_meta[1:13],'black'),
          colRow = col_vector) 

# #For order according to patient makeup of communities (bellow in analysis)
# p_dat = p_dat[rev(o_stroma$Clustergram),]
# pdf(file="/home/jana/Desktop/R_dat/stroma_node_heatmap_k20.pdf", width=10, height=10)
# heatmap.2(p_dat,
#           scale ='none',
#           trace = "none",
#           col=cmap(75),
#           dendrogram = 'none',
#           Rowv=F,
#           Colv=as.dendrogram(hc),
#           density.info ='none',
#           cexRow=0.6,
#           cexCol=0.6,
#           margins=c(4,8),
#           xlab = 'Markers',
#           ylab ='Cluster',
#           main = 'PG_norm_slide',
#           colCol = c(mycols_basel_meta[1:13],'black'),
#           colRow = col_vector[rev(o_stroma$Clustergram)]) 
# 
# dev.off()


```

#Run tsne on microenvironment communities based on cell type content
```{r}
dat_tsne = nodules_wide[!duplicated(nodules_wide[,-c('Community','core','cluster')])] 

#Run tsne
require(doParallel)
cores = 10
options('mc.cores' = cores)
registerDoParallel(cores)
tsne_comm <- Rtsne.multicore::Rtsne.multicore(dat_tsne[,-c('Community','core','cluster')], 
            verbose = T, dims = 2, num_threads = 10)

#Save out tsne results
#fwrite(tsne_comm$Y,'tsne_stroma_basel_final.csv',col.names = F)

#Read in previous tsne result from publication
tsne_comm = fread('/home/ubuntu/tmp/server_homes/janaf/Data/2019/Data_publication/BaselTMA/Communities/tsne_microenvironment_communities.csv')

dat_tsne = merge(dat_tsne,tsne_comm,by = c('Community','core'))
dat_tsne = merge(unique(Sample_metadata[,c('core','PID')]),dat_tsne,by = 'core')
meta_patient_clustering$PID = as.character(meta_patient_clustering$PID)
dat_tsne$PID = as.character(dat_tsne$PID)
dat_tsne = merge(dat_tsne,meta_patient_clustering,by = 'PID')
dat_tsne$cluster = factor(dat_tsne$cluster,order_stroma)

p = dat_tsne%>%
  ggplot(aes(x=V1, y=V2))+
  geom_point(size=1, alpha=0.8, pch = 21, aes(color=cluster,fill = cluster))+
  labs(colour="Patients")+
  scale_color_manual(values = c(mycols_basel_meta,'black')[c(2,11,8,28,12,7,13,28,28,10,3,9,28,28,28,8,28,7,4,28,28,28,10,10,5,3,4,28,6,3)][as.numeric(hr$labels[hr$order])])+
  scale_fill_manual(values = c(mycols_basel_meta,'black')[c(2,11,8,28,12,7,13,8,10,9,3,9,7,28,10,8,28,28,3,28,28,28,9,10,5,9,4,10,6,7)][as.numeric(hr$labels[hr$order])])+
  ggtitle('Phenograph')+
  guides(color=guide_legend(override.aes=list(size=5)))+
  theme(strip.background = element_blank(),
        panel.background=element_rect(fill='white', colour = 'black'),
        panel.grid.major=element_blank(),
        panel.grid.minor=element_blank(),
        plot.background=element_blank(),
        legend.key = element_blank())

pdf('stroma_communities_tsne.pdf',width = 10,height = 10)
p
dev.off()



#Overview of cell type fractions on patient tSNE
melted = melt.data.table(dat_tsne,id.vars = c('PID','V1','V2','patient_pheno','cluster','Community','core'), measure.vars =colnames(dat_tsne)[!colnames(dat_tsne) %in%c('PID','V1','V2','patient_pheno','cluster','Community','core')], variable.name = 'channel', value.name = 'counts', na.rm=TRUE)
melted[, c_counts := bbRtools::censor_dat(counts,0.995), by=channel]
melted[, c_counts_scaled := ((c_counts - min(c_counts))/(max(c_counts) - min(c_counts))), by=channel]
melted[c_counts_scaled < 0, c_counts_scaled := 0, by=channel]

p = melted%>%
  ggplot(aes(x=V1, y=V2, color=c_counts_scaled))+
  facet_wrap(~channel, scales = "free", ncol = 7)+
  geom_point(alpha=1, size=1)+
  scale_color_gradientn(colours=rev(brewer.pal(11, 'Spectral')), name='Counts')+
  ggtitle('Marker overview')+
  scale_x_discrete(labels = abbreviate)+
  theme(strip.background = element_blank(),
        axis.line=element_blank(),
        axis.text.x=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_blank(),
        panel.border=element_blank(),
        panel.grid.major=element_blank(),
        panel.grid.minor=element_blank(),
        plot.background=element_blank()) 

pdf("tsne_heatmap_stroma.pdf",
  width     = 30,
  height    = 10)
p
dev.off()



```

#Stacked bars showing absolute numbers of cells of each cell type per community type
```{r}

cl_dat = fread('/home/ubuntu/tmp/server_homes/janaf/Data/2019/Data_publication/BaselTMA/Communities/PG_microenvironment_communities.csv',header = T)
nodules_wide_not_norm = merge(nodules_wide_not_norm,cl_dat,by = c('Community','core'))
nodules_long = melt.data.table(nodules_wide_not_norm, id.vars = c('Community','core','cluster') ,variable.name = 'channel', value.name = 'perc_cluster')
nodules_long$perc_cluster = as.double(nodules_long$perc_cluster)

set.seed(2)
summary_dat = nodules_long[ ,list(
  median_val = median(perc_cluster),
  mean_val= mean(perc_cluster),
  #std_val = std(perc_cluster),
  cell_cluster=.N),
  by=.(channel,cluster)]


hm_dat = dcast.data.table(data =summary_dat, formula = 'cluster ~ channel',
                          value.var = 'mean_val') #can be exchanged for 'median_val' 

#Bars next to heatmap
d = unique(summary_dat[,c('channel','cluster','mean_val')])

p <- ggplot(d, aes(x=factor(cluster,levels = hr$labels[hr$order]), y=mean_val, fill=factor(channel))) + #o_stroma$Clustergram
  geom_bar(stat='identity',show.legend = TRUE)+
  scale_fill_manual("Clusters",values =  c(mycols_basel_meta[1:13],'black'))+ 
  labs(fill = "Clusters")+
  coord_flip()+
  xlab("Patient")+
  ylab("Percentage of cluster cells in patient")+
  theme(panel.background = element_blank(),
        axis.text.y = element_text(colour=col_vector[as.numeric(hr$labels[hr$order])]))+
  ggtitle('Patient composition')



pdf('comm_cluster_compositions.pdf',width = 10,height = 10)
p
dev.off()


```

#Clustered heatmaps showing how tumors are made up by the different microenvironment community types (and grouping into 11 stromal environments SE)
```{r}
#Prepare data
nodules_wide = merge(unique(Sample_metadata[,c('core','PID')]),nodules_wide,by = 'core')
nodules_wide$PID = as.character(nodules_wide$PID)
nodules_wide = merge(nodules_wide,meta_patient_clustering,by = 'PID')
enrichment = unique(nodules_wide[,c('cluster','PID','Community','core')])
enrichment[,both := .N, by = c('cluster','PID')]
enrichment[,frac_patient := both/.N, by = c('PID')]
enrichment = unique(enrichment[,c('PID','cluster','frac_patient')])
d = dcast.data.table(enrichment,formula = 'PID  ~ cluster',value.var = 'frac_patient',fill = 0)

#Read in original ordering of this table according to original patient IDs. IDs had to be changed for publication but order needs to remain for result from publication to be reproducible.
order_orig = fread('/home/ubuntu/tmp/server_homes/janaf/Data/2019/Data_publication/BaselTMA/Communities/order_orig.csv',header = T)
d = d[order(match(PID,as.character(order_orig$order_orig))),]
d_mat = as.matrix(d[,-'PID'])
rownames(d_mat) = d$PID

#Cluster into 11 groups based on hierarchy
hr = hclust(dist(d_mat), method = "ward.D2")
clusters = dendextend::cutree(hr, k = 11)

#Save for later
cnames = names(clusters)
neighb_clusters = data.table(cnames)
names(neighb_clusters) = 'core'
neighb_clusters$cluster = unlist(clusters)
neighb_clusters_orig = neighb_clusters

#Clustered heatmap split into 11 groups
h = Heatmap(d_mat, name = "Clustergram", km = 1, col = colorRamp2(c(0, 1), c("white", "red")),
     show_row_names = T, show_column_names =  T, clustering_method_rows = "ward.D2",clustering_method_columns = "ward.D2",split = clusters)

#Save order
o_stroma = column_order(h)
o_patients = names(clusters[unlist(row_order(h))])

pdf('stromalcommunities_patients.pdf',width = 10, height = 20)
h
dev.off()

#Clustered heatmap not split into 11 groups (like in Figure, looks prettier, but same groups are still there)
h = Heatmap(d_mat, name = "Clustergram", km = 1, col = colorRamp2(c(0, 1), c("white", "red")),
     show_row_names = T, show_column_names =  T, clustering_method_rows = "ward.D2",clustering_method_columns = "ward.D2")

#Save order
o_stroma = column_order(h)
o_patients = names(clusters[unlist(row_order(h))])

pdf('stromalcommunities_patients.pdf',width = 10, height = 20)
h
dev.off()

#Icons describing cell type contents of each Stromal Environment (SE)
names(neighb_clusters_orig)[1] = 'PID'
Sample_metadata$PID = as.character(Sample_metadata$PID)
icon = merge(merge(nodules_orig,unique(Sample_metadata[,c('core','PID')]),by = 'core'),neighb_clusters_orig,by = 'PID')
icon = unique(icon[,c('Pheno','ncells','core','Community','cluster')])
icon[,tot := sum(as.double(ncells)), by = c('cluster','Pheno')]
icon[,avg := tot/sum(tot), by = c('cluster')]

bp<- ggplot(icon, aes(x="", y=avg, fill=factor(Pheno)))+
geom_bar(width = 1, stat = "identity")+
  facet_wrap(~cluster, ncol = 5)+
  scale_fill_manual("Clusters",values =  c(mycols_basel_meta[1:13],'black'))+
    theme(strip.background = element_blank(),
        panel.background=element_rect(fill='white', colour = 'black'),
        panel.grid.major=element_blank(),
        panel.grid.minor=element_blank(),
        plot.background=element_blank(),
        legend.key = element_blank())


pdf('icons_SEs.pdf',width = 10, height = 20)
bp
dev.off()


```

#Kaplan Meier survival curves for SEs (based on above clustering of microenvironment communities contaied in patients)
```{r}
names(neighb_clusters)[1] = 'PID'
surv_comm = merge(neighb_clusters,unique(Sample_metadata[,c('PID','OSmonth','DFSmonth','Patientstatus')]),by = 'PID')
      
#Adjust censoring depending on whether you are interested in overal or disease free survival (here overal)
surv_comm$censoring[str_detect(surv_comm$Patientstatus,'death by primary disease')] = 1
surv_comm$censoring[is.na(surv_comm$censoring)] = 0

# surv_comm$censoring[str_detect(surv_comm$Patientstatus,'alive w metastases')] = 1
# surv_comm$censoring[is.na(surv_comm$censoring)] = 0
# surv_comm$censoring[surv_comm$OSmonth > surv_comm$DFSmonth] = 1 #uncomment for DFS

SurvObj <- Surv(surv_comm$OSmonth, surv_comm$censoring)
km.as.one <- survfit(SurvObj ~ 1)

#Plot the SE patient group survival curves next to each other
pdf('KaplanMeierComm_clusters.pdf',width = 20,height = 20)
par(mfrow=c(4,5))
for (i in unique(surv_comm$cluster)){
  cur = unique(surv_comm$cluster)[unique(surv_comm$cluster) == i]
  cur_dat = subset(surv_comm, surv_comm$cluster == cur)
  SurvObj_cur <- Surv(cur_dat$OSmonth, cur_dat$censoring)
  km.cur.group <- survfit(SurvObj_cur ~ cur_dat$cluster)
  plot(km.cur.group,mark.time = T,col = col_vector[cur],xlim=range(1:242))
  par(new=TRUE)
  plot(km.as.one,mark.time = T,col = "black",xlim=range(1:242))
  legend("bottomleft",1,cur,col_vector[cur], cex=3)
}
dev.off()




#Coxph to test sign difference of one group to rest
pdf('coxph_stromal_comm_OS.pdf',height = 15, width = 20)
for (i in c(1:11)){
  surv_comm$grp = NULL
  surv_comm$grp[surv_comm$cluster == i] = 1
  surv_comm$grp[is.na(surv_comm$grp)] = 0
  
  res.cox <- coxph(Surv(surv_comm$OSmonth, surv_comm$censoring) ~ grp, data =  surv_comm)
  textplot(capture.output(summary(res.cox)))
  title(as.character(i))
}
dev.off()

#logrank to test sign difference of one group to rest
pdf('one_vs_rest_sign_logrank_DFS.pdf',height = 10, width = 20)
for (i in c(1:11)){
  one_vs_others = NULL
  one_vs_others[surv_comm$cluster == i ] = 1
  one_vs_others[!(surv_comm$cluster == i)] = 0
  res = survdiff(Surv(surv_comm$DFSmonth, surv_comm$censoring) ~ one_vs_others)
  textplot(capture.output(res))
  title(as.character(i))
}
dev.off()

```


#Enrichment between SE patient groups and other patient groupings
```{r}
#Enrichment bubble plot between SCP and SE patient groups
meta_patient_clustering$patient_pheno = factor(meta_patient_clustering$patient_pheno, 1:18)
cors = merge(neighb_clusters,meta_patient_clustering,by = 'PID')
cors[,nr_both := .N, by = c('cluster','patient_pheno')]
cors[,perc_ME := nr_both/.N, by = c('cluster')]
cors[,perc_CT := nr_both/.N, by = c('patient_pheno')]

cors$cluster = factor(cors$cluster, levels = as.character(1:11))
cors$patient_pheno = factor(cors$patient_pheno)
colnames(cors)[1:3] = c('patientcode','StromalComm_groups','SCP_groups')

#plot
p4 <- ggplot(cors,aes(y=StromalComm_groups,x=SCP_groups))+
  geom_point(aes(colour = perc_ME, 
                 size =perc_CT))  +   
scale_color_gradient2(low = "blue",  
                     mid = "white",
                     high = "red",
                     name = "Fraction of Comm_cluster in SCP group")+       
scale_size(range = c(1, 15),name = "Fraction of SCP in Comm_cluster group") +
      theme(axis.text.x=element_text(color = c(mycols_patient)))

pdf('/home/jana/Desktop/R_dat/enrichment_commclusters_SCP_groups.pdf',width = 20, height = 10)
p4
dev.off()

#Enrichment stats:
#Loop through all SE patient groups and test for each SCP patient group whether there is an enrichment
overview = list()
counter = 1
for (i in unique(cors$StromalComm_groups)){
  logic_vector = cors$StromalComm_groups == i
  MEs = unique(cors$SCP_groups[logic_vector])
  ME_vectors = lapply(MEs, function(x){cors$SCP_groups == x})
  res = lapply(ME_vectors, function(x){fisher.test(logic_vector,x,alternative = 'greater')})
  p = unlist(lapply(res, function(x){x$p.value}))
  CT_name = rep(i,length(MEs))
  ME_name = MEs
  #Correct for multiple testing
  adjusted_p = p.adjust(p, method = 'bonferroni', n = length(p))
  overview[[counter]] = cbind(CT_name,ME_name,adjusted_p)
  
  counter = counter + 1
}

d = data.table(do.call(rbind,overview))
colnames(d) = c('StromalCommRegion','SCP_groups','adjusted_p')
fwrite(d,file = 'enrichment_p_vals_SCP_stromal_environment.csv',col.names = T)

#Enrichment with esponse
cors = merge(neighb_clusters_orig,unique(Sample_metadata[,c('PID','response')]),by = 'PID')
cors = cors[!response == '',]
cors[,nr_both := .N, by = c('cluster','response')]
cors[,perc_ME := nr_both/.N, by = c('cluster')]
cors[,perc_CT := nr_both/.N, by = c('response')]
cors$cluster = factor(cors$cluster, levels = as.character(1:11))
cors$response = factor(cors$response)
colnames(cors)[1:3] = c('PID','StromalComm_groups','Response')

#plot
p4 <- ggplot(cors,aes(y=StromalComm_groups,x=Response))+
  geom_point(aes(colour = perc_ME, 
                 size =perc_CT))  +   
scale_color_gradient2(low = "blue",  
                     mid = "white",
                     high = "red",
                     name = "Fraction of Comm_cluster in Response group")+       
scale_size(range = c(1, 15),name = "Fraction of Response in Comm_cluster group") +
      theme(axis.text.x=element_text(color = c(mycols_clinical)))

pdf('enrichment_commclusters_response_groups.pdf',width = 20, height = 10)
p4
dev.off()

#Enrichment stats

#Loop through all SE patient groups and test for all response types each one contains whether there is a significant enrichment
overview = list()
counter = 1
for (i in unique(cors$StromalComm_groups)){
  logic_vector = cors$StromalComm_groups == i
  MEs = unique(cors$Response[logic_vector])
  ME_vectors = lapply(MEs, function(x){cors$Response == x})
  res = lapply(ME_vectors, function(x){fisher.test(logic_vector,x,alternative = 'greater')})
  p = unlist(lapply(res, function(x){x$p.value}))
  CT_name = rep(i,length(MEs))
  ME_name = MEs
  #Correct for multiple testing
  adjusted_p = p.adjust(p, method = 'bonferroni', n = length(p))
  overview[[counter]] = cbind(as.data.table(CT_name),ME_name,adjusted_p)
  
  counter = counter + 1
}

d = data.table(do.call(rbind,overview))
colnames(d) = c('StromalCommRegion','Response_groups','adjusted_p')
fwrite(d,file = '/home/jana/Desktop/R_dat/enrichment_p_vals_Response_stromal_region.csv',col.names = T)


#Enrichment with Grade
cors = merge(neighb_clusters_orig,unique(Sample_metadata[,c('PID','grade')]),by = 'PID')
cors[,nr_both := .N, by = c('cluster','grade')]
cors[,perc_ME := nr_both/.N, by = c('cluster')]
cors[,perc_CT := nr_both/.N, by = c('grade')]
cors$cluster = factor(cors$cluster, levels = as.character(1:11))
cors$grade = factor(cors$grade)
colnames(cors)[1:3] = c('PID','StromalComm_groups','grade')

#plot
p4 <- ggplot(cors,aes(y=StromalComm_groups,x=grade))+
  geom_point(aes(colour = perc_ME, 
                 size =perc_CT))  +   
scale_color_gradient2(low = "blue",  
                     mid = "white",
                     high = "red",
                     name = "Fraction of Comm_cluster in grade group")+       
scale_size(range = c(1, 15),name = "Fraction of grade in Comm_cluster group") +
      theme(axis.text.x=element_text(color = c(mycols_clinical)))

pdf('enrichment_commclusters_grade_groups.pdf',width = 20, height = 10)
p4
dev.off()

#Enrichment stats

#Loop through all SE patient groups and test for all grades each one contains whether there is a significant enrichment
overview = list()
counter = 1
for (i in unique(cors$StromalComm_groups)){
  logic_vector = cors$StromalComm_groups == i
  MEs = unique(cors$grade[logic_vector])
  ME_vectors = lapply(MEs, function(x){cors$grade == x})
  res = lapply(ME_vectors, function(x){fisher.test(logic_vector,x,alternative = 'greater')})
  p = unlist(lapply(res, function(x){x$p.value}))
  CT_name = rep(i,length(MEs))
  ME_name = MEs
  #Correct for multiple testing
  adjusted_p = p.adjust(p, method = 'bonferroni', n = length(p))
  overview[[counter]] = cbind(as.data.table(CT_name),ME_name,adjusted_p)
  
  counter = counter + 1
}

d = data.table(do.call(rbind,overview))
colnames(d) = c('StromalCommRegion','Grade','adjusted_p')
fwrite(d,file = 'enrichment_p_vals_grade_stromal_region.csv',col.names = T)


#Enrichment with Clinical subtype
cors = merge(neighb_clusters_orig,unique(Sample_metadata[,c('PID','clinical_type')]),by = 'PID')
cors = cors[clinical_type != '']
cors[,nr_both := .N, by = c('cluster','clinical_type')]
cors[,perc_ME := nr_both/.N, by = c('cluster')]
cors[,perc_CT := nr_both/.N, by = c('clinical_type')]
cors$cluster = factor(cors$cluster, levels = as.character(1:11))
cors$clinical_type = factor(cors$clinical_type)
colnames(cors)[1:3] = c('PID','StromalComm_groups','clinical_type')

#plot
p4 <- ggplot(cors,aes(y=StromalComm_groups,x=factor(clinical_type,c('','HR+HER2-','HR+HER2+','HR-HER2+','TripleNeg'))))+
  geom_point(aes(colour = perc_ME, 
                 size =perc_CT))  +   
scale_color_gradient2(low = "blue",  
                     mid = "white",
                     high = "red",
                     name = "Fraction of Comm_cluster in clinical_type group")+       
scale_size(range = c(1, 15),name = "Fraction of clinical_type in Comm_cluster group") +
      theme(axis.text.x=element_text(color = c(mycols_clinical[c(2,3,1,4)])))

pdf('enrichment_commclusters_clinical_type_groups.pdf',width = 20, height = 10)
p4
dev.off()

#Enrichment stats

#Loop through all SE patient groups and test for all clinical subtype each one contains whether there is a significant enrichment
overview = list()
counter = 1
for (i in unique(cors$StromalComm_groups)){
  logic_vector = cors$StromalComm_groups == i
  MEs = unique(cors$clinical_type[logic_vector])
  ME_vectors = lapply(MEs, function(x){cors$clinical_type == x})
  res = lapply(ME_vectors, function(x){fisher.test(logic_vector,x,alternative = 'greater')})
  p = unlist(lapply(res, function(x){x$p.value}))
  CT_name = rep(i,length(MEs))
  ME_name = MEs
  #Correct for multiple testing
  adjusted_p = p.adjust(p, method = 'bonferroni', n = length(p))
  overview[[counter]] = cbind(as.data.table(CT_name),ME_name,adjusted_p)
  
  counter = counter + 1
}

d = data.table(do.call(rbind,overview))
colnames(d) = c('StromalCommRegion','clinical_type','adjusted_p')
fwrite(d,file = 'enrichment_p_vals_clinical_type_stromal_region.csv',col.names = T)

```


#Neighborhood according to stromal communities
```{r}
#d_mat from clustered clustergram stroma
# 
# hr = hclust(dist(d_mat), method = "ward.D2")
# hr_c <- order.optimal(dist(d_mat), hr$merge)
# hr$order = hr_c$order
# hr$merge = hr_c$merge
# 
# hc = hclust(dist(t(d_mat)), method = "ward.D2")
# hc_c <- order.optimal(dist(t(d_mat)), hc$merge)
# hc$order = hc_c$order
# hc$merge = hc_c$merge
# order_stroma_sbp = hc$labels[hc$order]
# 
# d_mat = d_mat[,order_stroma_sbp]
# 
# 
# h = Heatmap(d_mat, name = "Clustergram", km = 1, col = colorRamp2(c(0, 1), c("white", "red")),
#      show_row_names = T, show_column_names =  T, cluster_rows = hr,cluster_columns = hc)+
# 
# Heatmap(factor(d$group), name = "Patientgroups", show_row_names = FALSE, width = unit(10, "mm"), col = structure(col_vector, names = c(as.character(1:10))))
# 
# pdf('/home/jana/Desktop/R_dat/levels_stromalcommunities_ME_colors.pdf',width = 10, height = 20)
# h
# dev.off()


pa = pa[order(match(patientcode,o_patients))]
                    
clustergram_dat = clustergram_dat[pa$core,]

clustergram_grade = data.table(clustergram_grade)
clustergram_grade = clustergram_grade[core %in%pa$core,]
clustergram_grade = clustergram_grade[order(match(core,pa$core))]

splitting_names = pa[order(match(patientcode,names(clusters))),'core']
splitting = clusters
names(splitting) = splitting_names$core
splitting = splitting[order(match(names(splitting),pa$core))]



h = Heatmap(clustergram_dat, name = "Clustergram", km = 1, col = colorRamp2(c(-1, 0, 1), c("blue", "white", "red")),
     show_row_names = TRUE, show_column_names =  TRUE, cluster_rows = F,clustering_method_columns = "ward.D2",split = splitting)+   #  row_order = rev(order_stacked), cluster_rows = FALSE
  
#patient groups
    Heatmap(pa$patient_pheno, name = "Patient_Groups", show_row_names = FALSE, width = unit(10, "mm"), col = structure(c("white","white",mycols_patient,"chocolate"), names = c('normal',0:17))) +
  
#grades
  Heatmap(factor(clustergram_grade$grade), name = "Grade", show_row_names = FALSE, width = unit(10, "mm"),col = structure(c("white","green","blue","red","black"), names = c('0','1','2','3','CONTROL')))+
  
#clinical group
  Heatmap(factor(pa$clinical_type), name = "ClinicalType", show_row_names = FALSE, width = unit(10, "mm"),col = structure(c(mycols_clinical,"white","black","black"), names = c('HR-HER2+','HR+HER2-','HR+HER2+','TripleNeg','normal','control','CONTROL')))



pdf('/home/jana/Desktop/R_dat/neighborhood_accordingtoComm.pdf',width = 90, height = 60)
h
dev.off()

#Enrichment analysis for neighborhood interactions in stromal community groups
names(neighb_clusters_orig)[1] = 'patientcode'
neighb_clusters_orig = merge(neighb_clusters_orig,unique(pa[,c('core','patientcode')]),by = 'patientcode')
clustergram = as.data.table(clustergram_dat)
clustergram$core = rownames(clustergram_dat)
neighb_clusters_orig = merge(neighb_clusters_orig,clustergram,by = 'core')

neighb_clusters_orig$cluster = as.factor(neighb_clusters_orig$cluster)

#Loop through all SCP patient groups and test for all TMEs each one contains whether there is a significant enrichment
overview = list()
counter = 1
for (i in 4:ncol(neighb_clusters_orig)){
  
  
  cur = as.matrix(neighb_clusters_orig[,eval(i),with =F])
  cur[cur == 1] = 0
  if (sum(cur)< 0){
    cur = as.factor(cur)
  
    #only for positive association
    res = lapply(unique(neighb_clusters_orig$cluster), function(x){fisher.test(cur == -1,neighb_clusters_orig$cluster == x,alternative = 'greater',simulate.p.value=TRUE)})
    p = unlist(lapply(res, function(x){x$p.value}))
      
    
    interaction_name = rep(names(neighb_clusters_orig)[i],length(unique(neighb_clusters_orig$cluster)))
    group_name = unique(neighb_clusters_orig$cluster)
    #Correct for multiple testing of different TMEs
    adjusted_p = p.adjust(p, method = 'bonferroni', n = length(p))
    overview[[counter]] = cbind(interaction_name,group_name,adjusted_p)
    
    counter = counter + 1
    }
}

#Write out overview of results
d = data.table(do.call(rbind,overview))
d = d[adjusted_p < 0.05,]
fwrite(d,file = '/home/jana/Desktop/R_dat/enrichment_StromalCommGroups_significantInteractions_negative.csv',col.names = T)

```


```{r}
#stromal
surv_stroma = unique(nodules_wide[,c('patientcode','cluster','Community','core')])
surv_stroma[,nr_both := .N, by = c('cluster','core')]
surv_stroma = merge(surv_stroma,unique(Sample_metadata[,c('core','area')]),by = 'core')
surv_stroma[,nodule_area := nr_both/area, by = 'core']
surv_stroma[,nodule_area_patient := mean(nodule_area),by = c('patientcode','cluster')]
surv_stroma = unique(surv_stroma[,c('patientcode','cluster','nodule_area_patient')])
surv_stroma = dcast.data.table(surv_stroma,'patientcode ~ cluster',fill = 0)
surv_stroma = merge(unique(Sample_metadata[,c('patientcode','OSmonth','Patientstatus')]),surv_stroma,by = 'patientcode')

surv_stroma = surv_stroma[!is.na(surv_stroma$OSmonth),]
colnames(surv_stroma)[-c(1:3)] = paste0('cluster_',colnames(surv_stroma)[-c(1:3)])

#Change Unit so the values aren't all super small
surv_stroma = cbind(surv_stroma[,c(1:3)],data.table(as.matrix(surv_stroma[,-c(1:3)]) * 10000000))


#log transf
bin = surv_stroma[,-c(1:3)]
#bin = log1p(bin)
bin[bin ==0] = 1
bin= log(bin)
surv_stroma = cbind(surv_stroma[,c(1:3)],bin)



#Adjust censoring depending on whether you are interested in overal or disease free survival (here overal)
surv_stroma$censoring[str_detect(surv_stroma$Patientstatus,'death by primary disease')] = 1
surv_stroma$censoring[is.na(surv_stroma$censoring)] = 0

res.cox2 <- coxph(Surv(surv_stroma$OSmonth, surv_stroma$censoring) ~ cluster_1 + cluster_2  + cluster_3  + cluster_4 + cluster_5 + cluster_6 + cluster_7 + cluster_8  + cluster_9 + cluster_10  + cluster_11 + cluster_12 +cluster_13 +cluster_14 +cluster_15 +cluster_16 +cluster_17 +cluster_18 +cluster_19 +cluster_20 +cluster_21 +cluster_22 +cluster_23 +cluster_24 +cluster_25 +cluster_26 +cluster_27 +cluster_28 +cluster_29 +cluster_30 , data =  surv_stroma)
summary(res.cox2)
coefs = res.cox$coef
HR = exp(coefs)
CI = exp(confint(res.cox))






#Combined

colnames(surv_stroma)[-c(1:3,ncol(surv_stroma))] = paste0('stromal_',colnames(surv_stroma)[-c(1:3,ncol(surv_stroma))])
comb = merge(surv_stroma,surv, by = c('patientcode','OSmonth','Patientstatus','censoring'))


res.cox2 <- coxph(Surv(comb$OSmonth, comb$censoring) ~ stromal_cluster_1 + stromal_cluster_2 + stromal_cluster_3 + stromal_cluster_4 + stromal_cluster_5 + stromal_cluster_6 + stromal_cluster_7 + stromal_cluster_8 + stromal_cluster_9 + stromal_cluster_10 + stromal_cluster_11 + stromal_cluster_12 + stromal_cluster_13 + stromal_cluster_14 + stromal_cluster_15 + stromal_cluster_16 + stromal_cluster_17 + stromal_cluster_18 + stromal_cluster_19 + stromal_cluster_20 + stromal_cluster_21 + stromal_cluster_22 + stromal_cluster_23 + stromal_cluster_24 + stromal_cluster_25 + stromal_cluster_26 + stromal_cluster_27 + stromal_cluster_28 + stromal_cluster_29 + stromal_cluster_30 + cluster_1 + cluster_2  + cluster_3  + cluster_4 + cluster_5 + cluster_6 + cluster_7 + cluster_8 + cluster_9 + cluster_10  + cluster_11 + cluster_12 +cluster_13 +cluster_14 +cluster_15 +cluster_16 +cluster_17  +cluster_18  +cluster_19  +cluster_20  +cluster_21  +cluster_22  +cluster_23 , data =  comb)
summary(res.cox2)

CI = confint(res2)
df <- data.frame(x = names(res2$coefficients),
                 F = exp(res2$coefficients),
                 L = exp(CI[,1]),
                 U = exp(CI[,2]))
df = data.table(df)
df = df[order(F),]
df$x = factor(df$x, levels = df$x)
df$sign[df$L < 1 & df$U < 1] = 1
df$sign[df$L > 1 & df$U > 1] = 1
df$sign[is.na(df$sign)] = 0
df$sign = factor(df$sign)

g = ggplot(df, aes(x = x, y = F, color = sign)) +
  geom_point(size = 4) +
  geom_errorbar(aes(ymax = U, ymin = L))+
  scale_color_manual(values = c('light blue','red'))+
  coord_flip()+ylim(0,5)+
  geom_hline(yintercept = 1,color = 'blue')+
  scale_y_continuous(trans='log')

pdf('/home/jana/Desktop/R_dat/clinical_community_dat_zoomed.pdf',width = 20, height = 10)
g
dev.off()

#Model comparison
comb = merge(comb,unique(Sample_metadata[,c('patientcode','clinical_type','grade')]),by = 'patientcode')

comb$grade = factor(comb$grade,levels = 3:1)
comb$clinical_type = factor(comb$clinical_type,levels = c('HR+HER2-','TripleNeg','HR+HER2+','HR-HER2+',''))
res1 = coxph(Surv(comb$OSmonth, comb$censoring) ~ clinical_type + grade , data =  comb)
res2 = coxph(Surv(comb$OSmonth, comb$censoring) ~ clinical_type + grade + stromal_cluster_1 + stromal_cluster_2 + stromal_cluster_3 + stromal_cluster_4 + stromal_cluster_5 + stromal_cluster_6 + stromal_cluster_7 + stromal_cluster_8 + stromal_cluster_9 + stromal_cluster_10 + stromal_cluster_11 + stromal_cluster_12 + stromal_cluster_13 + stromal_cluster_14 + stromal_cluster_15 + stromal_cluster_16 + stromal_cluster_17 + stromal_cluster_18 + stromal_cluster_19 + stromal_cluster_20 + stromal_cluster_21 + stromal_cluster_22 + stromal_cluster_23 + stromal_cluster_24 + stromal_cluster_25 + stromal_cluster_26 + stromal_cluster_27 + stromal_cluster_28 + stromal_cluster_29 + stromal_cluster_30 + cluster_1 + cluster_2  + cluster_3  + cluster_4 + cluster_5 + cluster_6 + cluster_7 + cluster_8 + cluster_9 + cluster_10  + cluster_11 + cluster_12 +cluster_13 +cluster_14 +cluster_15 +cluster_16 +cluster_17  +cluster_18  +cluster_19  +cluster_20  +cluster_21  +cluster_22  +cluster_23 , data =  comb)


#Likelihood ratio test
anova(res1,res2)

#Grade and clinical
res1 = coxph(Surv(comb$OSmonth, comb$censoring) ~ grade , data =  comb)
res2 = coxph(Surv(comb$OSmonth, comb$censoring) ~ grade + clinical_type , data =  comb)
anova(res1,res2)

#Grade and clinical
res1 = coxph(Surv(comb$OSmonth, comb$censoring) ~ stromal_cluster_1 + stromal_cluster_2 + stromal_cluster_3 + stromal_cluster_4 + stromal_cluster_5 + stromal_cluster_6 + stromal_cluster_7 + stromal_cluster_8 + stromal_cluster_9 + stromal_cluster_10 + stromal_cluster_11 + stromal_cluster_12 + stromal_cluster_13 + stromal_cluster_14 + stromal_cluster_15 + stromal_cluster_16 + stromal_cluster_17 + stromal_cluster_18 + stromal_cluster_19 + stromal_cluster_20 + stromal_cluster_21 + stromal_cluster_22 + stromal_cluster_23 + stromal_cluster_24 + stromal_cluster_25 + stromal_cluster_26 + stromal_cluster_27 + stromal_cluster_28 + stromal_cluster_29 + stromal_cluster_30 + cluster_1 + cluster_2  + cluster_3  + cluster_4 + cluster_5 + cluster_6 + cluster_7 + cluster_8 + cluster_9 + cluster_10  + cluster_11 + cluster_12 +cluster_13 +cluster_14 +cluster_15 +cluster_16 +cluster_17  +cluster_18  +cluster_19  +cluster_20  +cluster_21  +cluster_22  +cluster_23  , data =  comb)
res2 = coxph(Surv(comb$OSmonth, comb$censoring) ~ stromal_cluster_1 + stromal_cluster_2 + stromal_cluster_3 + stromal_cluster_4 + stromal_cluster_5 + stromal_cluster_6 + stromal_cluster_7 + stromal_cluster_8 + stromal_cluster_9 + stromal_cluster_10 + stromal_cluster_11 + stromal_cluster_12 + stromal_cluster_13 + stromal_cluster_14 + stromal_cluster_15 + stromal_cluster_16 + stromal_cluster_17 + stromal_cluster_18 + stromal_cluster_19 + stromal_cluster_20 + stromal_cluster_21 + stromal_cluster_22 + stromal_cluster_23 + stromal_cluster_24 + stromal_cluster_25 + stromal_cluster_26 + stromal_cluster_27 + stromal_cluster_28 + stromal_cluster_29 + stromal_cluster_30 + cluster_1 + cluster_2  + cluster_3  + cluster_4 + cluster_5 + cluster_6 + cluster_7 + cluster_8 + cluster_9 + cluster_10  + cluster_11 + cluster_12 +cluster_13 +cluster_14 +cluster_15 +cluster_16 +cluster_17  +cluster_18  +cluster_19  +cluster_20  +cluster_21  +cluster_22  +cluster_23 + grade  , data =  comb)
anova(res1,res2)


#Within subgroups
cur = comb[clinical_type == 'TripleNeg',]
res2 = coxph(Surv(cur$OSmonth, cur$censoring) ~  grade + stromal_cluster_1 + stromal_cluster_2 + stromal_cluster_3 + stromal_cluster_4 + stromal_cluster_5 + stromal_cluster_6 + stromal_cluster_7 + stromal_cluster_8 + stromal_cluster_9 + stromal_cluster_10 + stromal_cluster_11 + stromal_cluster_12 + stromal_cluster_13 + stromal_cluster_14 + stromal_cluster_15 + stromal_cluster_16 + stromal_cluster_17 + stromal_cluster_18 + stromal_cluster_19 + stromal_cluster_20 + stromal_cluster_21 + stromal_cluster_22 + stromal_cluster_23 + stromal_cluster_24 + stromal_cluster_25 + stromal_cluster_26 + stromal_cluster_27 + stromal_cluster_28 + stromal_cluster_29 + stromal_cluster_30 + cluster_1 + cluster_2  + cluster_3  + cluster_4 + cluster_5 + cluster_6 + cluster_7 + cluster_8 + cluster_9 + cluster_10  + cluster_11 + cluster_12 +cluster_13 +cluster_14 +cluster_15 +cluster_16 +cluster_17  +cluster_18  +cluster_19  +cluster_20  +cluster_21  +cluster_22  +cluster_23 , data =  cur)

#Within grade
cur = comb[grade == 1,]
res2 = coxph(Surv(cur$OSmonth, cur$censoring) ~ cluster_1 + cluster_2  + cluster_3  + cluster_4 + cluster_5 + cluster_6 + cluster_7 + cluster_8 + cluster_9 + cluster_10  + cluster_11 + cluster_12 +cluster_13 +cluster_14 +cluster_15 +cluster_16 +cluster_17  +cluster_18  +cluster_19  +cluster_20  +cluster_21  +cluster_22  +cluster_23 , data =  cur)

CI = confint(res2)
df <- data.frame(x = names(res2$coefficients),
                 F = exp(res2$coefficients),
                 L = exp(CI[,1]),
                 U = exp(CI[,2]))
df = data.table(df)
df = df[order(F),]
df$x = factor(df$x, levels = df$x)
df$sign[df$L < 1 & df$U < 1] = 1
df$sign[df$L > 1 & df$U > 1] = 1
df$sign[is.na(df$sign)] = 0
df$sign = factor(df$sign)

g = ggplot(df, aes(x = x, y = F, color = sign)) +
  geom_point(size = 4) +
  geom_errorbar(aes(ymax = U, ymin = L))+
  scale_color_manual(values = c('light blue','red'))+
  coord_flip()+ylim(0,20)+
  geom_hline(yintercept = 1,color = 'blue')

pdf('/home/jana/Desktop/R_dat/onlyGrade3Patients_onlyEpiCommunities.pdf',width = 20, height = 10)
g
dev.off()


#Lasso regularized

comb$OSmonth[comb$OSmonth == 0] = 1
comb$clinical_type = factor(comb$clinical_type)
clinical_dummy <- model.matrix( ~ clinical_type, comb)
comb = cbind(comb,clinical_dummy)
grade_dummy <- model.matrix( ~ grade, comb)
comb = cbind(comb,grade_dummy)
comb = comb[,-c('clinical_type','(Intercept)','grade')]
cv.fit <- cv.glmnet(as.matrix(comb[,-c('patientcode','OSmonth','Patientstatus','censoring')]), Surv(comb$OSmonth, comb$censoring), family="cox", maxit = 10000)

plot(cv.fit)

cv.fit$lambda.min
Coefficients <- coef(cv.fit, s = cv.fit$lambda.min)
Active.Index <- which(Coefficients != 0)
Active.Coefficients <- Coefficients[Active.Index]
names(comb[,-c('patientcode','OSmonth','Patientstatus','censoring')])[Active.Index]






#Single-cells

celltype_dat = merge(unique(Sample_metadata[,c('patientcode','OSmonth','Patientstatus')]),patient_wide_densities, by = 'patientcode')
celltype_dat = celltype_dat[!is.na(celltype_dat$OSmonth),]
colnames(celltype_dat)[-c(1:3)] = paste0('cluster_',colnames(celltype_dat)[-c(1:3)])

#Change Unit so the values aren't all super small
celltype_dat = cbind(celltype_dat[,c(1:3)],data.table(as.matrix(celltype_dat[,-c(1:3)]) * 10000000))

#log transf
bin = celltype_dat[,-c(1:3)]
#bin[bin ==0] = 0.0000001
bin[bin ==0] = 1
bin= log(bin)
celltype_dat = cbind(celltype_dat[,c(1:3)],bin)


#Add metadata
celltype_dat = merge(celltype_dat,unique(cluster_dat_tumors[,c('patientcode','grade','age','PTNM_T','PTNM_M','tumor_size','PTNM_N','histology','patient_pheno','clinical_type')]), by = 'patientcode')


#Adjust censoring depending on whether you are interested in overal or disease free survival (here overal)
celltype_dat$censoring[str_detect(celltype_dat$Patientstatus,'death by primary disease')] = 1
celltype_dat$censoring[is.na(celltype_dat$censoring)] = 0


# Compare any 2 nested models using likelihood ratio tests (add in or leave away different variables)
celltype_dat$grade = factor(celltype_dat$grade,levels = 3:1)
celltype_dat$clinical_type = factor(celltype_dat$clinical_type,levels = c('HR+HER2-','TripleNeg','HR+HER2+','HR-HER2+',''))
res.cox1 <- coxph(Surv(celltype_dat$OSmonth, celltype_dat$censoring) ~ clinical_type + grade , data =  celltype_dat)
res.cox2 <- coxph(Surv(celltype_dat$OSmonth, celltype_dat$censoring) ~ clinical_type + grade + cluster_1 + cluster_2  + cluster_3  + cluster_4 + cluster_5 + cluster_6 + cluster_7 + cluster_8  + cluster_9 + cluster_10  + cluster_11 + cluster_12 +cluster_13 +cluster_14 +cluster_15 +cluster_16 +cluster_17 +cluster_18 +cluster_19 +cluster_20 + cluster_21 + cluster_22 + cluster_23 + cluster_24 + cluster_25 + cluster_26 + cluster_27, data =  celltype_dat)
summary(res.cox2)
anova(res.cox1,res.cox2)

CI = confint(res.cox2)
df <- data.frame(x = names(res.cox2$coefficients),
                 F = exp(res.cox2$coefficients),
                 L = exp(CI[,1]),
                 U = exp(CI[,2]))
df = data.table(df)
df = df[order(F),]
df$x = factor(df$x, levels = df$x)
df$sign[df$L < 1 & df$U < 1] = 1
df$sign[df$L > 1 & df$U > 1] = 1
df$sign[is.na(df$sign)] = 0
df$sign = factor(df$sign)

g = ggplot(df, aes(x = x, y = F, color = sign)) +
  geom_point(size = 4) +
  geom_errorbar(aes(ymax = U, ymin = L))+
  scale_color_manual(values = c('light blue','red'))+
  coord_flip()+ylim(0,20)+
  geom_hline(yintercept = 1,color = 'blue')

pdf('/home/jana/Desktop/R_dat/only_single_cell.pdf',width = 20, height = 10)
g
dev.off()

```

#Correlation stroma and epi comm
```{r}
s = surv_stroma[,-c('OSmonth','Patientstatus','censoring')]
e = surv[,-c('OSmonth','Patientstatus','censoring')]

s_mat = as.matrix(s[,-'patientcode'])
rownames(s_mat) = s$patientcode

e_mat = as.matrix(e[,-'patientcode'])
rownames(e_mat) = e$patientcode

s_mat = s_mat[rownames(s_mat)[rownames(s_mat) %in% rownames(e_mat)],]
e_mat = e_mat[rownames(e_mat)[rownames(e_mat) %in% rownames(s_mat)],]

s_mat = s_mat[,o_stroma]
e_mat = e_mat[,o_epi]


crosscor = cor(e_mat,s_mat)

combcorr = cor(cbind(e_mat,s_mat))


hr = hclust(dist(t(cbind(e_mat,s_mat))), method = "ward.D2")


pdf('/home/jana/Desktop/R_dat/corr_stromal_epi_comm_patient_level.pdf',width = 20,height = 20)
corrplot(cor(cbind(e_mat,s_mat)), method = "color",col=colorRampPalette(c("blue","white","red"))(200))#[,hr$labels[hr$order]]
dev.off()
```

#Correlation on cell level ( how often do they share cells)
```{r}

epi = merge(unique(nodules_orig[,c('CellId','Community','core')]),nodules_wide[,c('core','Community','cluster')],by = c('core','Community'))
names(epi)[names(epi) == 'Community'] = 'Epi_community'
names(epi)[names(epi) == 'cluster'] = 'Epi_cluster'

stroma = merge(unique(nodules_orig[,c('CellId','Community','core')]),nodules_wide[,c('core','Community','cluster')],by = c('core','Community'))
names(stroma)[names(stroma) == 'Community'] = 'Stromal_community'
names(stroma)[names(stroma) == 'cluster'] = 'Stromal_cluster'

both = merge(epi,stroma, by = c('core','CellId'))
both = unique(both[,-'CellId'])
both[,n_both := .N , by = c('Epi_cluster','Stromal_cluster')]
both[,frac_epi := n_both/.N , by = c('Epi_cluster')]
both[,frac_stroma := n_both/.N , by = c('Stromal_cluster')]

both$Stromal_cluster = factor(both$Stromal_cluster, levels = o_stroma) #order_stroma or o_stroma$Clustergram
both$Epi_cluster = factor(both$Epi_cluster, levels = order_epi)#order_epi

both = unique(both[,c('Epi_cluster','Stromal_cluster','n_both')])
p4 <- ggplot(both,aes(y=factor(Epi_cluster),x=factor(Stromal_cluster)))+
  geom_point(aes(colour = n_both, 
                 size = n_both))  +   
scale_color_gradient2(low = "blue",  
                     mid = "white",
                     high = "red",
                     name = "Absolute shared number")+       
scale_size(range = c(1, 15),name = "Absolute shared number") +
  theme_dark()

pdf('/home/jana/Desktop/R_dat/community_enrichment_abs_numbers.pdf',width = 20, height = 10)
p4
dev.off()


```

Distances to tumor-stroma boundary
```{r}
#Import SC distnace data exported from histoCAT (SC distnacens were extracted using regionprops in matlab)
folder_csv_images <- '/home/ubuntu/tmp/Data/2019/Revisions_submission/Data_for_submission/SC_Distances.csv'

# Load the data and get rid of cells for which the distance to mask couldn't be calculated (Inf) because no mask in that image
cells <- fread(folder_csv_images, header = TRUE, check.names = TRUE)
cells = cells[!cells$Distances == 'Inf',]

# Adjust to uniform core naming as done previously for the data here in histoCAT2R_dataCleaning.R (because naming slighlty different in histoCAT than here in R pipeline due to metadata)
test = unique(cells$core)
split_core = strsplit(cells$core,'_', fixed = TRUE)
cells$core = unlist(lapply(split_core, function(x){paste(x[c(1,2,8,9,10)],collapse =  "_")}))
#Replace the ones that don't need acquisition number again
short = unlist(lapply(strsplit(test,'_', fixed = TRUE),function(x){paste(x[c(1,2,8,9)],collapse =  "_")}))
duplicate_idx = duplicated(short) | duplicated(short, fromLast = TRUE)
in_cores_index = unlist(lapply(unique(cells$core)[duplicate_idx],function(x){which(cells$core %in% x)}))
cells$core[setdiff(1:length(cells$core),in_cores_index)] = unlist(lapply(strsplit(cells$core[setdiff(1:length(cells$core),in_cores_index)],'_', fixed = TRUE), function(x){paste(x[1:length(x)-1],collapse =  "_")}))

#Delete zeros from core names
cells$core = unlist(lapply(cells$core,function(x){gsub("000","",x)}))

#Assign StandardID (across entire data set) for every cell
cells <- cells[, id := paste(.BY,collapse =  "_"), by=.(core,CellId)]



#Add metacluster info
dat_tumor_mask = merge(unique(cells[,c('core','CellId','Mask')]),stroma, by = c('core','CellId'))
dat_tumor_mask[,n_in := .N, by = c('Stromal_cluster','Mask')]
dat_tumor_mask = unique(dat_tumor_mask[,c('Mask','Stromal_cluster','n_in')])
dat_tumor_mask[,sum_cluster := sum(n_in), by = Stromal_cluster]
dat_tumor_mask[,frac_in := n_in/sum_cluster , by = Mask]
in_tumor = dat_tumor_mask[Mask == 1,]
in_tumor = unique(in_tumor[,c('Stromal_cluster','frac_in')])

```


#K for stromal communities
```{r}
nodules = fread('/home/jana/Desktop/R_dat/nodules_stromal_basel.csv',header = T)


test = unique(nodules$core)
split_core = strsplit(nodules$core,'_', fixed = TRUE)
nodules$core = unlist(lapply(split_core, function(x){paste(x[c(1,2,8,9,10)],collapse =  "_")}))
#Replace the ones that don't need acquisition number again
short = unlist(lapply(strsplit(test,'_', fixed = TRUE),function(x){paste(x[c(1,2,8,9)],collapse =  "_")}))
duplicate_idx = duplicated(short) | duplicated(short, fromLast = TRUE)
in_cores_index = unlist(lapply(unique(nodules$core)[duplicate_idx],function(x){which(nodules$core %in% x)}))
nodules$core[setdiff(1:length(nodules$core),in_cores_index)] = unlist(lapply(strsplit(nodules$core[setdiff(1:length(nodules$core),in_cores_index)],'_', fixed = TRUE), function(x){paste(x[1:length(x)-1],collapse =  "_")}))

#Delete zeros from core names
nodules$core = unlist(lapply(nodules$core,function(x){gsub("000","",x)}))

# nodules = merge(nodules,unique(cells[,c('core','CellId','Mask')]),by = c('core','CellId'))
# nodules = nodules[Mask ==0,]

nodules[,size_comm := .N, by = c('Community','core')]
#nodules = nodules[size_comm > 19,]
nodules[,ncells := .N , by = c('Community','Pheno','core')]
nodules[,perc_cluster := ncells/size_comm, by = c('core','Community')]
save_size = unique(nodules[,c('core','Community','size_comm')])
nodules_orig = nodules

#Image mean
nodules <- unique(nodules[,c("core","Pheno","ncells","Community")])
nodules$Pheno = factor(nodules$Pheno, levels = sort(unique(nodules$Pheno)))

#Make missing cells types 0
nodules_wide = dcast.data.table(nodules,formula = 'Community + core ~ Pheno',value.var = 'ncells',fill = 0)

# #Add size and normalize
# nodules_wide = merge(nodules_wide,save_size,by = c('core','Community'))
nodules_wide = cbind( nodules_wide[,c('Community','core')],apply(nodules_wide[,-c('Community','core')],2, function(x){(x-min(x))/(max(x)-min(x))}))

save_clusterings = unique(Sample_metadata[,'patientcode'])
for (i in seq(20,60,10)){
  #PG for identifying different structures
  rand_seed = 3
  rpheno_out = cytofkit::Rphenograph(nodules_wide[,-c('Community','core')], k = i, seed = rand_seed,approx = T)
  nodules_wide_cur = nodules_wide
  nodules_wide_cur$cluster = rpheno_out$membership

  nodules_wide_cur = merge(unique(Sample_metadata[,c('core','patientcode')]),nodules_wide_cur,by = 'core')
  enrichment = unique(nodules_wide_cur[,c('cluster','patientcode','Community','core')])
  enrichment[,both := .N, by = c('cluster','patientcode')]
  enrichment[,frac_patient := both/.N, by = c('patientcode')]
  enrichment = unique(enrichment[,c('patientcode','cluster','frac_patient')])
  d = dcast.data.table(enrichment,formula = 'patientcode  ~ cluster',value.var = 'frac_patient',fill = 0)
  d_mat = as.matrix(d[,-'patientcode'])
  rownames(d_mat) = d$patientcode


  hr = hclust(dist(d_mat), method = "ward.D2")
  clusters = dendextend::cutree(hr, k = 11)

  cnames = names(clusters)
  neighb_clusters = data.table(cnames)
  names(neighb_clusters) = 'patientcode'
  neighb_clusters$cluster = unlist(clusters)
  names(neighb_clusters)[2] = paste0('cluster_',as.character(i))
  save_clusterings = merge(save_clusterings,neighb_clusters,by = 'patientcode')

}

cluster_20 = dcast.data.table(save_clusterings,'patientcode ~ cluster_20')
cluster_20_mat = as.matrix(cluster_20[,2:ncol(cluster_20)])
rownames(cluster_20_mat) = cluster_20$patientcode
cluster_20_mat[!is.na(cluster_20_mat)] = 1
cluster_20_mat[is.na(cluster_20_mat)] = 0

cluster_30 = dcast.data.table(save_clusterings,'patientcode ~ cluster_30')
cluster_30_mat = as.matrix(cluster_30[,2:ncol(cluster_30)])
rownames(cluster_30_mat) = cluster_30$patientcode
cluster_30_mat[!is.na(cluster_30_mat)] = 1
cluster_30_mat[is.na(cluster_30_mat)] = 0

cluster_40 = dcast.data.table(save_clusterings,'patientcode ~ cluster_40')
cluster_40_mat = as.matrix(cluster_40[,2:ncol(cluster_40)])
rownames(cluster_40_mat) = cluster_40$patientcode
cluster_40_mat[!is.na(cluster_40_mat)] = 1
cluster_40_mat[is.na(cluster_40_mat)] = 0

cluster_50 = dcast.data.table(save_clusterings,'patientcode ~ cluster_50')
cluster_50_mat = as.matrix(cluster_50[,2:ncol(cluster_50)])
rownames(cluster_50_mat) = cluster_50$patientcode
cluster_50_mat[!is.na(cluster_50_mat)] = 1
cluster_50_mat[is.na(cluster_50_mat)] = 0

cluster_60 = dcast.data.table(save_clusterings,'patientcode ~ cluster_60')
cluster_60_mat = as.matrix(cluster_60[,2:ncol(cluster_60)])
rownames(cluster_60_mat) = cluster_60$patientcode
cluster_60_mat[!is.na(cluster_60_mat)] = 1
cluster_60_mat[is.na(cluster_60_mat)] = 0

cor20 = cor(t(cluster_20_mat))
cor20[cor20 != 1] = 0
cor30 = cor(t(cluster_30_mat))
cor30[cor30 != 1] = 0
cor40 = cor(t(cluster_40_mat))
cor40[cor40 != 1] = 0
cor50 = cor(t(cluster_50_mat))
cor50[cor50 != 1] = 0
cor60 = cor(t(cluster_60_mat))
cor60[cor60 != 1] = 0


co_occurance = (cor20+cor30+cor40+cor50+cor60)/5
co_occurance = co_occurance[o_patients,]
co_occurance = co_occurance[,o_patients]

tab = rownames(co_occurance)
tab = as.data.table(tab)
names(tab) = 'patientcode'
names(neighb_clusters_orig)[1] = 'patientcode'
tab = merge(tab,neighb_clusters_orig,by = 'patientcode')
tab = tab[order(match(patientcode,rownames(co_occurance)))]

h = Heatmap(co_occurance, name = "co_occurance", km = 1, col = colorRamp2(c(0, 1), c("white", "red")),
     show_row_names = F, show_column_names =  F,cluster_rows = F,cluster_columns = F)+

Heatmap(factor(tab$cluster), name = "Patientgroups", show_row_names = FALSE, width = unit(10, "mm"), col = structure(col_vector, names = c(as.character(1:11))))

pdf('/home/jana/Desktop/R_dat/test.pdf',width = 30 , height = 30)
h
dev.off()

#Amount changing
length(which((cor20 - cor30) %in% c(1,-1)))
length(which((cor30 - cor40) %in% c(1,-1)))
length(which((cor40 - cor50) %in% c(1,-1)))
length(which((cor50 - cor60) %in% c(1,-1)))

```

```{r}
#Boxplots stroma and SCP


#Shannon entropy per patientcode
dat_cut_tumors <- unique(cluster_dat_tumors[,c("patientcode","cluster","ncells")])

#split into cores
ind_cores <- split( dat_cut_tumors , f = dat_cut_tumors$patientcode )

shannon_cores = lapply(ind_cores, function(x){entropy.ChaoShen(x$ncells)})

shannon_core = data.table(unlist(names(shannon_cores)))
names(shannon_core) = "patientcode"
shannon_core$shannon = unlist(shannon_cores)

#SCP

sh = merge(shannon_core,meta_patient_clustering,by = 'patientcode')


p <- ggplot(sh, aes(x=factor(patient_pheno), y=shannon)) + 
  geom_boxplot()+
  geom_point(size=2, alpha=1)+
  #stat_summary( fun.y = "mean",geom="point",colour = "black", size = 5)+
  #stat_summary(aes(group=grade), fun.y=mean, geom="line", colour="green")+
  ylab("KL div to patietn average of core")+
  xlab("Patientgroup")+
  theme(panel.background = element_blank())+
  ggtitle('Cores assigned to patient group')

pdf('/home/jana/Desktop/R_dat/shannon_SCP_basel.pdf')
p
dev.off()

#Stroma
names(neighb_clusters_orig)[1] = 'patientcode'
sh = merge(shannon_core,neighb_clusters_orig)


p <- ggplot(sh, aes(x=factor(cluster), y=shannon)) + 
  geom_boxplot()+
  geom_point(size=2, alpha=1)+
  #stat_summary( fun.y = "mean",geom="point",colour = "black", size = 5)+
  #stat_summary(aes(group=grade), fun.y=mean, geom="line", colour="green")+
  ylab("KL div to patietn average of core")+
  xlab("Patientgroup")+
  ylim(c(0,3))+
  theme(panel.background = element_blank())+
  ggtitle('Cores assigned to patient group')

pdf('/home/jana/Desktop/R_dat/shannon_stromalComm_basel.pdf')
p
dev.off()
```


#Example images
```{r}


nodules_orig = merge(nodules_orig,unique(Sample_metadata[,c('core','patientcode')]),by = 'core')
nodules_orig = merge(nodules_orig,unique(nodules_wide[,c('core','cluster','Community')]),by = c('core','Community'))


cur = surv_stroma[cluster_19 == max(cluster_19),'patientcode']
nodules_orig[patientcode == cur$patientcode,]
c = nodules_orig[(core == 'BaselTMA_SP41_178_X4Y9' & cluster == 23),c('CellId','Community')]

fwrite(c,'/home/jana/Desktop/R_dat/community_examples.csv',col.names = T)

#Check grade 2 dangerous small nodules
m = melt.data.table(comb,id.vars = c('patientcode','OSmonth','Patientstatus','censoring','clinical_type','grade'))
m = m[value != 0,]
pdf('/home/jana/Desktop/R_dat/grade.pdf',width = 50, height = 10)
ggplot(m,aes(x = variable, y = value, fill = grade))+
  geom_boxplot()
dev.off()
```
