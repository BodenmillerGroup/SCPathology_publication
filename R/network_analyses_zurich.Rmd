---
title: "R Notebook"
output: html_notebook
---



#Read in microenvironment community data from Matlab (topological single-cell communities were extracted using the Matlab wrapper of the C++ Louvain implementation) including all cells (but tumor metacluster agnostic -> all tumor cells are assigned to the same cell type (Pheno = 100))
```{r}
nodules = fread('/home/ubuntu/tmp/server_homes/janaf/Data/2019/Data_publication/ZurichTMA/Communities/Community_data_microenvironment.csv',header = T)

# #Adjust naming only first time when reading from Matlab (provided data is already cleaned)
# test = unique(nodules$core)
# split_core = strsplit(nodules$core,'_', fixed = TRUE)
# nodules$core = unlist(lapply(split_core, function(x){paste(x[c(1,2,8,9,10)],collapse =  "_")}))
# #Replace the ones that don't need acquisition number again
# short = unlist(lapply(strsplit(test,'_', fixed = TRUE),function(x){paste(x[c(1,2,8,9)],collapse =  "_")}))
# duplicate_idx = duplicated(short) | duplicated(short, fromLast = TRUE)
# in_cores_index = unlist(lapply(unique(nodules$core)[duplicate_idx],function(x){which(nodules$core %in% x)}))
# nodules$core[setdiff(1:length(nodules$core),in_cores_index)] = unlist(lapply(strsplit(nodules$core[setdiff(1:length(nodules$core),in_cores_index)],'_', fixed = TRUE), function(x){paste(x[1:length(x)-1],collapse =  "_")}))
# #Delete zeros from core names
# nodules$core = unlist(lapply(nodules$core,function(x){gsub("000","",x)}))

#Calculate number of cells from each cell type per community (community numbers are only unique per core)
nodules[,size_comm := .N, by = c('Community','core')]
nodules = nodules[size_comm > 9,]
nodules[,ncells := .N , by = c('Community','Pheno','core')]
nodules[,perc_cluster := ncells/size_comm, by = c('core','Community')]

#Save variables for bellow in pipeline
save_size = unique(nodules[,c('core','Community','size_comm')])
nodules_orig = nodules

#Set all tumor cell types to metacluster 100
nodules <- unique(nodules[,c("core","Pheno","ncells","Community")])
nodules$Pheno = factor(nodules$Pheno, levels = c(rev(cluster_order[cluster_order %in% c("41","3","39","7","2" ,"21","28","18","5","1","16")]),"100"))

#Set missing cells types to 0
nodules_wide = dcast.data.table(nodules,formula = 'Community + core ~ Pheno',value.var = 'ncells',fill = 0)
nodules_wide_not_norm = nodules_wide
```

#Run PG on microenvironment communities
```{r}
#01-normalize absolute cell type numbers of each community per cel type
nodules_wide = cbind( nodules_wide[,c('Community','core')],apply(nodules_wide[,-c('Community','core')],2, function(x){(x-min(x))/(max(x)-min(x))}))

#Run PG
rand_seed = 3
rpheno_out = cytofkit::Rphenograph(nodules_wide[,-c('Community','core')], k = 20, seed = rand_seed,approx = T)
nodules_wide$cluster = rpheno_out$membership

#Write out PG result
#fwrite(nodules_wide[,c('Community','cluster','core')],'PG_stroma_zurich.csv',col.names = T)

#Read in PG result from publication
cl_dat = fread('/home/ubuntu/tmp/server_homes/janaf/Data/2019/Data_publication/ZurichTMA/Communities/PG_microenvironmnet_communities.csv',header = T)
nodules_wide = merge(nodules_wide, cl_dat, by = c('core','Community'))

```

#Heatmap of cell type content of each microenvironment community type
```{r}
nodules_long = melt.data.table(nodules_wide, id.vars = c('Community','core','cluster') ,variable.name = 'channel', value.name = 'perc_cluster')
summary_dat = nodules_long[ ,list(
  mean_val= mean(perc_cluster),
  cell_cluster=.N),
  by=.(channel,cluster)]
hm_dat = dcast.data.table(data =summary_dat, formula = 'cluster ~ channel',
                          value.var = 'mean_val') #can be exchanged for 'median_val' 

#Convert to a matrix
trownames = hm_dat$cluster
hm_dat = as.matrix(hm_dat[,-1,with=F])
row.names(hm_dat) = trownames

# Set color map
cols = rev(brewer.pal(11,'Spectral'))
cmap = colorRampPalette(cols)

# Hierarchical clustering on rows with Ward's linkage
tdist = as.dist(1-cor(t(hm_dat), method="spearman"))
hr <- hclust(tdist, method="ward.D2")
co_r <- order.optimal(tdist, hr$merge)
hr$merge = co_r$merge
hr$order = co_r$order

# Order rows in heatmap according to clustering
order_heatmap_zscored = row.names(hm_dat)[hr$order]

# Hierarchical clustering on columns with Ward's linkage
tdist = as.dist(1-cor((hm_dat), method="spearman"))
hc <- hclust(tdist, method="ward.D2")
co_c <- order.optimal(tdist, hc$merge)
hc$merge = co_c$merge
hc$order = co_c$order

# Z-score data
p_dat = scale(hm_dat)

# Censor z-score at 2
p_dat[p_dat > 2] =2
p_dat[p_dat < -2] =-2

#Save order
order_stroma = hr$labels[hr$order]


pdf(file="stroma_node_heatmap_k20_zurich.pdf", width=10, height=10)

heatmap.2(p_dat,
          scale ='none',
          trace = "none",
          col=cmap(75),
          Rowv=as.dendrogram(hr),
          Colv=as.dendrogram(hc),
          density.info ='none',
          cexRow=0.6,
          cexCol=0.6,
          margins=c(4,8),
          xlab = 'Markers',
          ylab ='Cluster',
          main = 'PG_norm_slide',
          colCol = c(rev(rev(cols_corresp_basel)[cluster_order %in% c("41","3" , "39","7","2" ,"21","28","18","5","1","16")]),'black'), 
          colRow = col_vector) 

dev.off()
```

#Run tsne on microenvironment communities based on cell type content
```{r}
dat_tsne = nodules_wide[!duplicated(nodules_wide[,-c('Community','core','cluster')])] 

#Run a new tsne
require(doParallel)
cores = 10
options('mc.cores' = cores)
registerDoParallel(cores)
tsne_comm <- Rtsne.multicore::Rtsne.multicore(dat_tsne[,-c('Community','core','cluster')], 
            verbose = T, dims = 2, num_threads = 10)

#Save out tsne results
#fwrite(cbind(dat_tsne,tsne_comm$Y),'tsne_stroma_zurich_final.csv',col.names = F)

#Read in previous tsne result from publication
tsne_comm = fread('/home/ubuntu/tmp/server_homes/janaf/Data/2019/Data_publication/ZurichTMA/Communities/tsne_microenvironment_communities.csv')

dat_tsne = merge(dat_tsne,tsne_comm,by = c('Community','core'))
dat_tsne$cluster = factor(dat_tsne$cluster,order_stroma)

#plot tsne of microenvironment communities
p = dat_tsne%>%
  ggplot(aes(x=V1, y=V2))+
  geom_point(size=1, alpha=0.8, aes(color=cluster))+
  labs(colour="Patients")+
  scale_color_manual(values = col_vector[as.numeric(order_stroma)])+
  ggtitle('Phenograph')+
  guides(color=guide_legend(override.aes=list(size=5)))+
  theme(strip.background = element_blank(),
        panel.background=element_rect(fill='white', colour = 'black'),
        panel.grid.major=element_blank(),
        panel.grid.minor=element_blank(),
        plot.background=element_blank(),
        legend.key = element_blank())

pdf('microenv_communities_tsne.pdf',width = 10,height = 10)
p
dev.off()
```

#Stacked bars showing absolute numbers of cells of each cell type per community type
```{r}
cl_dat = fread('/home/ubuntu/tmp/server_homes/janaf/Data/2019/Data_publication/ZurichTMA/Communities/PG_microenvironmnet_communities.csv',header = T)
nodules_wide_not_norm = merge(nodules_wide_not_norm,cl_dat,by = c('Community','core'))
nodules_long = melt.data.table(nodules_wide_not_norm, id.vars = c('Community','core','cluster') ,variable.name = 'channel', value.name = 'perc_cluster')
nodules_long$perc_cluster = as.double(nodules_long$perc_cluster)

set.seed(2)
summary_dat = nodules_long[ ,list(
  median_val = median(perc_cluster),
  mean_val= mean(perc_cluster),
  #std_val = std(perc_cluster),
  cell_cluster=.N),
  by=.(channel,cluster)]


hm_dat = dcast.data.table(data =summary_dat, formula = 'cluster ~ channel',
                          value.var = 'mean_val') #can be exchanged for 'median_val' 

#Bars ordered acciording to heatmap
d = unique(summary_dat[,c('channel','cluster','mean_val')])
p <- ggplot(d, aes(x=factor(cluster,levels = hr$labels[hr$order]), y=mean_val, fill=factor(channel))) + 
  geom_bar(stat='identity',show.legend = TRUE)+
  scale_fill_manual("Clusters",values =  c(rev(rev(cols_corresp_basel)[cluster_order %in% c("41","3" , "39","7","2" ,"21","28","18","5","1","16")]),'black'))+ 
  labs(fill = "Clusters")+
  coord_flip()+
  xlab("Patient")+
  ylab("Percentage of cluster cells in patient")+
  theme(panel.background = element_blank(),
        axis.text.y = element_text(colour=col_vector[as.numeric(hr$labels[hr$order])]))+
  ggtitle('Patient composition')

pdf('comm_cluster_compositions.pdf',width = 10,height = 10)
p
dev.off()

```

#Clustered heatmaps showing how tumors are made up by the different microenvironment community types (and grouping into 11 stromal environments SE)
```{r}

#Prepare data
nodules_wide = merge(nodules_wide,Sample_metadata[,c('core','PID')],by = 'core')
enrichment = unique(nodules_wide[,c('cluster','Community','core')])
enrichment[,both := .N, by = c('cluster','core')]
enrichment[,frac_patient := both/.N, by = c('core')]
enrichment = unique(enrichment[,c('core','cluster','frac_patient')])
d = dcast.data.table(enrichment,formula = 'core  ~ cluster',value.var = 'frac_patient',fill = 0)

#Merge with matched SCP patient group info
d = merge(d,SCP_match,by = 'core')
d = merge(d,unique(Sample_metadata[,c('core','clinical_type')]),by = 'core')

#Read in original ordering of this table according to original patient IDs. IDs had to be changed for publication but order needs to remain for result from publication to be exactly reproducible.
order_orig = fread('/home/ubuntu/tmp/server_homes/janaf/Data/2019/Data_publication/ZurichTMA/Communities/order_orig.csv',header = T)
d = d[order(match(core,as.character(order_orig$core))),]
d_mat = as.matrix(d[,-c('core','patient_pheno','clinical_type')])
rownames(d_mat) = d$core

#Cluster into 11 groups
hr = hclust(dist(d_mat), method = "ward.D2")
clusters = dendextend::cutree(hr, k = 11)
cnames = names(clusters)
n_clusters = data.table(cnames)
names(n_clusters) = 'core'
n_clusters$cluster = unlist(clusters)
n_clusters_orig = n_clusters

h = Heatmap(d_mat, name = "Clustergram", km = 1, col = colorRamp2(c(0, 1), c("white", "red")),
     show_row_names = T, show_column_names =  T, clustering_method_rows = "ward.D2",clustering_method_columns = "ward.D2",split = clusters)+
Heatmap(factor(d$patient_pheno), name = "SCP", show_row_names = FALSE, width = unit(10, "mm"), col = structure(mycols_patient[sort(unique(d$patient_pheno))], names = as.character(sort(unique(d$patient_pheno)))))+
  Heatmap(factor(d$clinical_type), name = "clinical_type", show_row_names = FALSE, width = unit(10, "mm"), col = structure(mycols_clinical, names = c('HR-HER2+','HR+HER2-','HR+HER2+','TripleNeg')))

#Save orders
o_stroma = column_order(h)
o_patients = names(clusters[unlist(row_order(h))])

pdf('microenv_communities.pdf',width = 10, height = 30)
h
dev.off()

#Icons describing cell type contents of each Stromal Environment (SE)
icon = merge(nodules_orig,n_clusters_orig,by = 'core')
icon = unique(icon[,c('Pheno','ncells','core','Community','cluster')])
icon[,tot := sum(as.double(ncells)), by = c('cluster','Pheno')]
icon[,avg := tot/sum(tot), by = c('cluster')]

bp<- ggplot(icon, aes(x="", y=avg, fill=factor(Pheno,levels = c(cluster_order[cluster_order %in% c("41","3" , "39","7","2","21","28","18","5","1","16")],'100'))))+
geom_bar(width = 1, stat = "identity")+
  facet_wrap(~cluster, ncol = 5)+
  scale_fill_manual("Clusters",values =  c(rev(cols_corresp_basel)[cluster_order %in% c("41","3","39","7","2" ,"21","28","18","5","1","16")],'black'))+
    theme(strip.background = element_blank(),
        panel.background=element_rect(fill='white', colour = 'black'),
        panel.grid.major=element_blank(),
        panel.grid.minor=element_blank(),
        plot.background=element_blank(),
        legend.key = element_blank())

pdf('icons.pdf',width = 10, height = 20)
bp
dev.off()

```

#SCP and SE patientgroup enrichments
```{r}
#Enrichment bubble plot between SCP and SE patient groups
cors = merge(n_clusters_orig,SCP_match,by = 'core')
cors[,nr_both := .N, by = c('cluster','patient_pheno')]
cors[,perc_ME := nr_both/.N, by = c('cluster')]
cors[,perc_CT := nr_both/.N, by = c('patient_pheno')]
cors$cluster = factor(cors$cluster, levels = as.character(1:11))
cors$patient_pheno = factor(cors$patient_pheno)
colnames(cors)[1:3] = c('PID','StromalComm_groups','SCP_groups')

#plot
p4 <- ggplot(cors,aes(y=StromalComm_groups,x=SCP_groups))+
  geom_point(aes(colour = perc_ME, 
                 size =perc_CT))  +   
scale_color_gradient2(low = "blue",  
                     mid = "white",
                     high = "red",
                     name = "Fraction of Comm_cluster in SCP group")+       
scale_size(range = c(1, 15),name = "Fraction of SCP in Comm_cluster group") +
      theme(axis.text.x=element_text(color = c(mycols_patient[sort(as.numeric(levels(cors$SCP_groups)))])))

pdf('Zurich_enrichment_SE_SCP_groups.pdf',width = 20, height = 10)
p4
dev.off()


#Loop through all SE patient groups and test for all SCP groups each one contains whether there is a significant enrichment
overview = list()
counter = 1
for (i in unique(cors$StromalComm_groups)){
  logic_vector = cors$StromalComm_groups == i
  MEs = unique(cors$SCP_groups[logic_vector])
  ME_vectors = lapply(MEs, function(x){cors$SCP_groups == x})
  res = lapply(ME_vectors, function(x){fisher.test(logic_vector,x,alternative = 'greater')})
  p = unlist(lapply(res, function(x){x$p.value}))
  CT_name = rep(i,length(MEs))
  ME_name = as.character(MEs)
  #Correct for multiple testing
  adjusted_p = p.adjust(p, method = 'bonferroni', n = length(p))
  overview[[counter]] = cbind(CT_name,ME_name,adjusted_p)
  counter = counter + 1
}

d = data.table(do.call(rbind,overview))
colnames(d) = c('StromalCommRegion','SCP_groups','adjusted_p')
fwrite(d,file = 'enrichment_p_vals_SCP_SE.csv',col.names = T)


#Enrichment bubble plot between clinical subtype and SE patient groups
cors = merge(n_clusters_orig,unique(Sample_metadata[,c('core','clinical_type')]),by = 'core')
cors = cors[clinical_type != '',]
cors[,nr_both := .N, by = c('cluster','clinical_type')]
cors[,perc_ME := nr_both/.N, by = c('cluster')]
cors[,perc_CT := nr_both/.N, by = c('clinical_type')]
cors$cluster = factor(cors$cluster, levels = as.character(1:11))
cors$clinical_type = factor(cors$clinical_type)
colnames(cors)[1:3] = c('patientcode','StromalComm_groups','clinical_type')

#plot
p4 <- ggplot(cors,aes(y=StromalComm_groups,x=clinical_type))+
  geom_point(aes(colour = perc_ME, 
                 size =perc_CT))  +   
scale_color_gradient2(low = "blue",  
                     mid = "white",
                     high = "red",
                     name = "Fraction of Comm_cluster in clinical_type group")+       
scale_size(range = c(1, 15),name = "Fraction of clinical_type in Comm_cluster group") +
      theme(axis.text.x=element_text(color = c(mycols_clinical)))

pdf('Zurich_enrichment_SE_clinical_groups.pdf',width = 20, height = 10)
p4
dev.off()


#Loop through all SE patient groups and test for all clinical subtypes each one contains whether there is a significant enrichment
overview = list()
counter = 1
for (i in unique(cors$StromalComm_groups)){
  logic_vector = cors$StromalComm_groups == i
  MEs = unique(cors$clinical_type[logic_vector])
  ME_vectors = lapply(MEs, function(x){cors$clinical_type == x})
  res = lapply(ME_vectors, function(x){fisher.test(logic_vector,x,alternative = 'greater')})
  p = unlist(lapply(res, function(x){x$p.value}))
  CT_name = rep(i,length(MEs))
  ME_name = as.character(MEs)
  #Correct for multiple testing
  adjusted_p = p.adjust(p, method = 'bonferroni', n = length(p))
  overview[[counter]] = cbind(CT_name,ME_name,adjusted_p)
 
  counter = counter + 1
}

d = data.table(do.call(rbind,overview))
colnames(d) = c('StromalCommRegion','clinical_type','adjusted_p')
fwrite(d,file = 'enrichment_p_vals_clinical_SE.csv',col.names = T)
```

#Center or periphery core origin of microenvironment community types
```{r}
nodules_wide = merge(unique(Sample_metadata[,c('core','PID','location')]),nodules_wide,by = 'core')
cluster_loc = nodules_wide[,c('cluster','core','Community','location')]
cluster_loc$cluster = factor(cluster_loc$cluster)
cluster_loc = cluster_loc[!location %in% c('NORMAL','METASTASIS','[]'),]
cluster_loc[,count := .N, by = c('cluster','location')]
cluster_loc[,frac_cluster := count/.N, by = 'cluster']
cluster_loc[,frac_location := count/.N, by = 'location']
cluster_loc = unique(cluster_loc[,c('cluster','location','frac_cluster')])

#Stacked bar plot
p <- ggplot(cluster_loc, aes(x=cluster, y=frac_cluster, fill=factor(location,levels = c('CENTER','PERIPHERY')))) + 
  geom_bar(stat='identity',show.legend = TRUE)+
  scale_fill_manual("Clusters",values = c('red','blue'))+
  labs(fill = "Location")+
  coord_flip()+
  xlab("loc")+
  ylab("Frac cluster")+
  theme(panel.background = element_blank(),
        axis.text.y = element_text(colour=col_vector))+
  ggtitle('Location composition')


pdf('zurich_community_location_microenv.pdf',width = 10, height = 20)
p
dev.off()

```

#Order neighborhood analysis output per image (imported above) according to SEs
```{r}
clustergram_dat_meta = clustergram_dat_meta[core %in% o_patients,]
clustergram_dat_meta = clustergram_dat_meta[order(match(core,o_patients))]
mat = mat[clustergram_dat_meta$core,]
splitting = clusters
splitting = splitting[order(match(names(splitting),clustergram_dat_meta$core))]
splitting = splitting[names(splitting) %in% clustergram_dat_meta$core]

#Add colorbars for location, met status, grade and patient ID
h = Heatmap(mat, name = "Clustergram", km = 1, col = colorRamp2(c(-1, 0, 1), c("blue", "white", "red")),
     show_row_names = TRUE, show_column_names =  TRUE, cluster_rows = F,clustering_method_columns = "ward.D2",split = splitting)+   
 Heatmap(factor(clustergram_dat_meta$location), name = "Location", show_row_names = FALSE, width = unit(10, "mm"), col = structure(c("white","red","blue","black"), names = c('[]','CENTER','PERIPHERY','METASTASIS')))+ 
Heatmap(factor(clustergram_dat_meta$grade), name = "Grade", show_row_names = FALSE, width = unit(10, "mm"), col = structure(c("green","blue","red",'black'), names = c('1','2','3','METASTASIS')))+ 
Heatmap(factor(clustergram_dat_meta$PTNM_M), name = "Met", show_row_names = FALSE, width = unit(10, "mm"), col = structure(c("black","gray",'white'), names = c('M1','M0_IPLUS','M0')))+ 
  Heatmap(factor(clustergram_dat_meta$PID), name = "Patient", show_row_names = T, width = unit(10, "mm"), col = structure(c(col_vector,'black','gray'), names = levels(factor(clustergram_dat_meta$PID))))


pdf('neighborhood_accordingtoSE.pdf',width = 90, height = 60)
h
dev.off()


#Enrichment analysis for pairwise neighborhood interactions in SE groups
n_clusters_orig = merge(n_clusters_orig,clustergram_dat,by = 'core')
n_clusters_orig$cluster = as.factor(n_clusters_orig$cluster)

#Loop through all pairwise neighborhood interactions and test for each significantly enriched/depleted interaction whether there is a enrichment for one SE group. Run once for positive interactions (enrichments) and once for negative (avoidances).
overview = list()
counter = 1
for (i in 4:ncol(n_clusters_orig)){
  cur = as.matrix(n_clusters_orig[,eval(i),with =F])
  cur[cur == -1] = 0
  if (sum(cur)> 0){ #adapt sign: run once for positive interactions and once for negative interactions (also adapt -1 to 1 bellow)
    cur = as.factor(cur)
    #only for positive association
    res = lapply(unique(n_clusters_orig$cluster), function(x){fisher.test(cur == 1,n_clusters_orig$cluster == x,alternative = 'greater',simulate.p.value=TRUE)}) 
    p = unlist(lapply(res, function(x){x$p.value}))
    interaction_name = rep(names(n_clusters_orig)[i],length(unique(n_clusters_orig$cluster)))
    group_name = unique(n_clusters_orig$cluster)
    #Correct for multiple testing of different SEs
    adjusted_p = p.adjust(p, method = 'bonferroni', n = length(p))
    overview[[counter]] = cbind(interaction_name,group_name,adjusted_p)
    counter = counter + 1
    }
}

#Write out overview of results
d = data.table(do.call(rbind,overview))
d = d[adjusted_p < 0.05,]
fwrite(d,file = 'Zurich_enrichment_SE_significantInteractions_positive.csv',col.names = T)

```




