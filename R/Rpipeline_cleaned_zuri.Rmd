---
  title: "R downstream analysis Zurich TMA"
author: "Jana Fischer"
html_document: default
---

#Downstream R analysis for Zurich TMA on final single cell data (after cleaning of SC and metadata, final cleaned data provided). Produces all Figure content related to the Zurich TMA and aligns with Basel TMA. This pipeline uses output files from the previously run BaselTMA_pipeline. These files are provided in the output folder.
  
```{r}
library(data.table)
library(RColorBrewer)
library(dplyr)
library(gplots)
library(ggplot2)
library(stringr)
```

```{r Settings}

fn_cells = '/home/ubuntu/tmp/server_homes/janaf/Data/2019/Data_publication/ZurichTMA/SC_dat.csv'
fn_meta = '/home/ubuntu/tmp/server_homes/janaf/Data/2019/Data_publication/ZurichTMA/Zuri_PatientMetadata.csv'
fn_ZuriPheno = '/home/ubuntu/tmp/server_homes/janaf/Data/2019/Data_publication/ZurichTMA/PG_zurich.csv'

# Define channels to be excluded
channel_exclude = c("ImageId" ,"CellId" ,"In115 115InIn115Di","Xe134 134XeXe134Di","Hg202 202HgHg202Di","Pb204 204PbPb204Di","Pb206 206PbPb206Di","ArAr80 80ArArArAr80Di","phospho Erk12", "10311239Ru96Di Rutheni","10311240Ru98Di Rutheni","10311241Ru99Di Rutheni", "10311242Ru100Di Rutheni","10311243Ru101Di Rutheni", "10311244Ru102Di Rutheni","10311245Ru104Di Rutheni","Xe126 126XeXe126Di","I127 127II127Di","Xe131 131XeXe131Di","Pb207 207PbPb207Di","Pb208 208PbPb208Di","EulerNumber","MajorAxisLength","MinorAxisLength", "Orientation","10331253Ir191Di Iridium","2971330Dy161Di EpCAM","Perimeter","1971527Ho165Di bCaten","483739Yb171Di Sox9","Solidity")

#Save cluster order of Figures
cluster_order = c('37','4','10','11','27','6','19','22','29','31','24','14','30','32','9','23','33','34','40','13','12','17','20','38','15','26','35','25','8','41','3','39','7','2','21','28','18','5','1','16');

```

#Load the data
```{r}
#Single-cell data
dat <- fread(fn_cells,header = T)
#Patient metadata
Sample_metadata <- fread(fn_meta,header = T)
#PhenoGraph result from publication
custom_PG <- fread(fn_ZuriPheno, header = T)

```

#Display the channels used for analysis
```{r}
good_channels = unique(dat$channel)[!unique(dat$channel) %in% channel_exclude]
print(good_channels)
```

#Define a colormap used for general plots
```{r Generate a color pallette for plotting}
qual_col_pals = brewer.pal.info[brewer.pal.info$category == 'qual',]
col_vector = unlist(mapply(brewer.pal, qual_col_pals$maxcolors, rownames(qual_col_pals)))
col_vector = unique(col_vector)
```

#Define custom colormap with colors according to cell types as used in pulication
```{r Generate a color pallette for plotting}
#colors matched to most similar cell type from Basel TMA (see alignment bellow)
mycols =c("darkolivegreen","darkolivegreen","darkolivegreen1","green3","cadetblue1","darkslategray1","darkslategray1","yellow","turquoise1","turquoise1","lightskyblue","lightpink","dodgerblue4","blue","blue","aquamarine","aquamarine","aquamarine","aquamarine4","brown1","firebrick","purple4","purple4","purple4","purple4","purple4","darkorchid","darkorchid","darkorchid","salmon","chocolate","chocolate","chocolate","chocolate","orange2","deeppink1","deeppink1","deeppink1","deeppink1","tan4")

#Write out color map for use in other software (e.g. highlight cells in corresponding colors in histoCAT)
RGB = t(col2rgb(mycols[order(rev(as.numeric(cluster_order)))])) #in histoCAT clusters are ordered sequentially according to their cluster number
RGB_norm = (RGB - min(RGB))/(max(RGB) - min(RGB)) 
fwrite(data.table(RGB_norm), file='/home/jana/Desktop/R_dat/RGB_basel_meta.csv', col.names = TRUE)
hex = rgb(RGB_norm)

#Metacluster colors from Basel TMA
mycols_basel_meta <- colors()[c(258,257,86,85,259,81, #green
                                652, #yellow
                                636,520,430,109,68,43,#light blue
                                132,#other dark blue
                                26,#dark blue
                                8,12, #turquouis
                                33,#red
                                551,#dark purple
                                95,#light purple
                                419,#light pink
                                117,#pink
                                52,#burnt orange
                                500,#orange
                                568,#pink orange
                                624, #brown
                                133)] #dark red


#SCP patient group colors
mycols_patient = colors()[c(52,500,540,568,571,117,419,314,371,450,95,551,33,8,12,26,132,624)]

#Colormap for clinical subgroups
mycols_clinical = colors()[c(545,622,525,74)]
                
```

#Extract relevant PhenoGraph columns from custom_PG dataset
```{r}
# Get Phenograph column
custom_PG[, id := paste(.BY,collapse =  "_"), by=.(core,CellId)] 
pheno_cn <- c("id",colnames(custom_PG)[grep('PhenoGraph', colnames(custom_PG))])
cluster_pheno <- custom_PG[,pheno_cn, with=FALSE]
colnames(cluster_pheno) <- c("id","cluster")
```

#Plot heatmaps of the phenograph clusters for zurich TMA only
```{r}
setkey(dat,id)

#Exclude controls
dat = dat[!str_detect(dat$core,'control'),]
dat = dat[!str_detect(dat$core,'non-breast'),]
cluster_pheno = cluster_pheno[!str_detect(cluster_pheno$id,'non-breast'),]
cluster_pheno = cluster_pheno[!str_detect(cluster_pheno$id,'control'),]

#Exclude bad stains (these images are excluded from all further analysis because they turned out to be stained very weakly which resulted in almost all contained cells clustering together)
dat = dat[!str_detect(dat$core,regex('Ay.x1')),]
dat = dat[!str_detect(dat$core,regex('Ay..x1')),]
cluster_pheno = cluster_pheno[!str_detect(cluster_pheno$id,'Ay.x1'),]
cluster_pheno = cluster_pheno[!str_detect(cluster_pheno$id,'Ay..x1'),]

cluster_pheno$cluster <- factor(cluster_pheno$cluster, levels = cluster_order)
dat[,c_counts := bbRtools::censor_dat(mc_counts,0.99),by = channel]
#dat[, sc_counts := scale(mc_counts,censor_val), by=channel]

summary_dat = dat[cluster_pheno][ channel %in% good_channels ,list(
  median_val = median(c_counts),
  mean_val= mean(c_counts),
  cell_cluster=.N),
  by=.(channel,cluster)]

hm_dat = dcast.data.table(data =summary_dat, formula = 'cluster ~ channel',
                          value.var = 'mean_val') #'median_val' can be exchanged for 'mean_val'
                          
trownames = hm_dat$cluster
hm_dat = as.matrix(hm_dat[,-1,with=F])
row.names(hm_dat) = trownames

```

Plot the heatmap with z-scoring per marker
```{r}
# Set color map
cols = rev(brewer.pal(11,'Spectral'))
cmap = colorRampPalette(cols)

# Hierarchical clustering on rows with Ward's linkage
tdist = as.dist(1-cor(t(hm_dat), method="spearman"))
hr <- hclust(tdist, method="ward.D2")
co_r <- order.optimal(tdist, hr$merge)
hr$merge = co_r$merge
hr$order = co_r$order

#Order rows in heatmap according to clustering
order_heatmap_zscored = row.names(hm_dat)[hr$order]

# Hierarchical clustering on columns with Ward's linkage
tdist = as.dist(1-cor((hm_dat), method="spearman"))
hc <- hclust(tdist, method="ward.D2")
co_c <- order.optimal(tdist, hc$merge)
hc$merge = co_c$merge
hc$order = co_c$order

# Z-score data
p_dat = scale(hm_dat)

# Censor z-score at 2
p_dat[p_dat > 2] =2
p_dat[p_dat < -2] =-2


pdf(file="heatmap_zuri.pdf", width=10, height=10)

heatmap.2(p_dat,
          scale ='none',
          trace = "none",
          col=cmap(75),
          Rowv=as.dendrogram(hr),
          Colv=as.dendrogram(hc),
          density.info ='none',
          cexRow=0.6,
          cexCol=0.6,
          margins=c(4,8),
          xlab = 'Markers',
          ylab ='Cluster',
          main = 'PG_norm_slide')

dev.off()

```

#Match PG clusters from Zurich TMA to Basel TMA metaclusters
```{r}
# Z-score zurich data
hm_dat_zuri = hm_dat
hm_dat_zuri = scale(hm_dat_zuri)

#Read in metacluster means from Basel TMA
hm_dat_basel = fread('/home/ubuntu/tmp/server_homes/janaf/Data/2019/Data_publication/ZurichTMA/output_BaselTMA/hm_dat_basel.csv',header = T)
rownames = hm_dat_basel$V1
hm_dat_basel = as.matrix(hm_dat_basel[,-1])
rownames(hm_dat_basel)= rownames

# Z-score basel data
hm_dat_basel = scale(hm_dat_basel)

#Make sure all the same markers are used
colnames(hm_dat_zuri)[!colnames(hm_dat_zuri) %in% colnames(hm_dat_basel)] 
colnames(hm_dat_basel)[!colnames(hm_dat_basel) %in% colnames(hm_dat_zuri)]

#Calculate distances based on correlations between zurich and basel clusters
crosscor = 1-cor(t(hm_dat_basel),t(hm_dat_zuri),method = 'pearson')
#Find most similar cluster
idx_min = apply(crosscor,2,function(x){which(x == min(x))})
dist_min = apply(crosscor,2,min)
cluster_match = data.table(rownames(crosscor)[unlist(idx_min)])
colnames(cluster_match) = 'Basel'
cluster_match$zuri = colnames(crosscor)
cluster_match$dist = dist_min
cluster_match$zuri = as.numeric(cluster_match$zuri)
cluster_match = cluster_match[order(zuri),]

#Plot heatmap of Zurich PG clusters ordered and colored according to matching Basel metacluster
p_dat = hm_dat_zuri
p_dat[p_dat > 2] =2
p_dat[p_dat < -2] =-2
p_dat = p_dat[order(as.numeric(rownames(p_dat))),]

#Read in order from metacluster heatmap of Basel TMA (saved out in output from BaselTMA pipeline) in order to sort this heatmap accordingly
ordered_labels = fread('/home/ubuntu/tmp/server_homes/janaf/Data/2019/Data_publication/ZurichTMA/output_BaselTMA/ordered_labels_basel.csv',header = F)
ordered_labels = ordered_labels$V1
ordered_channels = fread('/home/ubuntu/tmp/server_homes/janaf/Data/2019/Data_publication/ZurichTMA/output_BaselTMA/ordered_channels_basel.csv',header = F,fill = T)
ordered_channels = ordered_channels[-1,]

cluster_match = cluster_match[order(as.numeric(Basel)),]
p_dat = p_dat[as.character(rev(cluster_match[order(match(cluster_match$Basel[cluster_match$Basel %in% ordered_labels],ordered_labels)),zuri])),]
p_dat = p_dat[,match(ordered_channels$V1,colnames(p_dat))]

cols_corresp_basel = mycols_basel_meta[rev(as.numeric(cluster_match[order(match(cluster_match$Basel[cluster_match$Basel %in% ordered_labels],ordered_labels)),Basel]))]

#Visualizes fully automatic assignment but for the publication a few clusters were reassigned based prior knowledge about markers (for example, cluster 15 was assigned to an immune cell based on marker correlations but contains some tumor markers, hence it was manually reassigned to the most similar tumor cell type)
pdf('zuri_heatmap_color_and_ord_matched_Basel.pdf')
heatmap.2(p_dat,
          scale ='none',
          trace = "none",
          col=cmap(75), dendrogram = "none", Rowv = FALSE, Colv = FALSE,
          density.info ='none',
          cexRow=0.6,
          cexCol=0.6,
          margins=c(4,8),
          xlab = 'Markers',
          ylab ='Cluster',
          main = 'PG_matched',
          colRow = cols_corresp_basel)
dev.off()


#Reassign some clusters as done for publication
cluster_match$Basel[cluster_match$zuri == 29] = 23 #different tumor cluster matched better based on relevant markers
cluster_match$Basel[cluster_match$zuri == 40] = 19 #different tumor cluster matched better based on relevant markers
cluster_match$Basel[cluster_match$zuri == 6] = 24 #different tumor cluster matched better based on relevant markers
cluster_match$Basel[cluster_match$zuri == 11] = 22 #different tumor cluster matched better based on relevant markers
cluster_match$Basel[cluster_match$zuri == 8] = 21 #This cluster forms tumor bulks (not stromal!!)
cluster_match$Basel[cluster_match$zuri == 9] = 19 #different tumor cluster matched better based on relevant markers
cluster_match$Basel[cluster_match$zuri == 26] = 15 #different tumor cluster matched better based on relevant markers
cluster_match$Basel[cluster_match$zuri == 15] = 16 #this has tumor markers
# cluster_match$Basel[cluster_match$zuri == 41] = 10
# cluster_match$Basel[cluster_match$zuri == 39] = 8 
# cluster_match$Basel[cluster_match$zuri == 3] = 8
cluster_match$Basel[cluster_match$zuri == 1] = 3

#Plot publication version
cluster_match = cluster_match[order(as.numeric(Basel)),]
p_dat = p_dat[as.character(rev(cluster_match[order(match(cluster_match$Basel[cluster_match$Basel %in% ordered_labels],ordered_labels)),zuri])),]
p_dat = p_dat[,match(ordered_channels$V1,colnames(p_dat))]

cols_corresp_basel = mycols_basel_meta[rev(as.numeric(cluster_match[order(match(cluster_match$Basel[cluster_match$Basel %in% ordered_labels],ordered_labels)),Basel]))]

pdf('zuri_heatmap_color_and_ord_matched_Basel.pdf')
heatmap.2(p_dat,
          scale ='none',
          trace = "none",
          col=cmap(75), dendrogram = "none", Rowv = FALSE, Colv = FALSE,
          density.info ='none',
          cexRow=0.6,
          cexCol=0.6,
          margins=c(4,8),
          xlab = 'Markers',
          ylab ='Cluster',
          main = 'PG_matched',
          colRow = cols_corresp_basel)
dev.off()

```

#Plot marker distributions for each cell type cluster
```{r}
#per channel
for (i in unique(dat[channel %in% good_channels,]$channel)){
  cdat <- dat[cluster_pheno][channel %in% good_channels,][channel == i,][,markermean:= mean(c_counts),by = 'cluster']
  pdf(paste0('marker_distributions_channel_',as.character(i),'.pdf'),width = 30,height = 150)
  print(ggplot(cdat, aes(x=c_counts, colour=cluster)) +
      geom_density(aes(y=..scaled..)) +
      geom_vline(data=cdat, aes(xintercept=markermean,  colour=cluster),
                 linetype="dashed", size=1)+
      facet_wrap( ~ cluster, ncol=1)+
    scale_color_manual(values = rev(mycols)))
  dev.off()}
```

Reproduce clustergram from neighborhood analysis in R with some adaptations
```{r}

#Read in data from histoCAT neighborhood analysis where stromal/immune/Endothelial Metaclusters are separate but all tumor cells have the same label (100)
clustergram_dat = read.csv('/home/ubuntu/tmp/server_homes/janaf/Data/2019/Data_publication/ZurichTMA/neighborhood_output/Clustergram_Zurich.csv',header = T,row.names = 1)

##Adapt names to be consistent with naming here, only necessary first time when importing from neighborhood run in histoCAT (provided neighborhood output is already cleaned)
# rnames = rownames(clustergram_dat)
# clustergram_dat = data.table(clustergram_dat)
# clustergram_dat$core = rnames
# test = unique(clustergram_dat$core)
# split_core = strsplit(clustergram_dat$core,'_', fixed = TRUE)
# clustergram_dat$core = unlist(lapply(split_core, function(x){paste(x[c(1,2,8,9,10)],collapse =  "_")}))
# #Replace the ones that don't need acquisition number again
# short = unlist(lapply(strsplit(test,'_', fixed = TRUE),function(x){paste(x[c(1,2,8,9)],collapse =  "_")}))
# duplicate_idx = duplicated(short) | duplicated(short, fromLast = TRUE)
# in_cores_index = unlist(lapply(unique(clustergram_dat$core)[duplicate_idx],function(x){which(clustergram_dat$core %in% x)}))
# clustergram_dat$core[setdiff(1:length(clustergram_dat$core),in_cores_index)] = unlist(lapply(strsplit(clustergram_dat$core[setdiff(1:length(clustergram_dat$core),in_cores_index)],'_', fixed = TRUE), function(x){paste(x[1:length(x)-1],collapse =  "_")}))
# #Delete zeros
# clustergram_dat$core = unlist(lapply(clustergram_dat$core,function(x){gsub("000","",x)}))

#Exclude weak stains
clustergram_dat = clustergram_dat[!str_detect(clustergram_dat$core,regex('Ay.x1')),]
clustergram_dat = clustergram_dat[!str_detect(clustergram_dat$core,regex('Ay..x1')),]

#Remove controls
clustergram_dat = clustergram_dat[!str_detect(clustergram_dat$core,'control'),]
clustergram_dat = clustergram_dat[!str_detect(clustergram_dat$core,'non-breast'),]

#Remove normal samples
clustergram_dat = merge(clustergram_dat,unique(Sample_metadata[,c('core','location')]),by = 'core')
clustergram_dat = clustergram_dat[!location %in% c('[]','METASTASIS'),]
clustergram_dat = clustergram_dat[,-'location']

clustergram_dat_meta = merge(clustergram_dat,Sample_metadata,by = 'core')


#Prepare for clustered heatmap
rnames = clustergram_dat$core
mat = as.matrix(clustergram_dat[,-'core'])
rownames(mat) = rnames

#Split into clusters, not used for publication
hr = hclust(dist(mat), method = "ward.D2")
clusters = dendextend::cutree(hr, k = 10)

#Write out clusters
cnames = names(clusters)
neighb_clusters = data.table(cnames)
names(neighb_clusters) = 'core'
neighb_clusters$cluster = unlist(clusters)

#Plot heatmap
h = Heatmap(mat, name = "Clustergram", km = 1, col = colorRamp2(c(-1, 0, 1), c("blue", "white", "red")),
     show_row_names = T, show_column_names =  T, clustering_method_rows = "ward.D2",clustering_method_columns = "ward.D2",split = clusters)+   #  row_order = rev(order_stacked), cluster_rows = FALSE
#location
    Heatmap(factor(clustergram_dat_meta$location), name = "Location", show_row_names = FALSE, width = unit(10, "mm"), col = structure(c("white","red","blue","black"), names = c('[]','CENTER','PERIPHERY','METASTASIS')))+ 
 #grade 
Heatmap(factor(clustergram_dat_meta$grade), name = "Grade", show_row_names = FALSE, width = unit(10, "mm"), col = structure(c("green","blue","red",'black'), names = c('1','2','3','METASTASIS')))+ 
#Mets
Heatmap(factor(clustergram_dat_meta$PTNM_M), name = "Met", show_row_names = FALSE, width = unit(10, "mm"), col = structure(c("black","gray",'white'), names = c('M1','M0_IPLUS','M0')))
  
  
pdf('clustergram_ZuriImages_far.pdf',width = 20,height = 20)
h
dev.off()


```

#Location composition of clusters from heatmap above
```{r}
loc_arc = merge(neighb_clusters,unique(Sample_metadata[,c('core','location')]),by = 'core')
loc_arc[,count := .N ,by = c('cluster','location')]
loc_arc[,frac_cluster := count/.N, by = 'cluster']
loc_arc[,frac_location := count/.N, by = 'location']
loc_arc = unique(loc_arc[,c('cluster','location','frac_cluster')])

p <- ggplot(loc_arc, aes(x=as.factor(cluster), y=frac_cluster, fill=as.factor(location))) + 
  geom_bar(stat='identity',show.legend = TRUE)+
  scale_fill_manual("Clusters",values =  c('red','blue'))+ 
  labs(fill = "Location")+
  coord_flip()+
  xlab("mArc")+
  ylab("Frac location")+
  theme(panel.background = element_blank())+
  ggtitle('Location composition')


pdf('mArc_location.pdf')
p
dev.off()

```

#Prepare data for patient and image cell type counts
```{r}
#Count number of cells per core and cluster
dat_cluster_caseID = dat[cluster_pheno][, .(ncells=.N),by=.(core, channel, cluster)]
dat_cluster_caseID[, id:=paste(cluster, core)]
setkey(dat_cluster_caseID, 'id')

#Remove duplicates
cluster_dat = subset(dat_cluster_caseID, !duplicated(id))

#Exclude stroma
cluster_dat = cluster_dat[!cluster %in% c(1:3,5,7,16,18,21,28,39,41),]

#Get fractions/percentages of cells by core/cluster
cluster_dat[, frac_cluster := ncells/sum(ncells), by=core]
cluster_dat[, frac_cells := ncells/sum(ncells), by=cluster]
cluster_dat[, perc_cluster := ncells*100/sum(ncells), by=core]
cluster_dat[, perc_cells := ncells*100/sum(ncells), by=cluster]

#Merge with metadata
cluster_dat = merge(cluster_dat, Sample_metadata[!is.na(Sample_metadata$area),], by = c('core'), all.x = TRUE, allow.cartesian=TRUE, rm.NA = TRUE)

#Calculate cell type densities per image
cluster_dat[,cell_density := ncells/area, by = 'core']

```

#Kick out normal, met and control in case not wanted for subsequent analyses, use metacluster labels from Basel
```{r}
cluster_dat_tumors <- cluster_dat[!is.na(cluster_dat$PID),]
cluster_dat_tumors <- cluster_dat_tumors[!cluster_dat_tumors$location == '[]',]
cluster_dat_tumors <- cluster_dat_tumors[!cluster_dat_tumors$location == "METASTASIS",]

#Use matched metacluster labels as cell types (so it is comparable to Basel TMA)
cluster_dat_tumors$cluster <- mapvalues(cluster_dat_tumors$cluster, from=cluster_match$zuri, to=cluster_match$Basel)

#If only interested in center cores
#cluster_dat_tumors <- cluster_dat_tumors[cluster_dat_tumors$location == "CENTER",]

```

#In case normal, met and control are kept, name them accordingly
```{r}
#Non existent patientcodes are control samples
cluster_dat$location[is.na(cluster_dat$PID)] <- 'CONTROL'
cluster_dat$PID[is.na(cluster_dat$PID)] <- 'CONTROL'
cluster_dat$grade[is.na(cluster_dat$grade)] <- 'CONTROL'

#Empty locations are normal samples, except for when they are met -> overwrite the mets
cluster_dat$grade[cluster_dat$location == '[]'] <- 'NORMAL'
cluster_dat$location[cluster_dat$location == '[]'] <- 'NORMAL'

cluster_dat[, cluster_by_area := ncells/area, by=c('core','cluster')]
cluster_dat = cluster_dat[!is.na(cluster_dat$cluster_by_area),]

#Exclude sample with no tumor core
cluster_dat = cluster_dat[cluster_dat$PID %in% cluster_dat_tumors$PID,]
```

#Distribution of cell types across center and periphery cores
```{r}
cluster_loc = cluster_dat[,c('cluster','core','ncells','location')]
cluster_loc = cluster_loc[!location %in% c('NORMAL','METASTASIS'),]
cluster_loc[,count := .N, by = c('cluster','location')]
cluster_loc[,frac_cluster := count/.N, by = 'cluster']
cluster_loc[,frac_location := count/.N, by = 'location']
cluster_loc = unique(cluster_loc[,c('cluster','location','frac_cluster')])

p <- ggplot(cluster_loc, aes(x=cluster, y=frac_cluster, fill=factor(location,levels = c('CENTER','PERIPHERY','NORMAL','METASTASIS')))) + 
  geom_bar(stat='identity',show.legend = TRUE)+
  scale_fill_manual("Clusters",values = c('red','blue','grey','black'))+ # rev(mycols)[!cluster_order %in% c(1,3:5,7:8,11,13,22,25:26,33:34)]
  labs(fill = "Location")+
  coord_flip()+
  xlab("loc")+
  ylab("Frac cluster")+
  theme(panel.background = element_blank(),
        axis.text.y = element_text(colour=rev(mycols)))+
  ggtitle('Location composition')

pdf('location.pdf')
p
dev.off()
```

#Patient clustering
```{r}
# Prepare for patient clustering based on fraction of contained cell type metacluster cells
cluster_dat_tumors <- subset(cluster_dat_tumors, by="PID")
cluster_dat_tumors[, tot_patient := sum(ncells), by=PID]
cluster_dat_tumors[, tot_location := sum(ncells), by=location]
cluster_dat_tumors[, tot_cell_area_patient := sum(unique(sum_area_cells)), by=PID]
cluster_dat_tumors[, tot_image_area_patient := sum(unique(area)), by=PID]
cluster_dat_tumors[, frac_cells_image_Area_patient := ncells/tot_image_area_patient, by=.(cluster)]
cluster_dat_tumors[, frac_cells_cell_Area_patient := ncells/tot_cell_area_patient, by=.(cluster)]
cluster_dat_tumors[, frac_cells_amount_cells_patient := ncells/tot_patient, by=.(cluster)]
cluster_dat_tumors[, tot_cell_area_image := sum_area_cells]
cluster_dat_tumors[, frac_cells_cell_Area_image := ncells/tot_cell_area_image, by=.(cluster)]
cluster_dat_tumors[, tot_cell_area_location := sum(unique(sum_area_cells)), by=location]
cluster_dat_tumors[, tot_image_area_location := sum(unique(area)), by=location]
cluster_dat_tumors[, cluster_by_area := ncells/area, by=c('core','cluster')]

#cluster_dat_tumors = cluster_dat_tumors[cluster_dat_tumors$cluster %in% c(1:11,21:22),]

patient_dat_vars <- unique(cluster_dat_tumors)
#check that sum adds up to 100% or 1 if fraction:
patient_dat_vars <- patient_dat_vars[,sum := sum(frac_cluster),by = .(core)]
patient_dat_vars <- patient_dat_vars[,sum := sum(frac_cells_amount_cells_patient),by = .(PID)]
patient_dat_vars <- cluster_dat_tumors[,c("PID","cluster","frac_cluster")] #replace frac with other norms
un_clusters <- unique(patient_dat_vars[,"cluster"])
un_clusters <- transform(un_clusters, cluster = as.character(cluster))
un_clusters <- unlist(un_clusters)
colnames(patient_dat_vars)<-c("PID","channel","value")
patient_dat_vars<-transform(patient_dat_vars, channel = as.character(channel))

# Hierarchical clustering on patients
patient_dat_vars = patient_dat_vars[order(PID)]
patient_wide = dcast.data.table(data =patient_dat_vars, formula = 'PID ~ channel',
                          value.var = 'value',fun.aggregate = mean,fill = 0)

dd <- dist(scale(patient_wide[,2:ncol(patient_wide)]), method = "euclidean")
hc <- hclust(dd, method = "ward.D2")

```

#Image clustering
```{r}
# Run hierclust on image's celltype fraction
image_dat_vars <- unique(cluster_dat_tumors) #cluster_dat for all images
grade <- unique(image_dat_vars[,c('core','grade')])
image_dat_vars <- image_dat_vars[,c("core","cluster","frac_cluster")]
un_clusters_im <- unique(image_dat_vars$cluster)
colnames(image_dat_vars)<-c("core","channel","value")
image_wide = dcast.data.table(data =image_dat_vars, formula = 'core ~ channel',
                          value.var = 'value',fun.aggregate = mean, fill = 0)
image_grade = merge(image_wide,grade, by = 'core')

dd_image <- dist(scale(image_wide[,2:ncol(image_wide)]), method = "euclidean")
hc_image <- hclust(dd_image, method = "ward.D2")

```

#Asign individual images from Zurich TMA to most similar SCP patient group from Basel TMA
```{r}
#Read in patient cell type composition from Basel TMA
basel_patients = fread('/home/ubuntu/tmp/server_homes/janaf/Data/2019/Data_publication/ZurichTMA/output_BaselTMA/patient_wide_basel.csv',header = T)
meta_patient_clustering = fread(file='/home/ubuntu/tmp/server_homes/janaf/Data/2019/Data_publication/ZurichTMA/output_BaselTMA/patient_groups_tumors_meta.csv', header = TRUE)

#Aggregate into mean cell type composition per SCP patient group
basel = merge(basel_patients,meta_patient_clustering, by = 'PID',all.x = T)
basel$patient_pheno[is.na(basel$patient_pheno)] = 18
group_means = lapply(unique(basel$patient_pheno),function(x){colMeans(basel[patient_pheno == x,-c('PID','patient_pheno')])})
group_means_t = data.table(matrix(unlist(group_means), ncol = length(group_means[[1]]), byrow = TRUE))
group_means_t$patient_pheno = unique(basel$patient_pheno)
names(group_means_t) = c(names(group_means[[1]]),'patient_pheno')

rnames = group_means_t$patient_pheno
basel_mat = as.matrix(group_means_t[,-'patient_pheno'])
rownames(basel_mat) = rnames

rnames = image_wide$core
zuri_mat = as.matrix(image_wide[,-'core'])
rownames(zuri_mat) = rnames

basel_mat = basel_mat[order(as.numeric(rownames(basel_mat))), ] 

crosscor = cor(t(basel_mat),t(zuri_mat))
idx_min = apply(crosscor,2,function(x){which(x == max(x))})
dist_min = apply(crosscor,2,max)
SCP_match = data.table(names(unlist(idx_min)))
colnames(SCP_match) = 'zuri'
SCP_match$basel = idx_min
names(SCP_match) = c('core','patient_pheno')

```

#Image clustering with stacked barplot, change grade to PID
```{r}
image_order <- unique(cluster_dat$core)[hc_image$order]
#Reorder the levels of legend
cluster_dat$cluster <- factor(cluster_dat$cluster,levels = cluster_order)
patient_im_orig = cluster_dat[,c('core','grade')]
patient_im_orig = unique(patient_im_orig)
#For bar
core_location <- cluster_dat[,c('core','location')]
core_location  <- unique(core_location)
location_order <- core_location[order(match(core_location$core,image_order))]
all_order = patient_im_orig[order(match(patient_im_orig$core,image_order))]
cluster_dat$cluster = factor(cluster_dat$cluster, levels = cluster_order)

p <- ggplot(cluster_dat, aes(x=core, y=cluster_by_area,  fill=cluster)) + 
  geom_bar(stat='identity')+
  scale_fill_manual("Clusters",values = rev(mycols))+
  scale_x_discrete(limits = all_order$core)+
  #facet_wrap(core~)+
  labs(fill = "Clusters")+
  coord_flip()+
  xlab("Patient images")+
  ylab("Percentage of cluster cells in image")+
  theme(panel.background = element_blank(),
    axis.text.y = element_text(colour=c('green','blue','red','lightblue','black')[factor(all_order$grade, levels = c('1','2','3','NORMAL','METASTASIS'))]))+
  ggtitle('Patient composition')

library("ggdendro")
p2 <- ggdendrogram(hc_image, rotate = TRUE,labels = FALSE, theme_dendro = TRUE, leaf_labels = FALSE)+
  theme(axis.title.x=element_blank(),
          axis.text.x=element_blank(),
          axis.ticks.x=element_blank(),
          axis.title.y=element_blank(),
          axis.text.y=element_blank(),
          axis.ticks.y=element_blank())

#Location
location_order$location = factor(location_order$location, levels = c('CENTER','PERIPHERY','NORMAL','METASTASIS'))
p3 <- ggplot(location_order, aes(x=1,y=c(1:length(location_order$location))))+
      geom_tile(aes( fill=location))+
  scale_fill_manual(values = c('red','blue','lightblue','black'))+
    theme(axis.title.x=element_blank(),
          axis.text.x=element_blank(),
          axis.ticks.x=element_blank(),
          axis.title.y=element_blank(),
          axis.text.y=element_blank(),
          axis.ticks.y=element_blank(),
          line = element_blank(),
          legend.position="none")

library("cowplot")
p4 <- ggdraw() +
     draw_plot(p2 + scale_y_reverse(), 0, 0.001, 0.43, 0.995) +
     draw_plot(p ,0.49, 0.04, 0.5, 0.915)+
     draw_plot(p3,0.45,0,0.047,0.998)


pdf(file="Image_clustering_zuri.pdf", width=40, height=100)
p4
dev.off()

```

#Patients clustering with stacked barplot of individual images, tumor images only, grouped by patient
```{r}
#If this should include stromal and immune cells don't exclude them above
cluster_dat_tumors = cluster_dat_tumors[!location %in% c("NORMAL","METASTASIS"),]
#cluster_dat_ordered_by_patient = cluster_dat_tumors[by=PID]
image_order = cluster_dat_ordered_by_patient[,c('PID','core')]
image_order = unique(image_order)
un_patients = unique(image_order$PID)
un_patients = un_patients[order(un_patients)]
o <- hc$order
all_order = image_order[order(match(image_order$PID,un_patients[o]))]

#cluster_dat_ordered_by_patient$cluster = factor(cluster_dat_ordered_by_patient$cluster, levels = rev(levels(cluster_dat_ordered_by_patient$cluster))) #for figure reverse 
p <- ggplot(cluster_dat_ordered_by_patient, aes(x=core, y=cell_density,  fill=cluster)) + 
  geom_bar(stat='identity')+
  scale_fill_manual("Clusters",values = mycols_basel_meta[as.numeric(levels(cluster_dat_ordered_by_patient$cluster))])+
  scale_x_discrete(limits = all_order$core)+
  #facet_wrap(core~)+
  labs(fill = "Clusters")+
  coord_flip()+
  xlab("Patient images")+
  ylab("Percentage of cluster cells in image")+
  theme(panel.background = element_blank(),
    axis.text.y = element_text(colour=c(col_vector,"#7FC97F",'black')[as.factor(all_order$PID)]))+
  ggtitle('Patient composition')

p2 <- ggdendro::ggdendrogram(hc, rotate = TRUE,labels = FALSE, theme_dendro = TRUE, leaf_labels = FALSE)+
  theme(axis.title.x=element_blank(),
          axis.text.x=element_blank(),
          axis.ticks.x=element_blank(),
          axis.title.y=element_blank(),
          axis.text.y=element_blank(),
          axis.ticks.y=element_blank())

#Clinical type bar
clinical_order = cluster_dat_ordered_by_patient[,c('clinical_type','PID','core')]
clinical_order = unique(clinical_order)
un_clin = unique(clinical_order$clinical_type)
all_clin_order = clinical_order[order(match(clinical_order$PID,un_patients[o]))]
all_clin_order$clinical_type = factor(all_clin_order$clinical_type, levels = c('HR-HER2+','HR+HER2-','HR+HER2+','TripleNeg'))#'NORMAL'
p3 <- ggplot(all_clin_order, aes(x=1,y=c(1:length(all_clin_order$clinical_type))))+
      geom_tile(aes( fill=clinical_type))+
  scale_fill_manual(values = c(mycols_clinical,'black'))+ #'lightblue',
    theme(axis.title.x=element_blank(),
          axis.text.x=element_blank(),
          axis.ticks.x=element_blank(),
          axis.title.y=element_blank(),
          axis.text.y=element_blank(),
          axis.ticks.y=element_blank(),
          line = element_blank(),
          legend.position="none")


#Location bar
location_order = cluster_dat_ordered_by_patient[,c('location','PID','core')]
location_order = unique(location_order)
un_loc = unique(location_order$location)
all_loc_order = location_order[order(match(location_order$PID,un_patients[o]))]
all_loc_order$location = factor(all_loc_order$location, levels = c('CENTER','PERIPHERY','METASTASIS','NORMAL'))#'NORMAL'
p3 <- ggplot(all_loc_order, aes(x=1,y=c(1:length(all_loc_order$location))))+
      geom_tile(aes( fill=location))+
  scale_fill_manual(values = c('red','blue','black','lightblue'))+ #'lightblue',
    theme(axis.title.x=element_blank(),
          axis.text.x=element_blank(),
          axis.ticks.x=element_blank(),
          axis.title.y=element_blank(),
          axis.text.y=element_blank(),
          axis.ticks.y=element_blank(),
          line = element_blank(),
          legend.position="none")



#SCP patient groups matched
all_pheno_order = SCP_match[order(match(SCP_match$core,all_order$core))]
all_pheno_order$patient_pheno = factor(all_pheno_order$patient_pheno)
p5 <- ggplot(all_pheno_order, aes(x=1,y=c(1:length(all_pheno_order$patient_pheno))))+
      geom_tile(aes( fill=patient_pheno))+
  scale_fill_manual(values = mycols_patient[as.numeric(levels(all_pheno_order$patient_pheno))])+ #'lightblue',
    theme(axis.title.x=element_blank(),
          axis.text.x=element_blank(),
          axis.ticks.x=element_blank(),
          axis.title.y=element_blank(),
          axis.text.y=element_blank(),
          axis.ticks.y=element_blank(),
          line = element_blank(),
          legend.position="none")


kldiv_ordered = data.table(names(unlist(kldiv)))
kldiv_ordered$kldiv = as.vector(unlist(kldiv))
names(kldiv_ordered)[1] = 'core'
kldiv_ordered$core = unlist(lapply(strsplit(kldiv_ordered$core,'[.]'), function(x){paste(x[3:4],collapse = '.')}))

add_normals = all_order$core[!all_order$core %in% kldiv_ordered$core]
kldiv_ordered = rbind(kldiv_ordered,data.frame(core = add_normals, kldiv = rep(NA,length(add_normals))))

kl_order = merge(cluster_dat_ordered_by_patient[,c('patientcode','core')],kldiv_ordered,by = 'core')
kl_order = unique(kl_order)
all_kl_order = kl_order[order(match(kl_order$patientcode,un_patients[o]))]

#Colorbar for kl div from tumor means
p4 <- ggplot(all_kl_order, aes(x=1,y=c(1:length(all_kl_order$kldiv))))+
      geom_tile(aes( fill=all_kl_order$kldiv))+
  scale_fill_gradient2(low = "blue", mid = "white", high = "red")+
    theme(axis.title.x=element_blank(),
          axis.text.x=element_blank(),
          axis.ticks.x=element_blank(),
          axis.title.y=element_blank(),
          axis.text.y=element_blank(),
          axis.ticks.y=element_blank(),
          line = element_blank(),
          legend.position="none")

#Shannon

shannon_core = merge(cluster_dat_ordered_by_patient[,c('patientcode','core')],shannon_core,by = 'core')
shannon_core = unique(shannon_core)
all_shannon_order = shannon_core[order(match(shannon_core$patientcode,un_patients[o]))]

p7 <- ggplot(all_shannon_order, aes(x=1,y=c(1:length(all_shannon_order$shannon))))+
      geom_tile(aes( fill=all_shannon_order$shannon))+
  scale_fill_gradient2(low = "blue", mid = "white", high = "purple")+
    theme(axis.title.x=element_blank(),
          axis.text.x=element_blank(),
          axis.ticks.x=element_blank(),
          axis.title.y=element_blank(),
          axis.text.y=element_blank(),
          axis.ticks.y=element_blank(),
          line = element_blank(),
          legend.position="none")


p6 <- ggdraw() +
     draw_plot(p2 + scale_y_reverse(), 0, 0.005, 0.36, 0.984) +
     draw_plot(p ,0.47, 0.035, 0.5, 0.926)+
   draw_plot(p3,0.45,0,0.05,1)+
  draw_plot(p4,0.42,0,0.05,1)+
  draw_plot(p7,0.39,0,0.05,1)+
  draw_plot(p5,0.36,0,0.05,1)

pdf(file="/home/jana/Desktop/R_dat/Image_KLdivs_perc_cluster.pdf", width=15, height=50)
#cowplot

p6

dev.off()


check = na.omit(unique(all_pheno_order[,c('image_pheno','patientcode')]))[by = patientcode]
check[,count := .N, by = 'patientcode']

```

#KL div per patient group
```{r}
kl_group = merge(all_kl_order,asigned,by = 'core')

p = ggplot(kl_group, aes(x = factor(cluster),y = kldiv))+
  geom_boxplot()+
  theme(axis.text.x = element_text(color = mycols_patient[sort(as.numeric(unique(kl_group$cluster)))]))


pdf(file="/home/jana/Desktop/R_dat/Zurich_asignedPatientgroup_KLdiv.pdf", width=10, height=10)


p

dev.off()

kl_group$cluster = factor(kl_group$cluster, levels = c(6,12,11,14,3,1,13,2,4,16,17,15,9,10,18,8,7) )
kl_group[,mean_kl := mean(kldiv),by = cluster]

cut = unique(kl_group[,c('mean_kl','cluster')])
cut = cut[order(cluster),]

p7 <- ggplot(cut, aes(x=1,y=1:length(mean_kl)))+
      geom_tile(aes( fill=mean_kl))+
  scale_fill_gradient2(low = "blue", mid = "white", high = "purple")+
  geom_text(aes(label=cluster))+
    theme(axis.title.x=element_blank(),
          axis.text.x = element_blank(),
          axis.ticks.x=element_blank(),
          axis.title.y=element_blank(),
          axis.text.y=element_blank(),
          axis.ticks.y=element_blank(),
          line = element_blank())


```

#23) Patient clustered stacked barplot, tumors only
```{r}


cluster_dat_tumors[, perc_cells_patient := ncells*100/sum(ncells), by=patientcode]
cluster_dat_tumors[, area_cells_patient := mean(cluster_by_area), by=c('patientcode','cluster')]
cluster_dat_tumors = cluster_dat_tumors[order(patientcode)]

#Grade colors
patient_grade_orig = cluster_dat_tumors[,c('patientcode','grade')]
patient_grade = unique(patient_grade_orig)
patient_grade = patient_grade[!duplicated(patient_grade$patientcode),]
patient_grade = patient_grade[order(patient_grade$patientcode),]
patient_grade_all = patient_grade[hc$order]

#Patient cluster colors
patient_cluster_orig = cluster_dat_tumors[,c('patientcode')]#,'patient_pheno'
patient_cluster = unique(patient_cluster_orig)
patient_Cluster = patient_cluster[!duplicated(patient_cluster$patientcode),]
patient_Cluster = patient_Cluster[order(patient_Cluster$patientcode),]
patient_cluster_all = patient_cluster[hc$order]


names(kldiv)[hc$order]
mean_kldiv_mat_tumors = mean_kldiv_mat_tumors[hc$order]
mean_kldiv_table =data.table(mean_kldiv_mat_tumors)

#Colorbar for kl div from tumor means
p3 <- ggplot(mean_kldiv_table, aes(x=1,y=c(1:length(mean_kldiv_table$mean_kldiv_mat))))+
      geom_tile(aes( fill=mean_kldiv_table$mean_kldiv_mat))+
   #scale_color_viridis()+
  scale_fill_gradient2(low = "blue", mid = "white", high = "red")+
    theme(axis.title.x=element_blank(),
          axis.text.x=element_blank(),
          axis.ticks.x=element_blank(),
          axis.title.y=element_blank(),
          axis.text.y=element_blank(),
          axis.ticks.y=element_blank(),
          line = element_blank(),
          legend.position="none")

#Colorbar for grade
p4 <- ggplot(patient_grade_all, aes(x=1,y=c(1:length(patient_grade_all$grade))))+
      geom_tile(aes( fill=factor(patient_grade_all$grade)))+
  scale_fill_manual(values = c('green','blue','red'))+
    theme(axis.title.x=element_blank(),
          axis.text.x=element_blank(),
          axis.ticks.x=element_blank(),
          axis.title.y=element_blank(),
          axis.text.y=element_blank(),
          axis.ticks.y=element_blank(),
          line = element_blank(),
          legend.position="none")

cut = cluster_dat_tumors[,c('patientcode','cluster','perc_cells_patient')]
cut = unique(cut)
#Staqcked bar plot
p <- ggplot(cut, aes(x=patientcode, y=perc_cells_patient, fill=as.factor(cluster))) + #
  geom_bar(stat='identity',show.legend = TRUE)+
  scale_fill_manual("Clusters",values = rev(mycols)[!cluster_order %in% c(1:3,5,7,15:16,18,21,28,39,41)])+ #[setdiff(1:length(mycols_zuri_basel_meta),c(1:24,26:28,34))]
  scale_x_discrete(limits = patient_cluster_all$patientcode)+
  labs(fill = "Clusters")+
  coord_flip()+
  xlab("Patient")+
  ylab("Percentage of cluster cells in patient")+
  theme(panel.background = element_blank())+
  ggtitle('Patient composition')

#cluster_dat_tumors[cluster_dat_tumors$cohort == 'Zuri',]


#Dendrogram of hierarchical clustering
p2 <- ggdendrogram(hc, rotate = TRUE,labels = TRUE, theme_dendro = TRUE, leaf_labels = FALSE)+
  theme(axis.title.x=element_blank(),
          axis.text.x=element_blank(),
          axis.ticks.x=element_blank(),
          axis.title.y=element_blank(),
          axis.text.y=element_blank(),
          axis.ticks.y=element_blank())

#Alignment is not same when printing to pdf, so don't pay attention to plot displayed in R
p4 <- ggdraw() +
     draw_plot(p2 + scale_y_reverse(), 0, 0.001, 0.48, 0.998) +
     draw_plot(p ,0.5, 0.0355, 0.5, 0.927)+
    draw_plot(p3,0.45,0.005,0.05,0.995)+
   draw_plot(p4,0.41,0.005,0.05,0.995)


pdf(file="/home/jana/Desktop/R_dat/patientmean_kldiv_percCluster.pdf", width=30, height=50)
#cowplot

p4

dev.off()

# tr = cbind(cluster_order,col_vector[as.factor(cluster_order)])
# tr = unique(tr)
# pdf(file="/home/jana/Desktop/R_dat/Legend.pdf", width=10, height=30)
# plot(1, type="n", axes=FALSE, xlab="", ylab="")
# legend(1, 1, legend = tr[,1], col=tr[,2], lwd=8, cex=3, xjust=0.5, yjust=0.5)
# dev.off()
# 
# #Potentially exclude patient clusters
# excl = patient_cluster_all[patient_cluster_all$patient_pheno %in% c(11,18),'patientcode']

```

#Saturation analysis tests
```{r}
#Sample cores
dat_cut_tumors <- cluster_dat_tumors[,c("core","cluster","perc_cluster","patientcode")]
one_patient = dat_cut_tumors[dat_cut_tumors$patientcode == 'B08.10992',]
un_core = unique(one_patient$core)
set.seed(2)
sampled = sample(un_core, 100, replace = TRUE, prob = NULL)

previous = data.table(
  cluster = factor(),
  previous_mean = numeric())
kldiv = list()

for (i in 1:length(sampled)){
  
  #Currently added image
  cur_core = sampled[[i]]
  cur_distribution = one_patient[one_patient$core == cur_core,]
  
  #Merge with previous distribution
  accumulated_distribution = merge(previous[,c('cluster','previous_mean')],cur_distribution[,c('cluster','perc_cluster')],by = 'cluster', all = TRUE)
    
  if (i == 1){
    #Set NAs to 0
    accumulated_distribution$previous_mean[is.na(accumulated_distribution$previous_mean)] = 0
    accumulated_distribution$perc_cluster[is.na(accumulated_distribution$perc_cluster)] = 0
  
    #tosum up to 100%
    accumulated_distribution$accumulated_mean = rowSums(accumulated_distribution[,c('previous_mean', 'perc_cluster')])}
  else{
    accumulated_distribution = na.omit(accumulated_distribution)
    
    #Calculate mean per cluster
    accumulated_distribution$accumulated_mean = rowMeans(accumulated_distribution[,c('previous_mean', 'perc_cluster')])
  }
  


  #Calculate KL
  kldiv[[i]] = KL.plugin(accumulated_distribution$previous_mean, accumulated_distribution$accumulated_mean)
  previous = accumulated_distribution[,c('cluster','accumulated_mean')]
    
  names(previous) = c('cluster','previous_mean')
}

KL = data.table(unlist(kldiv))
names(KL)[1] = 'kldiv'

ggplot(KL[2:nrow(KL),],aes(x = 1:length(kldiv),y = cumsum(kldiv)))+
  geom_point()


#Sample cells from pooled patient
dat_cut_tumors <- cluster_dat_tumors[,c("core","cluster","patientcode")]
one_patient = dat_cut_tumors[dat_cut_tumors$patientcode == 'B08.10992',]
one_patient = merge(one_patient,unique(merge(cluster_pheno,dat[,c('core','id')],by = 'id')),by = c('core','cluster'),all.x = TRUE)
un_cells = unique(one_patient$id)
set.seed(2)
#sampled = sample(un_cells, 100, replace = FALSE, prob = NULL)

subsamples = split(one_patient, sample(1:20, nrow(one_patient), replace=F))
subsamples=one_patient[sample(nrow(one_patient),replace=F,size=0.05*nrow(one_patient)),]

# one_patient    <- one_patient[order(runif(nrow(one_patient))), ]
# bins  <- rep(1:100, nrow(one_patient) / 100)
# subsamples = split(one_patient, bins)

previous = data.table(
  cluster = factor(),
  previous_mean = numeric())
kldiv = list()
shannon = list()

for (i in 1:500){
  #Currently added cells
  cur_core = one_patient[sample(nrow(one_patient),replace=F,size=0.5*nrow(one_patient)),]
  #cur_core = subsamples[[i]]
  cur_core[,ncells_cluster := .N , by = 'cluster']
  cur_core[,perc_cluster := ncells_cluster/.N]
  
  #Merge with previous distribution
  accumulated_distribution = merge(previous[,c('cluster','previous_mean')],unique(cur_core[,c('cluster','perc_cluster')]),by = 'cluster', all = TRUE)
  
  if (i == 1){
    #Set NAs to 0
    accumulated_distribution$previous_mean[is.na(accumulated_distribution$previous_mean)] = 0
    accumulated_distribution$perc_cluster[is.na(accumulated_distribution$perc_cluster)] = 0
  
    #tosum up to 100%
    accumulated_distribution$accumulated_mean = rowSums(accumulated_distribution[,c('previous_mean', 'perc_cluster')])}
  else{
    accumulated_distribution = na.omit(accumulated_distribution)
    
    #Calculate mean per cluster
    accumulated_distribution$accumulated_mean = rowMeans(accumulated_distribution[,c('previous_mean', 'perc_cluster')])
  }

  #Calculate KL
  kldiv[[i]] = KL.plugin(accumulated_distribution$previous_mean, accumulated_distribution$perc_cluster)
  shannon[[i]] = entropy.ChaoShen(accumulated_distribution$accumulated_mean)
  previous = accumulated_distribution[,c('cluster','accumulated_mean')]
    
  names(previous) = c('cluster','previous_mean')
}

KL = data.table(unlist(kldiv))
names(KL)[1] = 'kldiv'

ggplot(KL[2:nrow(KL),],aes(x = 1:length(kldiv),y = cumsum(kldiv)))+
  geom_point()



#All cells vs less cells
previous = data.table(
  cluster = factor(),
  previous_mean = numeric())
kldiv = list()
shannon = list()

range = seq(from = 1, to = (1/100), by = -(1/100))
first = one_patient[sample(nrow(one_patient),replace=F,size=1*nrow(one_patient)),]
first[,ncells_cluster := .N , by = 'cluster']
first[,perc_cluster_first := ncells_cluster/.N]

for (i in 1:length(range)){
  cur = range[[i]]
  #Currently added cells
  cur_core = one_patient[sample(nrow(one_patient),replace=F,size=cur*nrow(one_patient)),]
  #cur_core = subsamples[[i]]
  cur_core[,ncells_cluster := .N , by = 'cluster']
  cur_core[,perc_cluster := ncells_cluster/.N]

  
  # #Merge with previous distribution
  # accumulated_distribution = merge(previous[,c('cluster','previous_mean')],unique(cur_core[,c('cluster','perc_cluster')]),by = 'cluster', all = TRUE)
  # 
  accumulated_distribution = merge(unique(first[,c('cluster','perc_cluster_first')]),unique(cur_core[,c('cluster','perc_cluster')]),by = 'cluster', all = TRUE)
  # 
  # if (i == 1){
  #   #Set NAs to 0
  #   accumulated_distribution$previous_mean[is.na(accumulated_distribution$previous_mean)] = 0
  #   accumulated_distribution$perc_cluster[is.na(accumulated_distribution$perc_cluster)] = 0
  # 
  #   #tosum up to 100%
  #   accumulated_distribution$accumulated_mean = rowSums(accumulated_distribution[,c('previous_mean', 'perc_cluster')])}
  # else{
    accumulated_distribution = na.omit(accumulated_distribution)
    
    # #Calculate mean per cluster
    # accumulated_distribution$accumulated_mean = rowMeans(accumulated_distribution[,c('previous_mean', 'perc_cluster')])
  # }

  #Calculate KL
  kldiv[[i]] = KL.plugin(accumulated_distribution$perc_cluster_first, accumulated_distribution$perc_cluster)
  shannon[[i]] = entropy.ChaoShen(accumulated_distribution$perc_cluster)
  previous = accumulated_distribution[,c('cluster','perc_cluster')]
    
  names(previous) = c('cluster','previous_mean')
}

KL = data.table(unlist(kldiv))
names(KL)[1] = 'kldiv'

ggplot(KL[2:nrow(KL),],aes(x = 1:length(kldiv),y = cumsum(kldiv)))+
  geom_point()



#Small fraction to all (increasing size)
previous = data.table(
  cluster = factor(),
  previous_mean = numeric())
kldiv = list()
shannon = list()

range = rev(seq(from = 1, to = (1/100), by = -(1/100)))
first = one_patient[sample(nrow(one_patient),replace=F,size=1*nrow(one_patient)),]
first[,ncells_cluster := .N , by = 'cluster']
first[,perc_cluster_first := ncells_cluster/.N]

for (i in 1:length(range)){
  cur = range[[i]]
  #Currently added cells
  cur_core = one_patient[sample(nrow(one_patient),replace=F,size=cur*nrow(one_patient)),]
  #cur_core = subsamples[[i]]
  cur_core[,ncells_cluster := .N , by = 'cluster']
  cur_core[,perc_cluster := ncells_cluster/.N]

  
  # #Merge with previous distribution
  # accumulated_distribution = merge(previous[,c('cluster','previous_mean')],unique(cur_core[,c('cluster','perc_cluster')]),by = 'cluster', all = TRUE)
  # 
  accumulated_distribution = merge(unique(first[,c('cluster','perc_cluster_first')]),unique(cur_core[,c('cluster','perc_cluster')]),by = 'cluster', all = TRUE)
  # 
  # if (i == 1){
  #   #Set NAs to 0
  #   accumulated_distribution$previous_mean[is.na(accumulated_distribution$previous_mean)] = 0
  #   accumulated_distribution$perc_cluster[is.na(accumulated_distribution$perc_cluster)] = 0
  # 
  #   #tosum up to 100%
  #   accumulated_distribution$accumulated_mean = rowSums(accumulated_distribution[,c('previous_mean', 'perc_cluster')])}
  # else{
    accumulated_distribution = na.omit(accumulated_distribution)
    
    # #Calculate mean per cluster
    # accumulated_distribution$accumulated_mean = rowMeans(accumulated_distribution[,c('previous_mean', 'perc_cluster')])
  # }

  #Calculate KL
  kldiv[[i]] = KL.plugin(accumulated_distribution$perc_cluster_first, accumulated_distribution$perc_cluster)
  shannon[[i]] = entropy.ChaoShen(accumulated_distribution$perc_cluster)
  previous = accumulated_distribution[,c('cluster','perc_cluster')]
    
  names(previous) = c('cluster','previous_mean')
}

KL = data.table(unlist(kldiv))
names(KL)[1] = 'kldiv'

ggplot(KL[2:nrow(KL),],aes(x = 1:length(kldiv),y = cumsum(kldiv)))+
  geom_point()



#Small fraction to larger (increasing size)
previous = data.table(
  cluster = factor(),
  previous_mean = numeric())
kldiv = list()
shannon = list()

range = rev(seq(from = 1, to = (1/100), by = -(1/100)))


for (i in 1:length(range)){
  cur = range[[i]]
  #Currently added cells
  cur_core = one_patient[sample(nrow(one_patient),replace=F,size=cur*nrow(one_patient)),]
  #cur_core = subsamples[[i]]
  cur_core[,ncells_cluster := .N , by = 'cluster']
  cur_core[,perc_cluster := ncells_cluster/.N]


  #Merge with previous distribution
  accumulated_distribution = merge(previous[,c('cluster','previous_mean')],unique(cur_core[,c('cluster','perc_cluster')]),by = 'cluster', all = TRUE)

  

  if (i == 1){
    #Set NAs to 0
    accumulated_distribution$previous_mean[is.na(accumulated_distribution$previous_mean)] = 0
    accumulated_distribution$perc_cluster[is.na(accumulated_distribution$perc_cluster)] = 0

    #tosum up to 100%
    accumulated_distribution$accumulated_mean = rowSums(accumulated_distribution[,c('previous_mean', 'perc_cluster')])}
  else{
   accumulated_distribution = na.omit(accumulated_distribution)

  #Calculate mean per cluster
  accumulated_distribution$accumulated_mean = rowMeans(accumulated_distribution[,c('previous_mean', 'perc_cluster')])
  }

  #Calculate KL
  kldiv[[i]] = KL.plugin(accumulated_distribution$previous, accumulated_distribution$perc_cluster)
  shannon[[i]] = entropy.ChaoShen(accumulated_distribution$perc_cluster)
  previous = accumulated_distribution[,c('cluster','perc_cluster')]
    
  names(previous) = c('cluster','previous_mean')
}

KL = data.table(unlist(kldiv))
names(KL)[1] = 'kldiv'

ggplot(KL[2:nrow(KL),],aes(x = 1:length(kldiv),y = cumsum(kldiv)))+
  geom_point()


```
#Not means but treat as one sample
```{r}
#Sample cells from pooled patient
dat_cut_tumors <- cluster_dat_tumors[,c("core","cluster","patientcode")]
one_patient = dat_cut_tumors[dat_cut_tumors$patientcode == 'B09.40012',]
one_patient = merge(one_patient,unique(merge(cluster_pheno,dat[,c('core','id')],by = 'id')),by = c('core','cluster'),all.x = TRUE)
un_cells = unique(one_patient$id)
#set.seed(2)
#sampled = sample(un_cells, 100, replace = FALSE, prob = NULL)

subsamples = split(one_patient, sample(1:100, nrow(one_patient), replace=T))


previous = data.table(
  sample = numeric(),
  cluster = factor(),
  id = character(),
  perc_cluster = numeric())
kldiv = list()
shannon = list()

for (i in 1:length(subsamples)){
  #Currently added cells
  cur_core = subsamples[[i]]
  cur_core[,sample:= unlist(rep(i,nrow(cur_core)))]
  
  #Merge with previous distribution
  accumulated_distribution = rbind(unique(previous[,c('sample','cluster','id')]),unique(cur_core[,c('sample','cluster','id')]))
  accumulated_distribution[,ncells_cluster := .N , by = 'cluster']
  accumulated_distribution[,perc_cluster := ncells_cluster/.N]
  
  to_test = merge(unique(previous[,c('cluster','perc_cluster')]),unique(accumulated_distribution[,c('cluster','perc_cluster')]),by = 'cluster',all = TRUE)
  

  # to_test$previous_mean[is.na(to_test$perc_cluster.x)] = 0
  # to_test$perc_cluster[is.na(to_test$perc_cluster.y)] = 0

  to_test = na.omit(to_test)


  #Calculate KL
  kldiv[[i]] = KL.plugin(to_test$perc_cluster.x, to_test$perc_cluster.y)

  previous = accumulated_distribution[,c('sample','cluster','perc_cluster','id')]
    
}

KL = data.table(unlist(kldiv))
names(KL)[1] = 'kldiv'

ggplot(KL[2:nrow(KL),],aes(x = 1:length(kldiv),y = cumsum(kldiv)))+
  geom_point()



#Sample cores
dat_cut_tumors <- cluster_dat_tumors[,c("core","cluster","patientcode")]
one_patient = dat_cut_tumors[dat_cut_tumors$patientcode == 'B09.40012',]
one_patient = merge(one_patient,unique(merge(cluster_pheno,dat[,c('core','id')],by = 'id')),by = c('core','cluster'),all.x = TRUE)
un_core = unique(one_patient$core)
#set.seed(2)
sampled = sample(un_core, 50, replace = TRUE, prob = NULL)

previous = data.table(
  sample = numeric(),
  core = character(),
  cluster = factor(),
  id = character(),
  perc_cluster = numeric())
kldiv = list()
shannon = list()

for (i in 1:length(sampled)){
  #Currently added cells
  cur = sampled[[i]]
  cur_core = one_patient[one_patient$core == cur,]
  cur_core[,sample:= unlist(rep(i,nrow(cur_core)))]
  
  #Merge with previous distribution
  accumulated_distribution = rbind(unique(previous[,c('sample','core','cluster','id')]),unique(cur_core[,c('sample','core','cluster','id')]))
  accumulated_distribution[,ncells_cluster := .N , by = 'cluster']
  accumulated_distribution[,perc_cluster := ncells_cluster/.N]
  
  to_test = merge(unique(previous[,c('cluster','perc_cluster')]),unique(accumulated_distribution[,c('cluster','perc_cluster')]),by = 'cluster',all = TRUE)
  

  # to_test$previous_mean[is.na(to_test$perc_cluster.x)] = 0
  # to_test$perc_cluster[is.na(to_test$perc_cluster.y)] = 0

  to_test = na.omit(to_test)


  #Calculate KL
  kldiv[[i]] = KL.plugin(to_test$perc_cluster.x, to_test$perc_cluster.y)

  previous = accumulated_distribution[,c('sample','core','cluster','perc_cluster','id')]
    
}

KL = data.table(unlist(kldiv))
names(KL)[1] = 'kldiv'

ggplot(KL[2:nrow(KL),],aes(x = 1:length(kldiv),y = cumsum(kldiv)))+
  geom_point()

```

#22) Compute KL divergence for patients clustering with tumors only mean
Whatch out whether want to use ncells or perc_cluster or cluster_by_area!!
```{r}

# all_perms = Permn(levels(dat_cut_tumors$cluster),length(levels(dat_cut_tumors$cluster)))
# all_perms =permutations(n=40,r=40,v=levels(dat_cut_tumors$cluster),repeats.allowed=F)
# all_perms = allPerms(levels(dat_cut_tumors$cluster), control = how(), check = TRUE)
# 
# for (i in all_perms)


#KL divergence per patient

#Tumors mean
dat_cut_tumors <- cluster_dat_tumors[,c("core","cluster","perc_cluster","patientcode")]

#Make missing cells types 0
dat_cut_tumors_wide = dcast.data.table(dat_cut_tumors,formula = 'patientcode + core ~ cluster',value.var = 'perc_cluster',fill = 0)
dat_cut_tumors_long = melt.data.table(dat_cut_tumors_wide, id.vars = c('patientcode','core') ,variable.name = 'cluster', value.name = 'perc_cluster')

#split into patients
ind_patients <- split( dat_cut_tumors_long , f = dat_cut_tumors_long$patientcode )
all_patient = lapply(ind_patients, function(x){x[order(x$core),]})
all_patient_tumors = lapply(all_patient,function(x){x[, patient_mean := mean(perc_cluster), by=cluster]})
ind_cores_tumors <- lapply(all_patient_tumors, function(x){split( x , f = x$core )})

library("entropy")
kldiv <- lapply(ind_cores_tumors, function(x){lapply(x,function(y){KL.plugin(y$perc_cluster, na.omit(y$patient_mean))})})
sum_kldiv <- lapply(kldiv,function(x){Reduce("+",x)})
length_kldiv <- lapply(kldiv,function(x){length(x)})
mean_kldiv_mat_tumors <- unlist(t(sum_kldiv))/unlist(t(length_kldiv))
sum_kldiv_mat_tumors <- unlist(t(sum_kldiv))


#Shannon entropy per core
dat_cut_tumors <- unique(cluster_dat_tumors[,c("core","cluster","ncells")])

#split into cores
ind_cores <- split( dat_cut_tumors , f = dat_cut_tumors$core )

shannon_cores = lapply(ind_cores, function(x){entropy.ChaoShen(x$ncells)})

shannon_core = data.table(unlist(names(shannon_cores)))
names(shannon_core) = "core"
shannon_core$shannon = unlist(shannon_cores)




#Grade

kldiv_ordered = data.table(names(unlist(kldiv)))
kldiv_ordered$kldiv = as.vector(unlist(kldiv))
names(kldiv_ordered)[1] = 'core'
kldiv_ordered$core = unlist(lapply(strsplit(kldiv_ordered$core,'[.]'), function(x){paste(x[3:4],collapse = '.')}))
kldiv_ordered = merge(kldiv_ordered, Sample_metadata, by = 'core')
kldiv_ordered[,meanKL := mean(kldiv),by = 'patientcode']
kldiv_ordered = unique(kldiv_ordered[,c('patientcode','meanKL','grade')])

p <- ggplot(kldiv_ordered, aes(x=factor(grade), y=meanKL)) + 
  geom_boxplot()+
  geom_point(size=2, alpha=1)+
  #stat_summary( fun.y = "mean",geom="point",colour = "black", size = 5)+
  #stat_summary(aes(group=grade), fun.y=mean, geom="line", colour="green")+
  ylab("Mean KL divergence of patient")+
  xlab("Grade")+
  theme(panel.background = element_blank())+
  ggtitle('Patients')


#PTNM_M/PTNM_N

kldiv_ordered = data.table(names(unlist(kldiv)))
kldiv_ordered$kldiv = as.vector(unlist(kldiv))
names(kldiv_ordered)[1] = 'core'
kldiv_ordered$core = unlist(lapply(strsplit(kldiv_ordered$core,'[.]'), function(x){paste(x[3:4],collapse = '.')}))
kldiv_ordered = merge(kldiv_ordered, Sample_metadata, by = 'core')
kldiv_ordered[,meanKL := mean(kldiv),by = 'patientcode']
kldiv_ordered = unique(kldiv_ordered[,c('patientcode','meanKL','PTNM_N')])


p <- ggplot(kldiv_ordered, aes(x=factor(PTNM_N), y=meanKL)) + 
  geom_boxplot()+
  geom_point(size=2, alpha=1)+
  #stat_summary( fun.y = "mean",geom="point",colour = "black", size = 5)+
  #stat_summary(aes(group=grade), fun.y=mean, geom="line", colour="green")+
  ylab("Mean KL divergence of patient")+
  xlab("PTNM_N")+
  theme(panel.background = element_blank())+
  ggtitle('PTNM_N')

pdf('/home/jana/Desktop/R_dat/CoreKLdiv_to_patientMean_perNodestatus.pdf',width = 30, height = 10)
p
dev.off()


#Type

kldiv_ordered = data.table(names(unlist(kldiv)))
kldiv_ordered$kldiv = as.vector(unlist(kldiv))
names(kldiv_ordered)[1] = 'core'
kldiv_ordered$core = unlist(lapply(strsplit(kldiv_ordered$core,'[.]'), function(x){paste(x[3:4],collapse = '.')}))
kldiv_ordered = merge(kldiv_ordered, Sample_metadata, by = 'core')
kldiv_ordered[,meanKL := mean(kldiv),by = 'patientcode']
kldiv_ordered = unique(kldiv_ordered[,c('patientcode','meanKL','tumor_type')])


p <- ggplot(kldiv_ordered, aes(x=factor(tumor_type), y=meanKL)) + 
  geom_boxplot()+
  geom_point(size=2, alpha=1)+
  #stat_summary( fun.y = "mean",geom="point",colour = "black", size = 5)+
  #stat_summary(aes(group=grade), fun.y=mean, geom="line", colour="green")+
  ylab("Mean KL divergence of patient")+
  xlab("PTNM_M")+
  theme(panel.background = element_blank())+
  ggtitle('PTNM_M')

pdf('/home/jana/Desktop/R_dat/CoreKLdiv_to_patientMean_perType.pdf',width = 30, height = 10)
p
dev.off()


#Size/age

kldiv_ordered = data.table(names(unlist(kldiv)))
kldiv_ordered$kldiv = as.vector(unlist(kldiv))
names(kldiv_ordered)[1] = 'core'
kldiv_ordered$core = unlist(lapply(strsplit(kldiv_ordered$core,'[.]'), function(x){paste(x[3:4],collapse = '.')}))
kldiv_ordered = merge(kldiv_ordered, Sample_metadata, by = 'core')
kldiv_ordered[,meanKL := mean(kldiv),by = 'patientcode']
kldiv_ordered = unique(kldiv_ordered[,c('patientcode','meanKL','age')])


p <- ggplot(kldiv_ordered, aes(x=age, y=meanKL)) + 
  geom_point()+
  geom_smooth()+
  geom_point(size=2, alpha=1)+
  #stat_summary( fun.y = "mean",geom="point",colour = "black", size = 5)+
  #stat_summary(aes(group=grade), fun.y=mean, geom="line", colour="green")+
  ylab("Mean KL divergence of patient")+
  xlab("age")+
  theme(panel.background = element_blank())+
  ggtitle('age')

pdf('/home/jana/Desktop/R_dat/CoreKLdiv_to_patientMean_perMetstatus.pdf',width = 30, height = 10)
p
dev.off()




# #TNBC
# names(asigned)[2] = 'cluster'
# names(asigned)[1] = 'core'
# TNBC = merge(asigned[cluster %in% 14:17,],unique(Sample_metadata[,c('patientcode','core')]),by = 'core')
# TNBC = unique(TNBC$patientcode)
# kldiv_ordered$type[kldiv_ordered$patientcode %in% TNBC] = 'TNBC'
# Basal = merge(asigned[cluster %in% 13,],unique(Sample_metadata[,c('patientcode','core')]),by = 'core')
# Basal = unique(Basal$patientcode)
# kldiv_ordered$type[kldiv_ordered$patientcode %in% Basal] = 'Basal'
# CK7 = merge(asigned[cluster %in% 11:12,],unique(Sample_metadata[,c('patientcode','core')]),by = 'core')
# CK7 = unique(CK7$patientcode)
# kldiv_ordered$type[kldiv_ordered$patientcode %in% CK7] = 'CK7'
# CK7 = merge(asigned[cluster %in% 11:12,],unique(Sample_metadata[,c('patientcode','core')]),by = 'core')
# CK7 = unique(CK7$patientcode)
# kldiv_ordered$type[kldiv_ordered$patientcode %in% CK7] = 'CK7'


#Patientgroups

kldiv_ordered = data.table(names(unlist(kldiv)))
kldiv_ordered$kldiv = as.vector(unlist(kldiv))
names(kldiv_ordered)[1] = 'core'
kldiv_ordered$core = unlist(lapply(strsplit(kldiv_ordered$core,'[.]'), function(x){paste(x[3:4],collapse = '.')}))
kldiv_ordered = merge(kldiv_ordered,asigned, by = 'core')


p <- ggplot(kldiv_ordered, aes(x=factor(cluster), y=kldiv)) + 
  geom_boxplot()+
  geom_point(size=2, alpha=1)+
  #stat_summary( fun.y = "mean",geom="point",colour = "black", size = 5)+
  #stat_summary(aes(group=grade), fun.y=mean, geom="line", colour="green")+
  ylab("KL div to patietn average of core")+
  xlab("Patientgroup")+
  theme(panel.background = element_blank())+
  ggtitle('Cores assigned to patient group')

pdf('/home/jana/Desktop/R_dat/CoreKLdiv_to_patientMean_perAssignedPatientgroup.pdf')
p
dev.off()


#mArc groups

kldiv_ordered = data.table(names(unlist(kldiv)))
kldiv_ordered$kldiv = as.vector(unlist(kldiv))
names(kldiv_ordered)[1] = 'core'
kldiv_ordered$core = unlist(lapply(strsplit(kldiv_ordered$core,'[.]'), function(x){paste(x[3:4],collapse = '.')}))
kldiv_ordered = merge(kldiv_ordered,neighb_clusters, by = 'core')


p <- ggplot(kldiv_ordered, aes(x=factor(cluster), y=kldiv)) + 
  geom_boxplot()+
  geom_point(size=2, alpha=1)+
  #stat_summary( fun.y = "mean",geom="point",colour = "black", size = 5)+
  #stat_summary(aes(group=grade), fun.y=mean, geom="line", colour="green")+
  ylab("KL div to patietn average of core")+
  xlab("mArc")+
  theme(panel.background = element_blank())+
  ggtitle('Cores mArc')

pdf('/home/jana/Desktop/R_dat/CoreKLdiv_to_patientMean_mArc.pdf')
p
dev.off()





#Shannon per patient grade/PTNM_M/PTNM_N
dat_cut_tumors <- cluster_dat_tumors[,c("core","cluster","ncells","patientcode")]

ind_patients <- split( dat_cut_tumors , f = dat_cut_tumors$patientcode )
all_patient = lapply(ind_patients, function(x){x[order(x$core),]})
ind_cores_tumors <- lapply(all_patient, function(x){split( x , f = x$core )})

shannon_patients = lapply(ind_cores_tumors, function(y){lapply(y, function(x){entropy.ChaoShen(x$ncells)})})
sum_shannon <- lapply(shannon_patients,function(x){Reduce("+",x)})
length_shannon <- lapply(shannon_patients,function(x){length(x)})
mean_shannon_patient <- unlist(t(sum_shannon))/unlist(t(length_shannon))

shannon_patient = data.table(unlist(names(ind_cores_tumors)))
names(shannon_patient) = "patientcode"
shannon_patient$shannon = mean_shannon_patient
shannon_patient = merge(shannon_patient, unique(Sample_metadata[,c('patientcode','PTNM_N')]),by = 'patientcode')
shannon_patient = shannon_patient[PTNM_N != 'METASTASIS']


p <- ggplot(shannon_patient, aes(x=factor(PTNM_N), y=shannon)) + 
  geom_boxplot()+
  geom_point(size=2, alpha=1)+
  #stat_summary( fun.y = "mean",geom="point",colour = "black", size = 5)+
  #stat_summary(aes(group=grade), fun.y=mean, geom="line", colour="green")+
  ylab("KL div to patietn average of core")+
  xlab("mArc")+
  theme(panel.background = element_blank())+
  ggtitle('Cores mArc')

pdf('/home/jana/Desktop/R_dat/CoreKLdiv_to_patientMean_mArc.pdf')
p
dev.off()


#Shannon per patientgroup/ mArc

ind_patients <- split( dat_cut_tumors , f = dat_cut_tumors$patientcode )
all_patient = lapply(ind_patients, function(x){x[order(x$core),]})
ind_cores_tumors <- lapply(all_patient, function(x){split( x , f = x$core )})

shannon_patients = lapply(ind_cores_tumors, function(y){lapply(y, function(x){entropy.ChaoShen(x$ncells)})})
sum_shannon <- lapply(shannon_patients,function(x){Reduce("+",x)})
length_shannon <- lapply(shannon_patients,function(x){length(x)})
mean_shannon_patient <- unlist(t(sum_shannon))/unlist(t(length_shannon))

shannon_patient = data.table(names(unlist(shannon_patients)))
names(shannon_patient) = "core"
shannon_patient$core = unlist(lapply(strsplit(shannon_patient$core,'[.]'), function(x){paste(x[3:4],collapse = '.')}))
shannon_patient$core = unique(shannon_patient$core)
shannon_patient$shannon = as.vector(unlist(shannon_patients))
shannon_patient = merge(shannon_patient, asigned,by = 'core')


p <- ggplot(shannon_patient, aes(x=factor(cluster), y=shannon)) + 
  geom_boxplot()+
  geom_point(size=2, alpha=1)+
  #stat_summary( fun.y = "mean",geom="point",colour = "black", size = 5)+
  #stat_summary(aes(group=grade), fun.y=mean, geom="line", colour="green")+
  ylab("Shannonentropy of core")+
  xlab("mArc")+
  theme(panel.background = element_blank())+
  ggtitle('Cores Shannon')

pdf('/home/jana/Desktop/R_dat/CoreShannon_Patientgroup_zurich.pdf')
p
dev.off()





##################################

#Chisq or Kolmogorov-Smirnof

dat_cut_tumors = cluster_dat_tumors[,c('core','cluster','ncells','patientcode')]

dat_cut_tumors_wide = dcast.data.table(dat_cut_tumors,formula = 'patientcode + core ~ cluster',value.var = 'ncells',fill = 0)
dat_cut_tumors_long = melt.data.table(dat_cut_tumors_wide, id.vars = c('patientcode','core') ,variable.name = 'cluster', value.name = 'ncells')

#split into patients
ind_patients <- split( dat_cut_tumors_long , f = dat_cut_tumors_long$patientcode )
all_patient = lapply(ind_patients, function(x){x[order(x$core),]})
all_patient_tumors = lapply(all_patient,function(x){x[, patient_mean := sum(ncells), by=cluster]})
ind_cores_tumors <- lapply(all_patient_tumors, function(x){split( x , f = x$core )})



cur = all_patient_tumors[[2]]
cur = cur[cur$patient_mean != 0,]
cur_images = split( cur , f = cur$core )

dgof::ks.test(cur_images[[1]]$perc_cluster, cur_images[[3]]$perc_cluster,simulate.p.value = T)


# 
test = cbind(cur_images[[1]]$ncells,cur_images[[3]]$ncells)
test = test[which(rowSums(test) > 0),] 
a = chisq.test(test, simulate.p.value = T)





#######################################
#Tumors only for patients clustering
grade_patient = cluster_dat_tumors [,c("grade","patientcode")]
grade_patient = grade_patient[order(patientcode)]
grade_patient = unique(grade_patient)
# grade_patient$meanKLdiv = data.frame(mean_kldiv_mat_tumors)
# grade_patient = grade_patient[!duplicated(grade_patient$patientcode),]
grade_patient$meanKLdiv[grade_patient$patientcode %in% names(sum_kldiv)] = mean_kldiv_mat_tumors[names(sum_kldiv) %in% grade_patient$patientcode]
grade_patient$meanShannon[grade_patient$patientcode %in% names(sum_shannon)] = mean_shannon_mat_tumors[names(sum_shannon) %in% grade_patient$patientcode]
#double check actual mean
ones <- grade_patient[grade_patient$grade == 1,]
threes <- grade_patient[grade_patient$grade == 3,]

p <- ggplot(grade_patient,aes(as.factor(grade), meanKLdiv))+
geom_boxplot()
pdf(file="/home/jana/Desktop/R_dat/KLdiv_grades_intrapatient.pdf", width=10, height=10)
p
dev.off()
# T-tests
y[grade_patient$grade == 2] = 1
y[grade_patient$grade == 3] = 0
y = y[!grade_patient$grade == 1]
x = grade_patient$meanKLdiv[!grade_patient$grade == 1]
t.test(x~as.factor(y))

shannon_patients = lapply(ind_cores_tumors, function(y){lapply(y, function(x){entropy.ChaoShen(x$cluster_by_area)})})
sum_shannon <- lapply(shannon_patients,function(x){Reduce("+",x)})
length_shannon <- lapply(shannon_patients,function(x){length(x)})
mean_shannon_mat_tumors <- unlist(t(sum_shannon))/unlist(t(length_shannon))
grade_patient$meanShannon = data.frame(mean_shannon_mat_tumors)

p <- ggplot(grade_patient, aes(x=factor(grade), y=meanKLdiv, fill=meanShannon)) + 
  geom_boxplot()+
  geom_point(size=2, alpha=1,aes(color=meanShannon))+
  scale_color_viridis(option="magma")+
  #stat_summary( fun.y = "mean",geom="point",colour = "black", size = 5)+
  #stat_summary(aes(group=grade), fun.y=mean, geom="line", colour="green")+
  ylab("Mean KL divergence of patient")+
  xlab("Grade")+
  theme(panel.background = element_blank())+
  ggtitle('Patients')
  

pdf(file="/home/jana/Desktop/R_dat/KL_shannonArea_grade.pdf", width=10, height=10)
p
dev.off()

p <- ggplot(grade_patient, aes(x=meanShannon, y=meanKLdiv, fill=factor(grade))) + 
  geom_point(size=2, alpha=1,aes(color=col_vector[factor(grade)]))+
  geom_smooth(method=lm)
pdf(file="/home/jana/Desktop/R_dat/KL_vs_shannon.pdf", width=10, height=10)
p
dev.off()

p <- ggplot(grade_patient, aes(x=meanShannon, y=meanKLdiv)) + 
  geom_point(size=2, alpha=1)+
  geom_smooth(method=lm)

p1 = ggplot(grade_patient, aes(x = meanShannon)) + #, color = as.factor(grade)
  geom_density()



size_patient = cluster_dat_tumors [,c("tumor_size","patientcode")]
size_patient = size_patient[order(patientcode)]
size_patient = unique(size_patient)
size_patient =size_patient[!is.na(size_patient$tumor_size),]
size_patient =size_patient[!size_patient$tumor_size == 0,]
# size_patient[!which(str_detect(size_patient$patientcode,"B08.44927"))[1],]
size_patient$meanKLdiv[size_patient$patientcode %in% names(sum_kldiv)] = mean_kldiv_mat_tumors[names(sum_kldiv) %in% size_patient$patientcode]
size_patient$meanShannon[size_patient$patientcode %in% names(sum_shannon)] = mean_shannon_mat_tumors[names(sum_shannon) %in% size_patient$patientcode]

p2 <-ggplot(size_patient,aes(x = tumor_size,y=meanKLdiv,fill = meanShannon))+
  geom_point(size=2, alpha=1,aes(color=meanShannon))+
  scale_color_viridis(option="magma")+
  geom_smooth(method=lm)
pdf(file="/home/jana/Desktop/R_dat/KLdiv_tumor_size_shannon.pdf", width=10, height=10)
p2
dev.off()

p <- ggplot(size_patient, aes(x=meanShannon, y=meanKLdiv, fill=tumor_size)) + 
  geom_point(size=2, alpha=1,aes(color=tumor_size))+
  scale_color_viridis(option="magma")+
  geom_smooth(method=lm)
pdf(file="/home/jana/Desktop/R_dat/KL_vs_shannon.pdf", width=10, height=10)
p
dev.off()


PTNM_M_patient = cluster_dat_tumors[,c("Subtype","patientcode")]
PTNM_M_patient = PTNM_M_patient[order(patientcode)]
PTNM_M_patient = unique(PTNM_M_patient)
PTNM_M_patient$meanKLdiv[PTNM_M_patient$patientcode %in% names(sum_kldiv)] = mean_kldiv_mat_tumors[names(sum_kldiv) %in% PTNM_M_patient$patientcode]
PTNM_M_patient$meanShannon[PTNM_M_patient$patientcode %in% names(sum_shannon)] = mean_shannon_mat_tumors[names(sum_shannon) %in% PTNM_M_patient$patientcode]

p <- ggplot(PTNM_M_patient,aes(as.factor(Subtype), meanKLdiv))+
geom_boxplot()

age_patient = cluster_dat_tumors[,c("age","patientcode")]
age_patient = age_patient[order(patientcode)]
age_patient = unique(age_patient)
age_patient$meanKLdiv[age_patient$patientcode %in% names(sum_kldiv)] = mean_kldiv_mat_tumors[names(sum_kldiv) %in% age_patient$patientcode]
age_patient$meanShannon[age_patient$patientcode %in% names(sum_shannon)] = mean_shannon_mat_tumors[names(sum_shannon) %in% age_patient$patientcode]

p2 <-ggplot(age_patient,aes(x = age,y=meanShannon,fill = meanKLdiv))+
  geom_point(size=2, alpha=1,aes(color=meanKLdiv))+
  scale_color_viridis(option="magma")+
  geom_smooth(method=lm)


cluster_patient = cluster_dat_tumors[,c("patient_pheno","patientcode")]
cluster_patient = cluster_patient[order(patientcode)]
cluster_patient = unique(cluster_patient)
cluster_patient$meanKLdiv[cluster_patient$patientcode %in% names(sum_kldiv)] = mean_kldiv_mat_tumors[names(sum_kldiv) %in% cluster_patient$patientcode]
cluster_patient$meanShannon[cluster_patient$patientcode %in% names(sum_shannon)] = mean_shannon_mat_tumors[names(sum_shannon) %in% cluster_patient$patientcode]

p <- ggplot(cluster_patient,aes(as.factor(patient_pheno), meanKLdiv))+
geom_boxplot()


#All patient samples vs tumor mean
cluster_dat_tumors[,tumor_logical := grade %in% c("1","2","3")]
cluster_dat_tumors[,to_calc_mean := cluster_by_area]
cluster_dat_tumors$to_calc_mean[cluster_dat_tumors$tumor_logical == 'FALSE'] = NA
dat_cut <- cluster_dat_tumors[,c("core","cluster","cluster_by_area","patientcode","to_calc_mean")]
ind_patients <- split( dat_cut , f = dat_cut$patientcode )
all_patient = lapply(ind_patients, function(x){x[order(x$core),]})
all_patient_mean = lapply(all_patient,function(x){x[, patient_mean := mean(na.omit(to_calc_mean)), by=cluster]})
ind_cores_all <- lapply(all_patient, function(x){split( x , f = x$core )})


library("entropy")
kldiv <- lapply(ind_cores_all, function(x){lapply(x,function(y){KL.plugin(y$cluster_by_area, na.omit(y$patient_mean))})})
sum_kldiv <- lapply(kldiv,function(x){Reduce("+",x)})
length_kldiv <- lapply(kldiv,function(x){length(x)})
mean_kldiv_mat <- unlist(t(sum_kldiv))/unlist(t(length_kldiv))
sum_kldiv_mat <- unlist(t(sum_kldiv))

#To add to image clustering of all samples
KLdiv_to_PatientMean_allImages = unlist(kldiv)
KLdiv_to_PatientMean_allImages = data.table(KLdiv_to_PatientMean_allImages)

patient_images = cluster_dat_tumors[,c("patientcode","core","location")]
patient_images = patient_images [order(patientcode)]
patient_images = unique(patient_images)

#Order according to core names from patient name ordering
KLdiv_to_PatientMean_allImages = KLdiv_to_PatientMean_allImages[order(patient_images$core)]


#Individual shannon index of images
shannon <- data.table(unlist(lapply(ind_cores_all, function(y){lapply(y, function(x){entropy.ChaoShen(x$cluster_by_area)})})))
shannon = shannon[order(patient_images$core)]

center_periphey = cbind(patient_images,shannon)
colnames(center_periphey)[4] = 'ShannonIdx'
p <- ggplot(center_periphey,aes(as.factor(location), ShannonIdx))+
geom_boxplot()
pdf(file="/home/jana/Desktop/R_dat/Shannon_location.pdf", width=10, height=10)
p
dev.off()

#paired t-test
center_periphey = center_periphey[!center_periphey$location %in% c('NORMAL','CONTROL','METASTASIS'),]
center_periphey[,mean := mean(V1), by = c('patientcode','location')]
center_periphey =center_periphey[,c('patientcode','location','mean')]
center_periphey = unique(center_periphey)

cp_wide = dcast.data.table(center_periphey, formula = 'patientcode ~ location', value.var = 'mean') 

cp_grade = merge(cp_wide,grade_patient[,c('grade','patientcode')], by = 'patientcode')
grade = cp_grade[cp_grade$grade == 1,]

t.test(grade3$CENTER, grade3$PERIPHERY, paired=TRUE)

```

#KL div grade1,2,3... kick out top part to only compare existing types and not zeros
```{r}

#Fill up zero clusters for each image
all_clusters = unique(cluster_dat$cluster)
cluster_dat_cut = unique(cluster_dat[,c("core","cluster","perc_cluster","patientcode","grade")])
ind_cores <- split( cluster_dat_cut , f = cluster_dat_cut$core )
cluster_dat_complete =lapply(ind_cores,function(x){x = data.frame(rbind(as.matrix(x),as.matrix(data.frame(cbind(rep(unique(x$core),length(which(!all_clusters %in% x$cluster))),all_clusters[!all_clusters %in% x$cluster],rep(0, length(which(!all_clusters %in% x$cluster))),rep(unique(x$patientcode),length(which(!all_clusters %in% x$cluster))),rep(unique(x$grade),length(which(!all_clusters %in% x$cluster))))))))})


cluster_dat_complete = ldply(cluster_dat_complete, data.frame)
cluster_dat_complete = cluster_dat_complete[,2:ncol(cluster_dat_complete)]
cluster_dat_complete = data.table(cluster_dat_complete)
cluster_dat_complete$perc_cluster = as.numeric(as.character(cluster_dat_complete$perc_cluster))


normal = subset(cluster_dat, grade %in% 'NORMAL')
grade1 = subset(cluster_dat, grade %in% 1)
grade2 = subset(cluster_dat, grade %in% 2)
grade3 = subset(cluster_dat, grade %in% 3)

normal_cut <- normal[,c("core","cluster","ncells","patientcode")]
grade1_cut <- grade1[,c("core","cluster","ncells","patientcode")]
grade2_cut <- grade2[,c("core","cluster","ncells","patientcode")]
grade3_cut <- grade3[,c("core","cluster","ncells","patientcode")]

#Normal
normal_cut[,overall_mean := mean(ncells), by = cluster]
ind_patients <- split( normal_cut , f = normal_cut$patientcode )
all_patient_normal = lapply(ind_patients,function(x){x[, patient_mean := mean(ncells), by=cluster]})
library("entropy")
kldiv <- lapply(all_patient_normal, function(x){KL.plugin(x$patient_mean, x$overall_mean)})
sum_kldiv <- lapply(kldiv,function(x){Reduce("+",x)})
length_kldiv <- lapply(kldiv,function(x){length(x)})
mean_kldiv_mat_normal <- unlist(t(sum_kldiv))/unlist(t(length_kldiv))
normalKL = cbind(data.frame(names(kldiv)),data.frame(mean_kldiv_mat_normal))
names(normalKL) = c('patientcode','KLdiv')
normalKL$grade = factor('NORMAL')

#Grade1
grade1_cut[,overall_mean := mean(ncells), by = cluster]
ind_patients <- split( grade1_cut , f = grade1_cut$patientcode )
all_patient_grade1 = lapply(ind_patients,function(x){x[, patient_mean := mean(ncells), by=cluster]})
library("entropy")
kldiv <- lapply(all_patient_grade1, function(x){KL.plugin(x$patient_mean, x$overall_mean)})
sum_kldiv <- lapply(kldiv,function(x){Reduce("+",x)})
length_kldiv <- lapply(kldiv,function(x){length(x)})
mean_kldiv_mat_grade1 <- unlist(t(sum_kldiv))/unlist(t(length_kldiv))
grade1KL = cbind(data.frame(names(kldiv)),data.frame(mean_kldiv_mat_grade1))
names(grade1KL) = c('patientcode','KLdiv')
grade1KL$grade = factor('1')

#Grade2
grade2_cut[,overall_mean := mean(ncells), by = cluster]
ind_patients <- split( grade2_cut , f = grade2_cut$patientcode )
all_patient_grade2 = lapply(ind_patients,function(x){x[, patient_mean := mean(ncells), by=cluster]})
library("entropy")
kldiv <- lapply(all_patient_grade2, function(x){KL.plugin(x$patient_mean, x$overall_mean)})
sum_kldiv <- lapply(kldiv,function(x){Reduce("+",x)})
length_kldiv <- lapply(kldiv,function(x){length(x)})
mean_kldiv_mat_grade2 <- unlist(t(sum_kldiv))/unlist(t(length_kldiv))
grade2KL = cbind(data.frame(names(kldiv)),data.frame(mean_kldiv_mat_grade2))
names(grade2KL) = c('patientcode','KLdiv')
grade2KL$grade = factor('2')

#Grade3
grade3_cut[,overall_mean := mean(ncells), by = cluster]
ind_patients <- split( grade3_cut , f = grade3_cut$patientcode )
all_patient_grade3 = lapply(ind_patients,function(x){x[, patient_mean := mean(ncells), by=cluster]})
library("entropy")
kldiv <- lapply(all_patient_grade3, function(x){KL.plugin(x$patient_mean, x$overall_mean)})
sum_kldiv <- lapply(kldiv,function(x){Reduce("+",x)})
length_kldiv <- lapply(kldiv,function(x){length(x)})
mean_kldiv_mat_grade3 <- unlist(t(sum_kldiv))/unlist(t(length_kldiv))
grade3KL = cbind(data.frame(names(kldiv)),data.frame(mean_kldiv_mat_grade3))
names(grade3KL) = c('patientcode','KLdiv')
grade3KL$grade = factor('3')


all_grades_kl = rbind(normalKL,grade1KL,grade2KL,grade3KL)

grades_kl = merge(cluster_dat,all_grades_kl, by = c('patientcode','grade'))
grades_kl_cut = grades_kl[,c('patientcode','grade','KLdiv')]
grades_kl_cut = unique(grades_kl_cut)
grades_kl_cut$grade = factor(grades_kl_cut$grade, level = c('NORMAL','1','2','3'))
names(grades_kl_cut)[3] = 'KLdiv_interPatient'

p <- ggplot(grades_kl_cut,aes(as.factor(grade),KLdiv_interPatient))+
geom_boxplot()
pdf(file="/home/jana/Desktop/R_dat/KLinterPatient_grade_normalized.pdf", width=10, height=10)
p
dev.off()


# T-test grade1 vs grade3
y = 0
y[grades_kl_cut$grade == 'NORMAL'] = 1
y[grades_kl_cut$grade == '3'] = 0
y = y[!grades_kl_cut$grade %in% c('1',"2")]
x = grades_kl_cut$KLdiv_interPatient[!grades_kl_cut$grade %in% c('1',"2")]
t.test(x~as.factor(y))







```

```{r}

normal = subset(cluster_dat, grade %in% 'NORMAL')
grades = subset(cluster_dat, grade %in% c(1,2,3))


normal_cut <- normal[,c("core","cluster","ncells","patientcode")]
grades_cut <- grades[,c("core","cluster","ncells","patientcode")]

#Normal
normal_cut[,overall_mean := mean(ncells), by = cluster]
normal_cut = normal_cut[,c('cluster','patientcode','overall_mean')]
grades_cut = grades_cut[,c('cluster','patientcode','ncells')]


both = merge(grades_cut,normal_cut, by = c('patientcode','cluster'))
ind_patients <- split( both , f = both$patientcode )


kldiv <- lapply(ind_patients, function(x){KL.plugin(x$ncells, x$overall_mean)})

names_patients = names(kldiv)
to_normal_kldiv = unlist(kldiv)
kl_to_norm = cbind(data.frame(names_patients),data.frame(to_normal_kldiv))
colnames(kl_to_norm) = c('patientcode','KLdiv_to_average_Normal')
rownames(kl_to_norm) = NULL

to_normal_kl = merge(cluster_dat,kl_to_norm, by = c('patientcode'))


survival_kl_cut = to_normal_kl[,c('patientcode','OSmonth','KLdiv_to_average_Normal')]
survival_kl_cut = unique(survival_kl_cut)


p <- ggplot(survival_kl_cut,aes(OSmonth,KLdiv_to_average_Normal))+
geom_point()+
  geom_smooth(method=lm)
pdf(file="/home/jana/Desktop/R_dat/KLinterPatient_vs_survuval.pdf", width=10, height=10)
p
dev.off()


shannon_patients = lapply(ind_patients, function(y){entropy.ChaoShen(y$ncells)})
names_patients = names(shannon_patients)
to_normal_shannon = unlist(shannon_patients)
shannon_to_norm = cbind(data.frame(names_patients),data.frame(to_normal_shannon))
colnames(shannon_to_norm) = c('patientcode','shannon')
rownames(shannon_to_norm) = NULL

to_normal_shannon = merge(cluster_dat,shannon_to_norm, by = c('patientcode'))


survival_shannon_cut = to_normal_shannon[,c('patientcode','OSmonth','shannon')]
survival_shannon_cut = unique(survival_shannon_cut)

p <- ggplot(survival_shannon_cut,aes(OSmonth,shannon))+
geom_point()+
  geom_smooth(method=lm)



```




