---
  title: "R downstream analysis Zurich TMA"
author: "Jana Fischer"
html_document: default
---

#Downstream R analysis for Zurich TMA on final single cell data (after cleaning of SC and metadata, final cleaned data provided). Produces all Figure content related to the Zurich TMA and aligns with Basel TMA. This pipeline uses output files from the previously run BaselTMA_pipeline. These files are provided in the output folder.
  
```{r}
library(data.table)
library(RColorBrewer)
library(dplyr)
library(gplots)
library(ggplot2)
library(stringr)
```

```{r Settings}

fn_cells = '/home/ubuntu/tmp/server_homes/janaf/Data/2019/Data_publication/ZurichTMA/SC_dat.csv'
fn_meta = '/home/ubuntu/tmp/server_homes/janaf/Data/2019/Data_publication/ZurichTMA/Zuri_PatientMetadata.csv'
fn_ZuriPheno = '/home/ubuntu/tmp/server_homes/janaf/Data/2019/Data_publication/ZurichTMA/PG_zurich.csv'

# Define channels to be excluded
channel_exclude = c("ImageId" ,"CellId" ,"In115 115InIn115Di","Xe134 134XeXe134Di","Hg202 202HgHg202Di","Pb204 204PbPb204Di","Pb206 206PbPb206Di","ArAr80 80ArArArAr80Di","phospho Erk12", "10311239Ru96Di Rutheni","10311240Ru98Di Rutheni","10311241Ru99Di Rutheni", "10311242Ru100Di Rutheni","10311243Ru101Di Rutheni", "10311244Ru102Di Rutheni","10311245Ru104Di Rutheni","Xe126 126XeXe126Di","I127 127II127Di","Xe131 131XeXe131Di","Pb207 207PbPb207Di","Pb208 208PbPb208Di","EulerNumber","MajorAxisLength","MinorAxisLength", "Orientation","10331253Ir191Di Iridium","2971330Dy161Di EpCAM","Perimeter","1971527Ho165Di bCaten","483739Yb171Di Sox9","Solidity")

#Save cluster order of Figures
cluster_order = c('37','4','10','11','27','6','19','22','29','31','24','14','30','32','9','23','33','34','40','13','12','17','20','38','15','26','35','25','8','41','3','39','7','2','21','28','18','5','1','16');

```

#Load the data
```{r}
#Single-cell data
dat <- fread(fn_cells,header = T)
#Patient metadata
Sample_metadata <- fread(fn_meta,header = T)
#PhenoGraph result from publication
custom_PG <- fread(fn_ZuriPheno, header = T)

```

#Display the channels used for analysis
```{r}
good_channels = unique(dat$channel)[!unique(dat$channel) %in% channel_exclude]
print(good_channels)
```

#Define a colormap used for general plots
```{r Generate a color pallette for plotting}
qual_col_pals = brewer.pal.info[brewer.pal.info$category == 'qual',]
col_vector = unlist(mapply(brewer.pal, qual_col_pals$maxcolors, rownames(qual_col_pals)))
col_vector = unique(col_vector)
```

#Define custom colormap with colors according to cell types as used in pulication
```{r Generate a color pallette for plotting}
#colors matched to most similar cell type from Basel TMA (see alignment bellow)
mycols =c("darkolivegreen","darkolivegreen","darkolivegreen1","green3","cadetblue1","darkslategray1","darkslategray1","yellow","turquoise1","turquoise1","lightskyblue","lightpink","dodgerblue4","blue","blue","aquamarine","aquamarine","aquamarine","aquamarine4","brown1","firebrick","purple4","purple4","purple4","purple4","purple4","darkorchid","darkorchid","darkorchid","salmon","chocolate","chocolate","chocolate","chocolate","orange2","deeppink1","deeppink1","deeppink1","deeppink1","tan4")

#Write out color map for use in other software (e.g. highlight cells in corresponding colors in histoCAT)
RGB = t(col2rgb(mycols[order(rev(as.numeric(cluster_order)))])) #in histoCAT clusters are ordered sequentially according to their cluster number
RGB_norm = (RGB - min(RGB))/(max(RGB) - min(RGB)) 
fwrite(data.table(RGB_norm), file='/home/jana/Desktop/R_dat/RGB_basel_meta.csv', col.names = TRUE)
hex = rgb(RGB_norm)

#Metacluster colors from Basel TMA
mycols_basel_meta <- colors()[c(258,257,86,85,259,81, #green
                                652, #yellow
                                636,520,430,109,68,43,#light blue
                                132,#other dark blue
                                26,#dark blue
                                8,12, #turquouis
                                33,#red
                                551,#dark purple
                                95,#light purple
                                419,#light pink
                                117,#pink
                                52,#burnt orange
                                500,#orange
                                568,#pink orange
                                624, #brown
                                133)] #dark red


#SCP patient group colors
mycols_patient = colors()[c(52,500,540,568,571,117,419,314,371,450,95,551,33,8,12,26,132,624)]

#Colormap for clinical subgroups
mycols_clinical = colors()[c(545,622,525,74)]
                
```

#Extract relevant PhenoGraph columns from custom_PG dataset
```{r}
# Get Phenograph column
custom_PG[, id := paste(.BY,collapse =  "_"), by=.(core,CellId)] 
pheno_cn <- c("id",colnames(custom_PG)[grep('PhenoGraph', colnames(custom_PG))])
cluster_pheno <- custom_PG[,pheno_cn, with=FALSE]
colnames(cluster_pheno) <- c("id","cluster")
```

#Plot heatmaps of the phenograph clusters for zurich TMA only
```{r}
setkey(dat,id)

#Exclude controls
dat = dat[!str_detect(dat$core,'control'),]
dat = dat[!str_detect(dat$core,'non-breast'),]
cluster_pheno = cluster_pheno[!str_detect(cluster_pheno$id,'non-breast'),]
cluster_pheno = cluster_pheno[!str_detect(cluster_pheno$id,'control'),]

#Exclude bad stains (these images are excluded from all further analysis because they turned out to be stained very weakly which resulted in almost all contained cells clustering together)
dat = dat[!str_detect(dat$core,regex('Ay.x1')),]
dat = dat[!str_detect(dat$core,regex('Ay..x1')),]
cluster_pheno = cluster_pheno[!str_detect(cluster_pheno$id,'Ay.x1'),]
cluster_pheno = cluster_pheno[!str_detect(cluster_pheno$id,'Ay..x1'),]

cluster_pheno$cluster <- factor(cluster_pheno$cluster, levels = cluster_order)
dat[,c_counts := bbRtools::censor_dat(mc_counts,0.99),by = channel]
#dat[, sc_counts := scale(mc_counts,censor_val), by=channel]

summary_dat = dat[cluster_pheno][ channel %in% good_channels ,list(
  median_val = median(c_counts),
  mean_val= mean(c_counts),
  cell_cluster=.N),
  by=.(channel,cluster)]

hm_dat = dcast.data.table(data =summary_dat, formula = 'cluster ~ channel',
                          value.var = 'mean_val') #'median_val' can be exchanged for 'mean_val'
                          
trownames = hm_dat$cluster
hm_dat = as.matrix(hm_dat[,-1,with=F])
row.names(hm_dat) = trownames

```

Plot the heatmap with z-scoring per marker
```{r}
# Set color map
cols = rev(brewer.pal(11,'Spectral'))
cmap = colorRampPalette(cols)

# Hierarchical clustering on rows with Ward's linkage
tdist = as.dist(1-cor(t(hm_dat), method="spearman"))
hr <- hclust(tdist, method="ward.D2")
co_r <- order.optimal(tdist, hr$merge)
hr$merge = co_r$merge
hr$order = co_r$order

#Order rows in heatmap according to clustering
order_heatmap_zscored = row.names(hm_dat)[hr$order]

# Hierarchical clustering on columns with Ward's linkage
tdist = as.dist(1-cor((hm_dat), method="spearman"))
hc <- hclust(tdist, method="ward.D2")
co_c <- order.optimal(tdist, hc$merge)
hc$merge = co_c$merge
hc$order = co_c$order

# Z-score data
p_dat = scale(hm_dat)

# Censor z-score at 2
p_dat[p_dat > 2] =2
p_dat[p_dat < -2] =-2


pdf(file="heatmap_zuri.pdf", width=10, height=10)

heatmap.2(p_dat,
          scale ='none',
          trace = "none",
          col=cmap(75),
          Rowv=as.dendrogram(hr),
          Colv=as.dendrogram(hc),
          density.info ='none',
          cexRow=0.6,
          cexCol=0.6,
          margins=c(4,8),
          xlab = 'Markers',
          ylab ='Cluster',
          main = 'PG_norm_slide')

dev.off()

```

#Match PG clusters from Zurich TMA to Basel TMA metaclusters
```{r}
# Z-score zurich data
hm_dat_zuri = hm_dat
hm_dat_zuri = scale(hm_dat_zuri)

#Read in metacluster means from Basel TMA
hm_dat_basel = fread('/home/ubuntu/tmp/server_homes/janaf/Data/2019/Data_publication/ZurichTMA/output_BaselTMA/hm_dat_basel.csv',header = T)
rownames = hm_dat_basel$V1
hm_dat_basel = as.matrix(hm_dat_basel[,-1])
rownames(hm_dat_basel)= rownames

# Z-score basel data
hm_dat_basel = scale(hm_dat_basel)

#Make sure all the same markers are used
colnames(hm_dat_zuri)[!colnames(hm_dat_zuri) %in% colnames(hm_dat_basel)] 
colnames(hm_dat_basel)[!colnames(hm_dat_basel) %in% colnames(hm_dat_zuri)]

#Calculate distances based on correlations between zurich and basel clusters
crosscor = 1-cor(t(hm_dat_basel),t(hm_dat_zuri),method = 'pearson')
#Find most similar cluster
idx_min = apply(crosscor,2,function(x){which(x == min(x))})
dist_min = apply(crosscor,2,min)
cluster_match = data.table(rownames(crosscor)[unlist(idx_min)])
colnames(cluster_match) = 'Basel'
cluster_match$zuri = colnames(crosscor)
cluster_match$dist = dist_min
cluster_match$zuri = as.numeric(cluster_match$zuri)
cluster_match = cluster_match[order(zuri),]

#Plot heatmap of Zurich PG clusters ordered and colored according to matching Basel metacluster
p_dat = hm_dat_zuri
p_dat[p_dat > 2] =2
p_dat[p_dat < -2] =-2
p_dat = p_dat[order(as.numeric(rownames(p_dat))),]

#Read in order from metacluster heatmap of Basel TMA (saved out in output from BaselTMA pipeline) in order to sort this heatmap accordingly
ordered_labels = fread('/home/ubuntu/tmp/server_homes/janaf/Data/2019/Data_publication/ZurichTMA/output_BaselTMA/ordered_labels_basel.csv',header = F)
ordered_labels = ordered_labels$V1
ordered_channels = fread('/home/ubuntu/tmp/server_homes/janaf/Data/2019/Data_publication/ZurichTMA/output_BaselTMA/ordered_channels_basel.csv',header = F,fill = T)
ordered_channels = ordered_channels[-1,]

cluster_match = cluster_match[order(as.numeric(Basel)),]
p_dat = p_dat[as.character(rev(cluster_match[order(match(cluster_match$Basel[cluster_match$Basel %in% ordered_labels],ordered_labels)),zuri])),]
p_dat = p_dat[,match(ordered_channels$V1,colnames(p_dat))]

cols_corresp_basel = mycols_basel_meta[rev(as.numeric(cluster_match[order(match(cluster_match$Basel[cluster_match$Basel %in% ordered_labels],ordered_labels)),Basel]))]

#Visualizes fully automatic assignment but for the publication a few clusters were reassigned based prior knowledge about markers (for example, cluster 15 was assigned to an immune cell based on marker correlations but contains some tumor markers, hence it was manually reassigned to the most similar tumor cell type)
pdf('zuri_heatmap_color_and_ord_matched_Basel.pdf')
heatmap.2(p_dat,
          scale ='none',
          trace = "none",
          col=cmap(75), dendrogram = "none", Rowv = FALSE, Colv = FALSE,
          density.info ='none',
          cexRow=0.6,
          cexCol=0.6,
          margins=c(4,8),
          xlab = 'Markers',
          ylab ='Cluster',
          main = 'PG_matched',
          colRow = cols_corresp_basel)
dev.off()


#Reassign some clusters as done for publication
cluster_match$Basel[cluster_match$zuri == 29] = 23 #different tumor cluster matched better based on relevant markers
cluster_match$Basel[cluster_match$zuri == 40] = 19 #different tumor cluster matched better based on relevant markers
cluster_match$Basel[cluster_match$zuri == 6] = 24 #different tumor cluster matched better based on relevant markers
cluster_match$Basel[cluster_match$zuri == 11] = 22 #different tumor cluster matched better based on relevant markers
cluster_match$Basel[cluster_match$zuri == 8] = 21 #This cluster forms tumor bulks (not stromal!!)
cluster_match$Basel[cluster_match$zuri == 9] = 19 #different tumor cluster matched better based on relevant markers
cluster_match$Basel[cluster_match$zuri == 26] = 15 #different tumor cluster matched better based on relevant markers
cluster_match$Basel[cluster_match$zuri == 15] = 16 #this has tumor markers
cluster_match$Basel[cluster_match$zuri == 41] = 10
cluster_match$Basel[cluster_match$zuri == 39] = 8 
cluster_match$Basel[cluster_match$zuri == 3] = 8
cluster_match$Basel[cluster_match$zuri == 1] = 3

#Plot publication version
cluster_match = cluster_match[order(as.numeric(Basel)),]
p_dat = p_dat[as.character(rev(cluster_match[order(match(cluster_match$Basel[cluster_match$Basel %in% ordered_labels],ordered_labels)),zuri])),]
p_dat = p_dat[,match(ordered_channels$V1,colnames(p_dat))]

cols_corresp_basel = mycols_basel_meta[rev(as.numeric(cluster_match[order(match(cluster_match$Basel[cluster_match$Basel %in% ordered_labels],ordered_labels)),Basel]))]

pdf('zuri_heatmap_color_and_ord_matched_Basel.pdf')
heatmap.2(p_dat,
          scale ='none',
          trace = "none",
          col=cmap(75), dendrogram = "none", Rowv = FALSE, Colv = FALSE,
          density.info ='none',
          cexRow=0.6,
          cexCol=0.6,
          margins=c(4,8),
          xlab = 'Markers',
          ylab ='Cluster',
          main = 'PG_matched',
          colRow = cols_corresp_basel)
dev.off()

```

#Plot marker distributions for each cell type cluster
```{r}
#per channel
for (i in unique(dat[channel %in% good_channels,]$channel)){
  cdat <- dat[cluster_pheno][channel %in% good_channels,][channel == i,][,markermean:= mean(c_counts),by = 'cluster']
  pdf(paste0('marker_distributions_channel_',as.character(i),'.pdf'),width = 30,height = 150)
  print(ggplot(cdat, aes(x=c_counts, colour=cluster)) +
      geom_density(aes(y=..scaled..)) +
      geom_vline(data=cdat, aes(xintercept=markermean,  colour=cluster),
                 linetype="dashed", size=1)+
      facet_wrap( ~ cluster, ncol=1)+
    scale_color_manual(values = rev(mycols)))
  dev.off()}
```

Reproduce clustergram from neighborhood analysis in R with some adaptations
```{r}

#Read in data from histoCAT neighborhood analysis where stromal/immune/Endothelial Metaclusters are separate but all tumor cells have the same label (100)
clustergram_dat = read.csv('/home/ubuntu/tmp/server_homes/janaf/Data/2019/Data_publication/ZurichTMA/neighborhood_output/Clustergram_Zurich.csv',header = T,row.names = 1)

##Adapt names to be consistent with naming here, only necessary first time when importing from neighborhood run in histoCAT (provided neighborhood output is already cleaned)
# rnames = rownames(clustergram_dat)
# clustergram_dat = data.table(clustergram_dat)
# clustergram_dat$core = rnames
# test = unique(clustergram_dat$core)
# split_core = strsplit(clustergram_dat$core,'_', fixed = TRUE)
# clustergram_dat$core = unlist(lapply(split_core, function(x){paste(x[c(1,2,8,9,10)],collapse =  "_")}))
# #Replace the ones that don't need acquisition number again
# short = unlist(lapply(strsplit(test,'_', fixed = TRUE),function(x){paste(x[c(1,2,8,9)],collapse =  "_")}))
# duplicate_idx = duplicated(short) | duplicated(short, fromLast = TRUE)
# in_cores_index = unlist(lapply(unique(clustergram_dat$core)[duplicate_idx],function(x){which(clustergram_dat$core %in% x)}))
# clustergram_dat$core[setdiff(1:length(clustergram_dat$core),in_cores_index)] = unlist(lapply(strsplit(clustergram_dat$core[setdiff(1:length(clustergram_dat$core),in_cores_index)],'_', fixed = TRUE), function(x){paste(x[1:length(x)-1],collapse =  "_")}))
# #Delete zeros
# clustergram_dat$core = unlist(lapply(clustergram_dat$core,function(x){gsub("000","",x)}))

#Exclude weak stains
clustergram_dat = clustergram_dat[!str_detect(clustergram_dat$core,regex('Ay.x1')),]
clustergram_dat = clustergram_dat[!str_detect(clustergram_dat$core,regex('Ay..x1')),]

#Remove controls
clustergram_dat = clustergram_dat[!str_detect(clustergram_dat$core,'control'),]
clustergram_dat = clustergram_dat[!str_detect(clustergram_dat$core,'non-breast'),]

#Remove normal samples
clustergram_dat = merge(clustergram_dat,unique(Sample_metadata[,c('core','location')]),by = 'core')
clustergram_dat = clustergram_dat[!location %in% c('[]','METASTASIS'),]
clustergram_dat = clustergram_dat[,-'location']

clustergram_dat_meta = merge(clustergram_dat,Sample_metadata,by = 'core')


#Prepare for clustered heatmap
rnames = clustergram_dat$core
mat = as.matrix(clustergram_dat[,-'core'])
rownames(mat) = rnames

#Split into clusters, not used for publication
hr = hclust(dist(mat), method = "ward.D2")
clusters = dendextend::cutree(hr, k = 10)

#Write out clusters
cnames = names(clusters)
neighb_clusters = data.table(cnames)
names(neighb_clusters) = 'core'
neighb_clusters$cluster = unlist(clusters)

#Plot heatmap
h = Heatmap(mat, name = "Clustergram", km = 1, col = colorRamp2(c(-1, 0, 1), c("blue", "white", "red")),
     show_row_names = T, show_column_names =  T, clustering_method_rows = "ward.D2",clustering_method_columns = "ward.D2",split = clusters)+   #  row_order = rev(order_stacked), cluster_rows = FALSE
#location
    Heatmap(factor(clustergram_dat_meta$location), name = "Location", show_row_names = FALSE, width = unit(10, "mm"), col = structure(c("white","red","blue","black"), names = c('[]','CENTER','PERIPHERY','METASTASIS')))+ 
 #grade 
Heatmap(factor(clustergram_dat_meta$grade), name = "Grade", show_row_names = FALSE, width = unit(10, "mm"), col = structure(c("green","blue","red",'black'), names = c('1','2','3','METASTASIS')))+ 
#Mets
Heatmap(factor(clustergram_dat_meta$PTNM_M), name = "Met", show_row_names = FALSE, width = unit(10, "mm"), col = structure(c("black","gray",'white'), names = c('M1','M0_IPLUS','M0')))
  
  
pdf('clustergram_ZuriImages_far.pdf',width = 20,height = 20)
h
dev.off()


```

#Location composition of clusters from heatmap above
```{r}
loc_arc = merge(neighb_clusters,unique(Sample_metadata[,c('core','location')]),by = 'core')
loc_arc[,count := .N ,by = c('cluster','location')]
loc_arc[,frac_cluster := count/.N, by = 'cluster']
loc_arc[,frac_location := count/.N, by = 'location']
loc_arc = unique(loc_arc[,c('cluster','location','frac_cluster')])

p <- ggplot(loc_arc, aes(x=as.factor(cluster), y=frac_cluster, fill=as.factor(location))) + 
  geom_bar(stat='identity',show.legend = TRUE)+
  scale_fill_manual("Clusters",values =  c('red','blue'))+ 
  labs(fill = "Location")+
  coord_flip()+
  xlab("mArc")+
  ylab("Frac location")+
  theme(panel.background = element_blank())+
  ggtitle('Location composition')


pdf('mArc_location.pdf')
p
dev.off()

```

#Prepare data for patient and image cell type counts
```{r}
#Count number of cells per core and cluster
dat_cluster_caseID = dat[cluster_pheno][, .(ncells=.N),by=.(core, channel, cluster)]
dat_cluster_caseID[, id:=paste(cluster, core)]
setkey(dat_cluster_caseID, 'id')

#Remove duplicates
cluster_dat_incl_stroma = subset(dat_cluster_caseID, !duplicated(id))

#Version including stroma
#Get fractions/percentages of cells by core/cluster
cluster_dat_incl_stroma[, frac_cluster := ncells/sum(ncells), by=core]
cluster_dat_incl_stroma[, frac_cells := ncells/sum(ncells), by=cluster]
cluster_dat_incl_stroma[, perc_cluster := ncells*100/sum(ncells), by=core]
cluster_dat_incl_stroma[, perc_cells := ncells*100/sum(ncells), by=cluster]

#Merge with metadata
cluster_dat_incl_stroma = merge(cluster_dat_incl_stroma, Sample_metadata[!is.na(Sample_metadata$area),], by = c('core'), all.x = TRUE, allow.cartesian=TRUE, rm.NA = TRUE)

#Calculate cell type densities per image
cluster_dat_incl_stroma[,cell_density := ncells/area, by = 'core']


#Version without stroma
#Exclude stromal cells
cluster_dat = subset(dat_cluster_caseID, !duplicated(id))
cluster_dat = cluster_dat[!cluster %in% c(1:3,5,7,16,18,21,28,39,41),]

#Get fractions/percentages of cells by core/cluster
cluster_dat[, frac_cluster := ncells/sum(ncells), by=core]
cluster_dat[, frac_cells := ncells/sum(ncells), by=cluster]
cluster_dat[, perc_cluster := ncells*100/sum(ncells), by=core]
cluster_dat[, perc_cells := ncells*100/sum(ncells), by=cluster]

#Merge with metadata
cluster_dat = merge(cluster_dat, Sample_metadata[!is.na(Sample_metadata$area),], by = c('core'), all.x = TRUE, allow.cartesian=TRUE, rm.NA = TRUE)

#Calculate cell type densities per image
cluster_dat[,cell_density := ncells/area, by = 'core']

```

#Kick out normal, met and control in case not wanted for subsequent analyses, use metacluster labels from Basel
```{r}
#Including stroma
cluster_dat_tumors_stroma <- cluster_dat_incl_stroma[!is.na(cluster_dat_incl_stroma$PID),]
cluster_dat_tumors_stroma <- cluster_dat_tumors_stroma[!cluster_dat_tumors_stroma$location == '[]',]

#Map metacluster labels (machted from Basel cohort) because from now on only using metacluster cell types 
cluster_dat_tumors_stroma$cluster <- mapvalues(cluster_dat_tumors_stroma$cluster, from=cluster_match$zuri, to=cluster_match$Basel)


#Without stromal cells
cluster_dat_tumors <- cluster_dat[!is.na(cluster_dat$PID),]
cluster_dat_tumors <- cluster_dat_tumors[!cluster_dat_tumors$location == '[]',]

#Map metacluster labels (machted from Basel cohort) because from now on only using metacluster cell types 
cluster_dat_tumors_orig = cluster_dat_tumors
cluster_dat_tumors$cluster <- mapvalues(cluster_dat_tumors$cluster, from=cluster_match$zuri, to=cluster_match$Basel

```

#In case normal, met and control are kept, name them accordingly
```{r}
#Non existent patientcodes are control samples
cluster_dat$location[is.na(cluster_dat$PID)] <- 'CONTROL'
cluster_dat$PID[is.na(cluster_dat$PID)] <- 'CONTROL'
cluster_dat$grade[is.na(cluster_dat$grade)] <- 'CONTROL'

#Empty locations are normal samples, except for when they are met -> overwrite the mets
cluster_dat$grade[cluster_dat$location == '[]'] <- 'NORMAL'
cluster_dat$location[cluster_dat$location == '[]'] <- 'NORMAL'

cluster_dat[, cluster_by_area := ncells/area, by=c('core','cluster')]
cluster_dat = cluster_dat[!is.na(cluster_dat$cluster_by_area),]

#Exclude sample with no tumor core
cluster_dat = cluster_dat[cluster_dat$PID %in% cluster_dat_tumors$PID,]
```

#Distribution of cell types across center and periphery cores
```{r}
cluster_loc = cluster_dat[,c('cluster','core','ncells','location')]
cluster_loc = cluster_loc[!location %in% c('NORMAL'),]
cluster_loc[,count := .N, by = c('cluster','location')]
cluster_loc[,frac_cluster := count/.N, by = 'cluster']
cluster_loc[,frac_location := count/.N, by = 'location']
cluster_loc = unique(cluster_loc[,c('cluster','location','frac_cluster')])

p <- ggplot(cluster_loc, aes(x=cluster, y=frac_cluster, fill=factor(location,levels = c('CENTER','PERIPHERY','NORMAL','METASTASIS')))) + 
  geom_bar(stat='identity',show.legend = TRUE)+
  scale_fill_manual("Clusters",values = c('red','blue','grey','black'))+ # rev(mycols)[!cluster_order %in% c(1,3:5,7:8,11,13,22,25:26,33:34)]
  labs(fill = "Location")+
  coord_flip()+
  xlab("loc")+
  ylab("Frac cluster")+
  theme(panel.background = element_blank(),
        axis.text.y = element_text(colour=rev(mycols)))+
  ggtitle('Location composition')

pdf('location.pdf')
p
dev.off()
```

#Patient clustering use tumor cells only
```{r}
# Prepare for patient clustering based on fraction of contained cell type metacluster cells
cluster_dat_tumors <- subset(cluster_dat_tumors, by="PID")
cluster_dat_tumors[, tot_patient := sum(ncells), by=PID]
cluster_dat_tumors[, tot_location := sum(ncells), by=location]
cluster_dat_tumors[, tot_cell_area_patient := sum(unique(sum_area_cells)), by=PID]
cluster_dat_tumors[, tot_image_area_patient := sum(unique(area)), by=PID]
cluster_dat_tumors[, frac_cells_image_Area_patient := ncells/tot_image_area_patient, by=.(cluster)]
cluster_dat_tumors[, frac_cells_cell_Area_patient := ncells/tot_cell_area_patient, by=.(cluster)]
cluster_dat_tumors[, frac_cells_amount_cells_patient := ncells/tot_patient, by=.(cluster)]
cluster_dat_tumors[, tot_cell_area_image := sum_area_cells]
cluster_dat_tumors[, frac_cells_cell_Area_image := ncells/tot_cell_area_image, by=.(cluster)]
cluster_dat_tumors[, tot_cell_area_location := sum(unique(sum_area_cells)), by=location]
cluster_dat_tumors[, tot_image_area_location := sum(unique(area)), by=location]
cluster_dat_tumors[, cluster_by_area := ncells/area, by=c('core','cluster')]
# order_orig = fread('/home/ubuntu/tmp/server_homes/janaf/Data/2019/Data_publication/ZurichTMA/order_orig.csv')
# cluster_dat_tumors = cluster_dat_tumors[order(match(core,order_orig$V1))]
# cluster_dat_tumors$PID = as.character(cluster_dat_tumors$PID)

patient_dat_vars <- cluster_dat_tumors[,c("PID","cluster","frac_cluster")] #replace frac with other norms
un_clusters <- unique(patient_dat_vars[,"cluster"])
un_clusters <- transform(un_clusters, cluster = as.character(cluster))
un_clusters <- unlist(un_clusters)
colnames(patient_dat_vars)<-c("PID","channel","value")
patient_dat_vars<-transform(patient_dat_vars, channel = as.character(channel))

# Hierarchical clustering on patients
patient_dat_vars = patient_dat_vars[order(PID)]
patient_wide = dcast.data.table(data =patient_dat_vars, formula = 'PID ~ channel',
                          value.var = 'value',fun.aggregate = mean,fill = 0)
patient_wide$PID = as.character(patient_wide$PID)

dd <- dist(scale(patient_wide[,2:ncol(patient_wide)]), method = "euclidean")
hc <- hclust(dd, method = "ward.D2")

```

#Image clustering use tumor cells only
```{r}
# Run hierclust on image's celltype fraction
image_dat_vars <- unique(cluster_dat_tumors) #cluster_dat for all images
grade <- unique(image_dat_vars[,c('core','grade')])
image_dat_vars <- image_dat_vars[,c("core","cluster","frac_cluster")]
un_clusters_im <- unique(image_dat_vars$cluster)
colnames(image_dat_vars)<-c("core","channel","value")
image_wide = dcast.data.table(data =image_dat_vars, formula = 'core ~ channel',
                          value.var = 'value',fun.aggregate = mean, fill = 0)

dd_image <- dist(scale(image_wide[,2:ncol(image_wide)]), method = "euclidean")
hc_image <- hclust(dd_image, method = "ward.D2")

#With original clusters for comparison
image_dat_vars <- unique(cluster_dat_tumors_orig) #cluster_dat for all images
grade <- unique(image_dat_vars[,c('core','grade')])
image_dat_vars <- image_dat_vars[,c("core","cluster","frac_cluster")]
un_clusters_im <- unique(image_dat_vars$cluster)
colnames(image_dat_vars)<-c("core","channel","value")
image_wide_orig = dcast.data.table(data =image_dat_vars, formula = 'core ~ channel',
                          value.var = 'value',fun.aggregate = mean, fill = 0)

```

#Asign individual images from Zurich TMA to most similar SCP patient group from Basel TMA based on tumor cell type proportions
```{r}
#Read in patient cell type composition from Basel TMA
basel_patients = fread('/home/ubuntu/tmp/server_homes/janaf/Data/2019/Data_publication/ZurichTMA/output_BaselTMA/patient_wide_basel.csv',header = T)
meta_patient_clustering = fread(file='/home/ubuntu/tmp/server_homes/janaf/Data/2019/Data_publication/ZurichTMA/output_BaselTMA/SCP_patientgroups.csv', header = TRUE)

#Aggregate into mean cell type composition per SCP patient group
basel = merge(basel_patients,meta_patient_clustering, by = 'PID',all.x = T)
basel$patient_pheno[is.na(basel$patient_pheno)] = 18
group_means = lapply(unique(basel$patient_pheno),function(x){colMeans(basel[patient_pheno == x,-c('PID','patient_pheno')])})
group_means_t = data.table(matrix(unlist(group_means), ncol = length(group_means[[1]]), byrow = TRUE))
group_means_t$patient_pheno = unique(basel$patient_pheno)
names(group_means_t) = c(names(group_means[[1]]),'patient_pheno')

rnames = group_means_t$patient_pheno
basel_mat = as.matrix(group_means_t[,-'patient_pheno'])
rownames(basel_mat) = rnames

#Sum over original clusters to get metacluster measurement per image
rnames = image_wide_orig$core
colnames(image_wide_orig) <- mapvalues(colnames(image_wide_orig), from=cluster_match$zuri, to=cluster_match$Basel)
zuri_images_sum = data.table(t(rowsum(t(image_wide_orig[,-'core']), group = colnames(image_wide_orig[,-'core']), na.rm = T)))
zuri_images_sum$core = rnames
zuri_mat = as.matrix(zuri_images_sum[,-'core'])
rownames(zuri_mat) = rnames
zuri_mat = zuri_mat[,colnames(basel_mat)]

basel_mat = basel_mat[order(as.numeric(rownames(basel_mat))), ] 

crosscor = cor(t(basel_mat),t(zuri_mat))
idx_min = apply(crosscor,2,function(x){which(x == max(x))})
dist_min = apply(crosscor,2,max)
SCP_match = data.table(names(unlist(idx_min)))
colnames(SCP_match) = 'zuri'
SCP_match$basel = idx_min
names(SCP_match) = c('core','patient_pheno')

```

#Image clustering with stacked barplot, change grade to PID
```{r}
image_order <- unique(cluster_dat$core)[hc_image$order]
#Reorder the levels of legend
cluster_dat$cluster <- factor(cluster_dat$cluster,levels = cluster_order)
patient_im_orig = cluster_dat[,c('core','grade')]
patient_im_orig = unique(patient_im_orig)
#For bar
core_location <- cluster_dat[,c('core','location')]
core_location  <- unique(core_location)
location_order <- core_location[order(match(core_location$core,image_order))]
all_order = patient_im_orig[order(match(patient_im_orig$core,image_order))]
cluster_dat$cluster = factor(cluster_dat$cluster, levels = cluster_order)

p <- ggplot(cluster_dat, aes(x=core, y=cluster_by_area,  fill=cluster)) + 
  geom_bar(stat='identity')+
  scale_fill_manual("Clusters",values = rev(mycols))+
  scale_x_discrete(limits = all_order$core)+
  #facet_wrap(core~)+
  labs(fill = "Clusters")+
  coord_flip()+
  xlab("Patient images")+
  ylab("Percentage of cluster cells in image")+
  theme(panel.background = element_blank(),
    axis.text.y = element_text(colour=c('green','blue','red','lightblue','black')[factor(all_order$grade, levels = c('1','2','3','NORMAL','METASTASIS'))]))+
  ggtitle('Patient composition')

library("ggdendro")
p2 <- ggdendrogram(hc_image, rotate = TRUE,labels = FALSE, theme_dendro = TRUE, leaf_labels = FALSE)+
  theme(axis.title.x=element_blank(),
          axis.text.x=element_blank(),
          axis.ticks.x=element_blank(),
          axis.title.y=element_blank(),
          axis.text.y=element_blank(),
          axis.ticks.y=element_blank())

#Location
location_order$location = factor(location_order$location, levels = c('CENTER','PERIPHERY','NORMAL','METASTASIS'))
p3 <- ggplot(location_order, aes(x=1,y=c(1:length(location_order$location))))+
      geom_tile(aes( fill=location))+
  scale_fill_manual(values = c('red','blue','lightblue','black'))+
    theme(axis.title.x=element_blank(),
          axis.text.x=element_blank(),
          axis.ticks.x=element_blank(),
          axis.title.y=element_blank(),
          axis.text.y=element_blank(),
          axis.ticks.y=element_blank(),
          line = element_blank(),
          legend.position="none")

library("cowplot")
p4 <- ggdraw() +
     draw_plot(p2 + scale_y_reverse(), 0, 0.001, 0.43, 0.995) +
     draw_plot(p ,0.49, 0.04, 0.5, 0.915)+
     draw_plot(p3,0.45,0,0.047,0.998)


pdf(file="Image_clustering_zuri.pdf", width=40, height=100)
p4
dev.off()

```

#Compute KL divergence between tumor cell type distributions of the individual core and the patient average 
```{r}
#KL divergence per patient

#Tumors mean
dat_cut_tumors <- cluster_dat_tumors[,c("core","cluster","perc_cluster","PID")]

#Set absent cells types to 0
dat_cut_tumors_wide = dcast.data.table(dat_cut_tumors,formula = 'PID + core ~ cluster',value.var = 'perc_cluster',fill = 0)
dat_cut_tumors_long = melt.data.table(dat_cut_tumors_wide, id.vars = c('PID','core') ,variable.name = 'cluster', value.name = 'perc_cluster')

#Split into patients
ind_patients <- split( dat_cut_tumors_long , f = dat_cut_tumors_long$PID )
all_patient = lapply(ind_patients, function(x){x[order(x$core),]})
all_patient_tumors = lapply(all_patient,function(x){x[, patient_mean := mean(perc_cluster), by=cluster]})
ind_cores_tumors <- lapply(all_patient_tumors, function(x){split( x , f = x$core )})

#Calculate KL divergence
kldiv <- lapply(ind_cores_tumors, function(x){lapply(x,function(y){entropy::KL.plugin(y$perc_cluster, na.omit(y$patient_mean))})})
sum_kldiv <- lapply(kldiv,function(x){Reduce("+",x)})
length_kldiv <- lapply(kldiv,function(x){length(x)})
mean_kldiv_mat_tumors <- unlist(t(sum_kldiv))/unlist(t(length_kldiv))
sum_kldiv_mat_tumors <- unlist(t(sum_kldiv))

```

#Compute shannon entropy of each core
```{r}
#Shannon entropy per core

#Split into cores
dat_cut_tumors <- unique(cluster_dat_tumors[,c("core","cluster","ncells")])
ind_cores <- split( dat_cut_tumors , f = dat_cut_tumors$core )

shannon_cores = lapply(ind_cores, function(x){entropy::entropy.ChaoShen(x$ncells)})
shannon_core = data.table(unlist(names(shannon_cores)))
names(shannon_core) = "core"
shannon_core$shannon = unlist(shannon_cores)

```

#Boxplot of average KL divergence to patient mean for cores assigned to each SCP patientgroup
```{r}

#SCP Patientgroup
kldiv_ordered = data.table(names(unlist(kldiv)))
kldiv_ordered$kldiv = as.vector(unlist(kldiv))
names(kldiv_ordered)[1] = 'core'
kldiv_ordered$core = unlist(lapply(strsplit(kldiv_ordered$core,'[.]'), function(x){paste(x[2],collapse = '.')}))
kldiv_ordered = merge(kldiv_ordered,SCP_match, by = 'core')

p <- ggplot(kldiv_ordered, aes(x=factor(patient_pheno), y=kldiv)) + 
  geom_boxplot()+
  geom_point(size=2, alpha=1)+
  #stat_summary( fun.y = "mean",geom="point",colour = "black", size = 5)+
  #stat_summary(aes(group=grade), fun.y=mean, geom="line", colour="green")+
  ylab("KL div to patietn average of core")+
  xlab("Patientgroup")+
  theme(panel.background = element_blank())+
  ggtitle('Cores assigned to patient group')

pdf('/home/jana/Desktop/R_dat/CoreKLdiv_to_patientMean_perAssignedPatientgroup.pdf')
p
dev.off()

```

#Patients clustering with stacked barplot of individual images, tumor images only, grouped by patient (use data including stroma for visualization)
```{r}
#Prepare
cluster_dat_tumors_stroma = cluster_dat_tumors_stroma[!location %in% c("NORMAL","METASTASIS"),]
cluster_dat_ordered_by_patient = cluster_dat_tumors_stroma[by=PID]
image_order = cluster_dat_ordered_by_patient[,c('PID','core')]
image_order = unique(image_order)
un_patients = unique(image_order$PID)
un_patients = un_patients[order(un_patients)]
o <- hc$order
#If using a new automatic clustering order
all_order = image_order[order(match(image_order$PID,un_patients[o]))]

#Read in original ordering of stacked bar plot to reproduce exact order as in Figure. The automatic ordering is not identical because some trees flipped due to different internal order of the data due to changed patient naming.
all_order = fread('/home/ubuntu/tmp/server_homes/janaf/Data/2019/Data_publication/ZurichTMA/all_order.csv')
colnames(all_order) = c('PID','core')

#Plot stacked barplot
cluster_dat_ordered_by_patient$cluster = factor(cluster_dat_ordered_by_patient$cluster, levels = rev(levels(cluster_dat_ordered_by_patient$cluster)))
p <- ggplot(cluster_dat_ordered_by_patient, aes(x=core, y=cell_density,  fill=cluster)) + 
  geom_bar(stat='identity')+
  scale_fill_manual("Clusters",values = mycols_basel_meta[as.numeric(levels(cluster_dat_ordered_by_patient$cluster))])+
  scale_x_discrete(limits = all_order$core)+
  #facet_wrap(core~)+
  labs(fill = "Clusters")+
  coord_flip()+
  xlab("Patient images")+
  ylab("Percentage of cluster cells in image")+
  theme(panel.background = element_blank(),
    axis.text.y = element_text(colour=c(col_vector,"#7FC97F",'black')[as.factor(all_order$PID)]))+
  ggtitle('Patient composition')

#If automatically clustsered plot dendrogram
# p2 <- ggdendro::ggdendrogram(hc, rotate = TRUE,labels = FALSE, theme_dendro = TRUE, leaf_labels = FALSE)+
#   theme(axis.title.x=element_blank(),
#           axis.text.x=element_blank(),
#           axis.ticks.x=element_blank(),
#           axis.title.y=element_blank(),
#           axis.text.y=element_blank(),
#           axis.ticks.y=element_blank())

#Clinical type bar
clinical_order = cluster_dat_ordered_by_patient[,c('clinical_type','PID','core')]
clinical_order = unique(clinical_order)
un_clin = unique(clinical_order$clinical_type)
all_clin_order = clinical_order[order(match(clinical_order$PID,unique(all_order$PID)))]
all_clin_order$clinical_type = factor(all_clin_order$clinical_type, levels = c('HR-HER2+','HR+HER2-','HR+HER2+','TripleNeg'))#'NORMAL'
p3 <- ggplot(all_clin_order, aes(x=1,y=c(1:length(all_clin_order$clinical_type))))+
      geom_tile(aes( fill=clinical_type))+
  scale_fill_manual(values = c(mycols_clinical,'black'))+ #'lightblue',
    theme(axis.title.x=element_blank(),
          axis.text.x=element_blank(),
          axis.ticks.x=element_blank(),
          axis.title.y=element_blank(),
          axis.text.y=element_blank(),
          axis.ticks.y=element_blank(),
          line = element_blank(),
          legend.position="none")


#Location bar
location_order = cluster_dat_ordered_by_patient[,c('location','PID','core')]
location_order = unique(location_order)
un_loc = unique(location_order$location)
all_loc_order = location_order[order(match(location_order$PID,unique(all_order$PID)))]
all_loc_order$location = factor(all_loc_order$location, levels = c('CENTER','PERIPHERY','METASTASIS','NORMAL'))#'NORMAL'
p3 <- ggplot(all_loc_order, aes(x=1,y=c(1:length(all_loc_order$location))))+
      geom_tile(aes( fill=location))+
  scale_fill_manual(values = c('red','blue','black','lightblue'))+ #'lightblue',
    theme(axis.title.x=element_blank(),
          axis.text.x=element_blank(),
          axis.ticks.x=element_blank(),
          axis.title.y=element_blank(),
          axis.text.y=element_blank(),
          axis.ticks.y=element_blank(),
          line = element_blank(),
          legend.position="none")


#SCP patient groups matched
all_pheno_order = SCP_match[order(match(SCP_match$core,all_order$core))]
all_pheno_order$patient_pheno = factor(all_pheno_order$patient_pheno)
p5 <- ggplot(all_pheno_order, aes(x=1,y=c(1:length(all_pheno_order$patient_pheno))))+
      geom_tile(aes( fill=patient_pheno))+
  scale_fill_manual(values = mycols_patient[as.numeric(levels(all_pheno_order$patient_pheno))])+ #'lightblue',
    theme(axis.title.x=element_blank(),
          axis.text.x=element_blank(),
          axis.ticks.x=element_blank(),
          axis.title.y=element_blank(),
          axis.text.y=element_blank(),
          axis.ticks.y=element_blank(),
          line = element_blank(),
          legend.position="none")

#KL divergence of each image to patient average
kldiv_ordered = data.table(names(unlist(kldiv)))
kldiv_ordered$kldiv = as.vector(unlist(kldiv))
names(kldiv_ordered)[1] = 'core'
kldiv_ordered$core = unlist(lapply(strsplit(kldiv_ordered$core,'[.]'), function(x){paste(x[2],collapse = '.')}))
add_normals = all_order$core[!all_order$core %in% kldiv_ordered$core]
kldiv_ordered = rbind(kldiv_ordered,data.frame(core = add_normals, kldiv = rep(NA,length(add_normals))))
kl_order = merge(cluster_dat_ordered_by_patient[,c('PID','core')],kldiv_ordered,by = 'core')
kl_order = unique(kl_order)
all_kl_order = kl_order[order(match(kl_order$PID,unique(all_order$PID)))]
#Colorbar for kl div from tumor means
p4 <- ggplot(all_kl_order, aes(x=1,y=c(1:length(all_kl_order$kldiv))))+
      geom_tile(aes( fill=all_kl_order$kldiv))+
  scale_fill_gradient2(low = "blue", mid = "white", high = "red")+
    theme(axis.title.x=element_blank(),
          axis.text.x=element_blank(),
          axis.ticks.x=element_blank(),
          axis.title.y=element_blank(),
          axis.text.y=element_blank(),
          axis.ticks.y=element_blank(),
          line = element_blank(),
          legend.position="none")

#Shannon entropy of each core
shannon_core = merge(cluster_dat_ordered_by_patient[,c('PID','core')],shannon_core,by = 'core')
shannon_core = unique(shannon_core)
all_shannon_order = shannon_core[order(match(shannon_core$PID,unique(all_order$PID)))]

p7 <- ggplot(all_shannon_order, aes(x=1,y=c(1:length(all_shannon_order$shannon))))+
      geom_tile(aes( fill=all_shannon_order$shannon))+
  scale_fill_gradient2(low = "blue", mid = "white", high = "purple")+
    theme(axis.title.x=element_blank(),
          axis.text.x=element_blank(),
          axis.ticks.x=element_blank(),
          axis.title.y=element_blank(),
          axis.text.y=element_blank(),
          axis.ticks.y=element_blank(),
          line = element_blank(),
          legend.position="none")

#Plot everything next to each other
p6 <- ggdraw() +
     draw_plot(p2 + scale_y_reverse(), 0, 0.005, 0.36, 0.984) +
     draw_plot(p ,0.47, 0.035, 0.5, 0.926)+
   draw_plot(p3,0.45,0,0.05,1)+
  draw_plot(p4,0.42,0,0.05,1)+
  draw_plot(p7,0.39,0,0.05,1)+
  draw_plot(p5,0.36,0,0.05,1)

pdf(file="/home/jana/Desktop/R_dat/Image_KLdivs_perc_cluster.pdf", width=15, height=50)
p6
dev.off()


```



